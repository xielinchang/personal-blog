/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80023
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 80023
 File Encoding         : 65001

 Date: 10/05/2023 23:38:06
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog_bg
-- ----------------------------
DROP TABLE IF EXISTS `blog_bg`;
CREATE TABLE `blog_bg`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_bg
-- ----------------------------
INSERT INTO `blog_bg` VALUES (1, '/public/uploads/main/bg/day01.jpg', NULL, NULL);
INSERT INTO `blog_bg` VALUES (2, '/public/uploads/main/bg/sunset01.jpg', NULL, NULL);
INSERT INTO `blog_bg` VALUES (3, '/public/uploads/main/bg/night01.jpg', NULL, NULL);

-- ----------------------------
-- Table structure for blog_bg_gif
-- ----------------------------
DROP TABLE IF EXISTS `blog_bg_gif`;
CREATE TABLE `blog_bg_gif`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_bg_gif
-- ----------------------------
INSERT INTO `blog_bg_gif` VALUES (1, '/public/uploads/main/bgGif/banner01.gif', NULL, NULL);
INSERT INTO `blog_bg_gif` VALUES (2, '/public/uploads/main/bgGif/banner00.gif', NULL, NULL);
INSERT INTO `blog_bg_gif` VALUES (3, '/public/uploads/main/bgGif/banner02.gif', NULL, NULL);

-- ----------------------------
-- Table structure for blog_comments
-- ----------------------------
DROP TABLE IF EXISTS `blog_comments`;
CREATE TABLE `blog_comments`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `comment_user_id`(`user_id`) USING BTREE,
  CONSTRAINT `comment_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 96 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_comments
-- ----------------------------
INSERT INTO `blog_comments` VALUES (6, 9, '213516gdfgf', '2023-03-21 15:51:25', '2023-03-21 15:51:28', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (88, 8, '1', '2023-03-21 16:36:34', '2023-03-21 16:36:34', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (89, 8, '哈哈哈', '2023-03-21 17:39:14', '2023-03-21 17:39:14', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (90, 8, '111', '2023-03-21 17:40:16', '2023-03-21 17:40:16', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (91, 8, '555', '2023-03-21 17:42:12', '2023-03-21 17:42:12', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (92, 8, '5224', '2023-03-21 17:44:34', '2023-03-21 17:44:34', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (93, 8, '555', '2023-03-21 17:45:20', '2023-03-21 17:45:20', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (94, 8, '156', '2023-03-21 17:57:43', '2023-03-21 17:57:43', '福建省福州市', NULL);
INSERT INTO `blog_comments` VALUES (95, 19, '非要说点什么', '2023-05-05 20:47:38', '2023-05-05 20:47:38', '福建省福州市', NULL);

-- ----------------------------
-- Table structure for blog_essay
-- ----------------------------
DROP TABLE IF EXISTS `blog_essay`;
CREATE TABLE `blog_essay`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `coverUrl` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `subtitle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `digest` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '每个标签按逗号分开',
  `domain` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `radio` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '1表示原创，2表示转载',
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_essay
-- ----------------------------
INSERT INTO `blog_essay` VALUES (25, '<h3> 1、vue的双向绑定原理是什么？里面的关键点在哪里？</h3><p><br></p><p>采用数据劫持，通过object. definePropety()劫持setter和getter在数据变</p><p>动时发送消息给订阅者，触发监听回调。</p><p><br></p><p><img src=\"http://127.0.0.1:7001/public/uploads/2023/04/22/1682178311497163.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-size: 16px;\">Object.defineProperty()方法重定义了data中属性的getter和setter方法，当data中的属性被读取或修改时会触发对应的getter或setter，在setter中通过触发相应的自定义事件来通知订阅者更新视图。而订阅者则是由编译器在模版解析时生成的Watcher实例，它们负责监听自身所关注的数据变化并执行响应函数来更新DOM视图。因此，关键点在于数据劫持和发布订阅模式的结合使用。</span></p><p style=\"line-height: 2;\"><br></p><p>双向绑定的核心： Object.defineProperty()</p><p>Object.defineProperty(obj, prop, descriptor) 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p><br></p><p>obj：要定义属性的对象</p><p>prop：要定义或修改的属性的名称或 Symbol</p><p>descriptor：要定义或修改的属性描述符</p><p>返回值：被传递给函数的对象</p><p>我们通过Object.defineProperty的get方法用来获取值 set方法用来拦截设置值</p><p><br></p><pre><code class=\"language-javascript\">  var obj = {};  //定义一个空对象\n    Object.defineProperty(obj, \'val\', {//定义要修改对象的属性\n        get: function () {\n            console.log(\'获取对象的值\')\n        },\n        set: function (newVal) { \n            console.log(\'设置对象的值：最新的值是\'+newVal);\n        }\n    });\n    obj.hello = \'hello world\'\n</code></pre><p><br></p><p><br></p><p><br></p><h3>2、实现水平垂直居中的方式？</h3><pre><code class=\"language-css\">body{\n    position:relative;\n}\n\nbox {\n    position: absolute; \n    top:0;\n    right: 0;\n    bot tom: 0;\n    left: 0;\n    margin: auto;\n}\n</code></pre><p><br></p><h3>3、常用伪元素有哪一些？</h3><p><br></p><p>:before</p><p><br></p><p>:after</p><p><br></p><p>:first-letter：向文本的第一个字母添加特殊样式。</p><p><br></p><p>:first-line:　向文本的首行添加特殊样式。</p><p><br></p><p>:before：在元素之前添加内容。(这个前端必会)　</p><p><br></p><p>:after：在元素之后添加内容。(这个前端必会)</p><p><br></p><p>::placeholder：匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效。（只支持双冒号的形式）。</p><p><br></p><p>::selection：CSS伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。（只支持双冒号的形式）。</p><p><br></p><h3>4、移动端如何适配不同屏幕尺寸？</h3><p><br></p><p>使用js修改rem值的大小</p><p><br></p><p> <a href=\"https://blog.csdn.net/qq_41988669/article/details/125361197?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168232724616800213085257%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168232724616800213085257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125361197-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E9%80%82%E9%85%8D&spm=1018.2226.3001.4187\" target=\"_blank\">媒体查询适配</a></p><p><br></p><p> <a href=\"https://blog.csdn.net/weixin_45602227/article/details/117416761?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168232379716782427483317%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168232379716782427483317&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117416761-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80&spm=1018.2226.3001.4187\" target=\"_blank\">媒体查询详解-响应式布局</a> </p><p><br></p><p>flex布局</p><p><br></p><h3>5、本地存储有哪一些？他们三者有什么区别？</h3><p><br></p><p>(1) cookies大小为4kb， sessionStorage 和localStorage 一般为5mb</p><p><br></p><p>(2) cookies可以使用setMaxAge来设置它的失效时间，</p><p>sessionStorage的失效时间是当会话关闭，localStorage是永久存储除非用户清空缓存。</p><p><br></p><p>(3) cookies会参与服务器端通信，sessionStorage 和localStorage 不会参与</p><p>服务器端通信。</p><p><br></p><p><br></p><h3>6、JS的数据类型？如何判断js的数据类型?</h3><p><br></p><p>主要数据类型: string number boolean</p><p>复合数据类型: function ob ject</p><p>特殊数据类型: undefined null</p><p><br></p><p>常见的判断方法 typeof</p><p><br></p><p>判断已知对象类型的方法 instanceof</p><p><br></p><p>根据对象的constructor判断： constructor</p><p><br></p><p>通用但很繁琐的方法： prototype</p><p><br></p><h3>7、说一下ES6的新特性有哪些？</h3><p><br></p><p> <a href=\"https://blog.csdn.net/ZLJ_999/article/details/124122540\" target=\"_blank\">https://blog.csdn.net/ZLJ_999/article/details/124122540</a> </p><p><br></p><h3>8、Let、const、var三者有什么区别？</h3><p><br></p><p>var定义的变量，可以预解析提前调用的结果是undefined，let和const定义的变量不能预解析，提前调用的结果是报错。</p><p><br></p><p>var定义的变量，变量名称可以重复，效果是重复赋值，let和const定义的变量不能重复，否则执行报错。</p><p><br></p><p>var定义的变量作用域是全局/局部作用域。let和const定义的变量如果在{}中只能在{}中调用。</p><p><br></p><p><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">let声明的变量可被重新赋值，而const声明的变量不可更改。</span></p><p><br></p><p> <a href=\"https://blog.csdn.net/qq_45799465/article/details/122892209\" target=\"_blank\">https://blog.csdn.net/qq_45799465/article/details/122892209</a> </p><p><br></p><h3>9、数组去重有哪些办法？</h3><p><br></p><p>ES6新增构造函数set，利用set具有天然去重功能</p><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 2, 3, 3, 4];\n const uniqueArr = [...new Set(arr)]; \nconsole.log(uniqueArr); // [1, 2, 3, 4]</code></pre><p><br></p><p>数组迭代，例如：</p><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 2, 3, 3, 4]; \nconst uniqueArr = []; \narr.forEach(item =&gt; { \nif (!uniqueArr.includes(item)) { \nuniqueArr.push(item);\n }\n });</code></pre><h3></h3><h3></h3><h3>10、说一下深拷贝和浅拷贝，如何自己实现一个深拷贝？</h3><p><br></p><p>浅拷贝：有两种方式，一种是把一个对象里面的所有的属性值和方法都复制给另一个对象，另一种是直接把一个对象赋给另一个对象，使得两个都指向同一个对象。</p><p><br></p><p>深拷贝：把一个对象的属性和方法一个个找出来，在另一个对象中开辟对应的空间，一个个存储到另一个对象中。</p><p><br></p><p>两者就在于，浅拷贝只是简单的复制，对对象里面的对象属性和数组属性只是复制了地址，并没有创建新的相同对象或者数组。而深拷贝是完完全全的复制一份，空间大小占用一样但是位置不同！！</p><p><br></p><p>(示例)深拷贝:拷贝还是复制,深:把一个对象中所有的属性或者方法,一个一个的找到.并且在另一个对象中开辟相应的空间,一个一个的存储到另一个对象中</p><pre><code class=\"language-javascript\">var obj1 = {\n            age: 10,\n            sex: \"男\",\n            car: [\"奔驰\", \"宝马\", \"特斯拉\", \"奥拓\"],\n            dog: {\n                name: \"大黄\",\n                age: 5,\n                color: \"黑白色\"\n            }\n        };\n \n        var obj2 = {};//空对象\n        //通过函数实现,把对象a中的所有的数据深拷贝到对象b中\n        // use recursion\n        function deepCopy(obj,targetObj){\n            for (let key in obj){\n                let item = obj[key];\n                if (item instanceof Array){//if array\n                    targetObj[key] = [];\n                    deepCopy(item,targetObj[key]);\n                }else if (item instanceof Object){//if object\n                    targetObj[key] = {};\n                    deepCopy(item,targetObj[key]);\n                }else {//normal attribute\n                    targetObj[key] = obj[key];\n                }\n            }\n        }\n        deepCopy(obj1,obj2);\n        console.dir(obj1);\n        console.dir(obj2);\n</code></pre><p> </p><p><br></p>', '/public/uploads/2023/04/22/1682178315125270.jpeg', '前端面试（一）', '面试常见题目', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-02 15:15:55', NULL);
INSERT INTO `blog_essay` VALUES (26, '<h3> 11、Vue的生命周期有哪一些？说一下它们每个阶段做什么操作？</h3><p> </p><p><br></p><p> &nbsp; &nbsp;(1) beforeCreate:数据初始化之前</p><p><br></p><p> &nbsp; &nbsp;(2) created:数据初始化之后，但未生成dom</p><p><br></p><p> &nbsp; &nbsp;(3) beforeMount: 准备生成dom</p><p><br></p><p> &nbsp; &nbsp;(4) mounted:生成dom之后</p><p><br></p><p> &nbsp; &nbsp;(5) beforeUpdate: 准备修改dom</p><p><br></p><p> &nbsp; &nbsp;(6) updated: 修改dom之后</p><p><br></p><p> &nbsp; &nbsp;(7) beforeDestroy:组件销毁之前</p><p><br></p><p> &nbsp; &nbsp;(8) destroyed:组件销毁之后</p><p style=\"text-indent: 2em;\"><br></p><p style=\"text-indent: 2em;\"><br></p><h3>12、组件通讯方式有哪一些？</h3><p><br></p><p>1、props和$emit(常用)；</p><p><br></p><p>2、$attrs和$listeners；</p><pre><code class=\"language-html\">&lt;template&gt; \n    &lt;button v-bind=\"$attrs\" v-on=\"$listeners\"&gt;\n        Click me!\n    &lt;/button&gt; \n&lt;/template&gt; \n&lt;script&gt; \nexport default { \n     name: \'MyButton\', \n } \n&lt;/script&gt;</code></pre><p style=\"text-align: start;\">在这个示例中，我们创建了一个名为<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>MyButton</code></span>的组件。在该组件内部，我们使用了<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>$attrs</code></span>实现继承父组件接收到的非prop属性，并用<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>v-bind</code></span>将它们绑定到子组件的<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>button</code></span>元素上。</p><p style=\"text-align: start;\">另外，我们使用了<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>$listeners</code></span>实现向父组件传递子组件触发的自定义事件。我们将<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>$listeners</code></span>应用于<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>v-on</code></span>指令，以使得所有来自父组件的监听器可以在子组件上运行。</p><p><br></p><p><br></p><p>3、eventBus &nbsp;中央事件总线（非父子组件间通信）；</p><p><br></p><p>4、v-model；</p><p><br></p><p>5、provide和inject；</p><p><br></p><p>6、$parent和$children；</p><p> </p><p><br></p><h3>13、Vuex有几个属性及作用？</h3><p> </p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">1.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">state</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：定义了应用程序的状态，就是我们要管理的数据。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: {\n count: 0 \n}\n })</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">2.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">getters</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：用于获取State中的状态，主要用于对state进行逻辑上的组合和应用，类似于</span><a href=\"https://so.csdn.net/so/search?q=Vue%E7%BB%84%E4%BB%B6&amp;spm=1001.2101.3001.7020\" target=\"_blank\" style=\"text-align: start;\">Vue组件</a><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">中的计算属性。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: { \ntodos: [ {\n id: 1,\n text: \'Learn Vue\', \ndone: true\n }, \n {\n id: 2, \ntext: \'Learn Vuex\', \ndone: false \n    }\n       ] }, \ngetters: { \ndoneTodos: state =&gt; { \nreturn state.todos.filter(todo =&gt; todo.done) \n}\n }\n })</code></pre><p>3.<span style=\"font-size: 19px;\">mutations</span>：用于修改state中的数据，是唯一可以修改state的地方。mutations接收state作为第一个参数，接收payload作为第二个参数。用于修改State中的状态，只能同步执行。Mutation必须是同步函数，因为它们不能处理异步行为，异步行为应该放在Action中处理。</p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: { \ncount: 0 \n}, \nmutations: { \nincrement (state) { \nstate.count++\n }\n }\n })</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">4.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">actions</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：用于异步操作和提交mutations，在actions中可以进行任何异步操作，最后再提交到mutations中同步修改state。actions接收context作为第一个参数，其中包含了state、getters和commit等属性。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: {\n count: 0 \n}, \nmutations: { \nincrement (state) { \nstate.count++\n }\n },\n actions: {\n asyncIncrement ({ commit }) { \nsetTimeout(() =&gt; { \ncommit(\'increment\')\n }, 1000) \n} \n}\n })</code></pre><p style=\"text-align: start;\">5.<span style=\"font-size: 19px;\">modules</span>：用于将store分割成模块，每个模块都拥有自己的state、mutation、action、getters和子模块，以便提高应用程序的可维护性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"> <a href=\"https://blog.csdn.net/u013517229/article/details/127906004?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vuex%20moudules&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-127906004.142^v86^koosearch_v1,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187\" target=\"_blank\">modules简单使用</a> </p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">总结：</p><p style=\"text-align: start;\">state:所有共享数据统一放到state中，与data类似</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">mutation: 类似于事件，用于改变状态</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">action: 和mutation相似，但是action是异步操作</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">getter: 类似vue中的computed，进行缓存，形成新的数据</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">modules: 分模块，大型项目一个对象管理会很臃肿</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p><br></p><p><br></p><h3>14、Vue的监听属性和计算属性有什么区别？</h3><p><br></p><p><br></p><p>computed（计算属性）：</p><p>1，监听值未在data中定义，以return返回值形式；</p><p>2，计算属性的值会被缓存，只有实例中相关依赖值改变时，才重新计算，性能好但不适合做异步请求；</p><p>3，计算属性默认只有get来读取，手动修改计算属性时，会触发手写的set函数。</p><p> </p><p>watch(监听器）：</p><p>1，监听值要在data中先定义，可以不写return返回值；</p><p>2，不支持缓存，可以做异步操作；</p><p>3，监听值改变，回调函数自动调用。</p><p> </p><h3> </h3><p><br></p><h3>15、说一下防抖和节流。怎么实现？</h3><p> &nbsp;</p><h4>防抖：</h4><pre><code class=\"language-javascript\">function debounce(fn) {\n        let timer = null;\n        return function (...args) {\n          clearTimeout(timer);\n          // 箭头函数没有自己的this，改变指向，使其指向input。同时执行fn函数\n          timer = setTimeout(() =&gt; {\n            fn.apply(this, args);\n          }, 500);\n        };\n      }</code></pre><h4>节流：</h4><p style=\"text-align: start;\">时间戳版</p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function throttle(fn, delay) {\n  let lastTime = 0;\n  return function() {\n    const context = this;\n    const args = arguments;\n    const nowTime = Date.now();\n    if (nowTime - lastTime &gt; delay) {\n      fn.apply(context, args);\n      lastTime = nowTime;\n    }\n  };\n}\n</code></pre><p style=\"text-align: start;\">定时器版：</p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function throttle(fn, delay) {\n  let timer = null;\n  return function() {\n    const context = this;\n    const args = arguments;\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  };\n}</code></pre><p><br></p><p><a href=\"https://blog.csdn.net/slient033/article/details/124359616?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168128871316800217277193%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168128871316800217277193&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124359616-null-null.142^v82^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E3%80%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F&spm=1018.2226.3001.4187\" target=\"_blank\">防抖和节流</a> </p><p> &nbsp;</p><p><br></p><h3>16、Vue的导航守卫有哪一些？</h3><p><br></p><p><br></p><p> <a href=\"https://blog.csdn.net/weixin_38083836/article/details/113932103?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168128920216800217217704%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168128920216800217217704&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-113932103-null-null.142^v82^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=Vue%E7%9A%84%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B&spm=1018.2226.3001.4187\" target=\"_blank\">路由守卫</a> </p><p><br></p><p><br></p><h3>17、你的登录拦截怎么实现的？</h3><h3> </h3><p><br></p><p style=\"text-align: start;\">1.requireAuth</p><p style=\"text-align: start;\">requireAuth属性作用是表明该路由是否需要登陆验证，在进行全局拦截时，通过该属性进行判断，该属性包含在meta属性中。</p><p> </p><p>2.router.beforeEach</p><p>beforeEach时router的钩子函数，该函数在进入每个网页之前调用，该函数接收三个参数：</p><p>①from：即将离开的路由</p><p>②to：即将要跳转的路由</p><p>③next：跳转方法，在beforeEach函数中作为结束语句调用，以实现页面跳转。</p><p>next(false)：中断当前的导航。如果浏览器的url改变了(可能是手动或浏览器按钮后退)，那么url地址会重置到from路由对应的地址。</p><p>next(’/’)或者next({path:’/’})：跳转到一个不同的地址。当前导航被中断，然后进行一个新的导航。</p><p> </p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">3.通过使用axios拦截器</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">如果要统一处理所有的http请求和响应，就需要使用axios的拦截器。通过配置http response inteceptor，当后端接口返回错误信息，让用户重新登陆</span></p><h3> </h3><p><br></p><h3>18、有用过图表吗？用的多吗？</h3><h3></h3><p><br></p><p><br></p><h3></h3><h3>19、闭包是什么？如何实现？</h3><h3> </h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>一个闭包是一个可以自己拥有独立的环境与变量的的表达式（通常是函数，因为ES6有了块级作用域的概念）。</strong></span></p><p> </p><p><br></p><h3>20、Vue2.0和vue3.0有什么区别？</h3><p> </p><p><br></p><p style=\"text-align: start;\">数据双向绑定方面</p><p style=\"text-align: start;\">Vue2使用Object.defineProperty</p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">Vue3使用ES6的新特性porxy</span></p><p> </p><p style=\"text-align: start;\">steup()函数</p><p style=\"text-align: start;\"> </p><p style=\"text-align: start;\">生命周期函数</p><p> </p><p><br></p>', '/public/uploads/2023/04/19/1681892071092678.png', '前端面试（二）', '前端面试问题', '', '前端,面试', 'VUE', '1', '2022-07-04 19:49:39', '2023-05-09 15:15:49', NULL);
INSERT INTO `blog_essay` VALUES (27, '<h3> 21、Vue常用的指令有哪些？</h3><p><br></p><p><br></p><p>(1) v-text: 渲染当前dom节点的纯文本内容</p><p><br></p><p>(2) v-html: 渲染当前dom节点的html内容</p><p><br></p><p>(3) v-pre: 用来跳过这个元素和它的子元素编译过程</p><p><br></p><p>(4) v-if、v-else-if、 v-else: 控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p><br></p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><p><br></p><p>(6) v-for:遍历dom节点</p><p><br></p><p>(7) v-once: 只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视</p><p><br></p><p>为静态内容跳过，这可以用于优化更新性能</p><p><br></p><p>(8) v-bind: 用来动态绑定属性，简写为:</p><p><br></p><p>(9) v--model: 用于在表单上创建双向数据绑定，他会忽略表单元素的value、checked、selected 的初始值</p><p><br></p><p>(10) v-on: 用来监听dom的事件</p><p><br></p><h3></h3><p><br></p><p><br></p><h3>22、v-If和v-show有什么区别？</h3><p><br></p><p><br></p><p>(4) v-if、v-else-if、 v-else: 控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p><br></p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><h3></h3><p><br></p><p><br></p><h3>23、v-for为什么要加一个key？</h3><p><br></p><p><br></p><p><br></p><p>修改dom或删除dom的时候，有了key的化，diff算法就可以更高效的识别到</p><p>这个节点，然后进行修改、删除、新增操作。</p><p><br></p><h3></h3><h3></h3><h3>24、你是如何封装一个组件的？</h3><h3></h3><p><br></p><p>使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。但是我们一般用脚手架开发项目，每个 .vue单文件就是一个组件。在另一组件import 导入，并在components中注册，子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p><p><br></p><p><br></p><p><br></p><p><br></p><h3></h3><h3>25、有自己从0到1搭建过项目吗？</h3><h3></h3><p><br></p><p>有</p><p><br></p><p><br></p><p><br></p><h3></h3><h3>26、有用过uni-app吗？</h3><h3></h3><p><br></p><p>有</p><p><br></p><p><br></p><h3></h3><h3>27、你会写后台吗？有搞过服务端渲染吗？</h3><h3></h3><h3></h3><p><br></p><p>有</p><p><br></p><p><br></p><p><br></p><h3>28、说一下你项目中遇到的难点，如何解决？</h3><p><br></p><p>制作消息提示组件的时候 ，当连续点击提示消息时，消息提示不懂怎么一个接一个放在上个消息提示的下边，而是重叠在一起。</p><p>一开始肯定是用搜索引擎查找网络资料，发现没有太相关的资料，后面去查看elementUI的源码解决的，可以自己设置一个offset高度，循环让每次点击的消息提示都有不同对应的高度，</p><h3></h3><pre><code class=\"language-javascript\">let verticalOffset = options.offset || 20\n\ninstances.forEach(item =&gt; {  \n\nverticalOffset += item.$el.offsetHeight + 16\n\n})\n</code></pre><p>消息关闭时也是一样的，要记录关闭对应的消息提示的高度，在对应高度关闭，最终达到效果</p><p><br></p><pre><code class=\"language-javascript\">Message.close = function(id, userOnClose) {\n  const len = instances.length \n let index = -1  \nlet removedHeight \n for (let i = 0; i &lt; len; i++) {   \n if (id === instances[i].id) {     \n removedHeight = instances[i].$el.offsetHeight    \n  index = i   \n   if (typeof userOnClose === \'function\') {    \n    userOnClose(instances[i])    \n  }    \n  instances.splice(i, 1)     \n break \n   }  \n}\nif (len &lt;= 1 || index === -1 || index &gt; instances.length - 1) return\r\n  for (let i = index; i &lt; len - 1; i++) {\r\n    const dom = instances[i].$el\r\n    dom.style[\'top\'] =\r\n        parseInt(dom.style[\'top\'], 10) - removedHeight - 16 + \'px\'\r\n  }\r\n}</code></pre><h3></h3><h3></h3><h3>29、Url到浏览器的一个过程有哪些步骤？</h3><p><br></p><p><br></p><p>(1) DNS解析</p><p><br></p><p>(2)TCP连接</p><p><br></p><p>(3)发送HTTP请求.</p><p><br></p><p>(4)服务器处理请求并返回需要的数据</p><p><br></p><p>(5)浏览器解析渲染页面</p><p><br></p><p>A.解析HTML， 生成DOM树，解析CSS，生成CSSOM树</p><p><br></p><p>B.将DOM树和CSSOM树结合，生成渲染树(RenderTree)</p><p><br></p><p>C. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息(位置，大小)</p><p><br></p><p>D. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p><p><br></p><p>E. Display:将像素发送给GPU,展示在页面上</p><p><br></p><p>(6)连接结束</p><h3></h3><p><br></p><h3></h3><h3></h3><h3>30、如何实现小程序的request封装及拦截？</h3><p><br></p><p> <a href=\"https://blog.csdn.net/qq_20059455/article/details/102891500?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168146875616800188570382%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168146875616800188570382&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-102891500-null-null.142^v83^insert_down38,239^v2^insert_chatgpt&utm_term=%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84request%E5%B0%81%E8%A3%85%E5%8F%8A%E6%8B%A6%E6%88%AA%EF%BC%9F&spm=1018.2226.3001.4187\" target=\"_blank\">小程序封装request</a> </p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/19/1681892140752754.jpeg', '前端面试（三）', '前端基础面试题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-04-24 11:26:51', NULL);
INSERT INTO `blog_essay` VALUES (28, '<h3> 31、在vue的项目应用中，不使用框架，怎么封装？</h3><p><br></p><p><br></p><p><br></p><p style=\"text-align: start;\">在Vue项目应用中，如果不使用框架，可以考虑以下几点来封装代码：</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">分离业务逻辑和视图层：将组件代码分离成业务逻辑和视图层两部分，业务逻辑部分可以使用ES6 class、函数等方式封装，视图层部分使用模板或JSX语法编写，在业务逻辑中通过调用视图层方法进行渲染。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">封装通用组件：对于多个组件之间存在相同或相似的逻辑或视图，可以将其封装成通用组件，提高代码复用性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">封装工具函数：对于一些通用的操作或计算，可以将其封装成工具函数，在需要的地方进行调用。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">封装API请求：对于API请求的封装，可以使用XMLHttpRequest、Fetch、Axios等方式，将请求封装成统一的接口，并提供相应的回调函数或Promise对象。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用事件总线：如果多个组件之间需要进行通信，可以使用事件总线来进行消息传递。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用状态管理：如果应用的状态比较复杂，可以使用状态管理工具如Vuex来进行状态管理，将应用的状态和行为分离开来，提高应用的可维护性和可扩展性。</p><h3></h3><h3></h3><p><br></p><p><br></p><h3>32、什么是Js原型？原型链是什么？</h3><p><br></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在JavaScript中，每个对象都有一个原型（prototype）属性，它指向另一个对象，而这个对象的原型又指向另一个对象，这样就形成了一个原型链（prototype chain）。 一个对象的原型可以通过Object.getPrototypeOf(obj)或者obj.__proto__（非标准属性）来获取，它指向了该对象的原型对象。原型对象也有自己的原型，如果它也有原型，那么它的原型又指向了另一个原型对象，这样就形成了一个原型链。 当我们访问一个对象的属性或方法时，JavaScript引擎会首先在该对象本身查找，如果找不到，就沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（Object.prototype）为止。 JavaScript中的原型和原型链是实现继承的基础，通过原型链，子类可以继承父类的属性和方法。可以通过将子类的原型指向父类的实例来实现继承。例如：</span></p><h3></h3><p><br></p><pre><code class=\"language-javascript\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, my name is ${this.name}`);\n}\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\nStudent.prototype.sayGrade = function() {\n  console.log(`I\'m in grade ${this.grade}`);\n}\nlet tom = new Student(\"Tom\", 5);\ntom.sayHello();  // 输出：Hello, my name is Tom\ntom.sayGrade();  // 输出：I\'m in grade 5</code></pre><h3></h3><h3></h3><h3></h3><h3>33、组件通讯方式有哪些？</h3><h3></h3><p><br></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>1、prop</strong></span></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>2、$emit</strong></span></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>3、sync 修饰符</strong></span></p><p style=\"text-align: start;\"><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>4、其他方式通信</strong></span></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">EventBus</span></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">Vuex</span></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">$parent</span></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">$root</span></p><p><br></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> </span><a href=\"https://blog.csdn.net/wy6250000/article/details/83793400?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168179845916782425144403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168179845916782425144403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-83793400-null-null.142^v84^control_2,239^v2^insert_chatgpt&utm_term=%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B&spm=1018.2226.3001.4187\" target=\"_blank\">详细内容</a> </p><p><br></p><p><br></p><h3>34、用闭包的原理做过哪些？</h3><h3></h3><h3></h3><p><br></p><p style=\"text-align: start;\">封装私有变量和方法：通过闭包，可以在函数外部无法访问到函数内部的变量和方法，从而实现对这些变量和方法的封装，避免了全局变量的污染。</p><p style=\"text-align: start;\">例如：</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">var user = (function(){\nvar __name = \'sven\',\n__age = 29;\nreturn {\ngetUserInfo: function(){\nreturn __name + \'-\' + __age;\n}\n}\n})();\n \nalert(user.getUserInfo());\n</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现模块化：通过使用闭包，可以将一组相关的方法和变量封装在一个函数内部，并返回一个对象，外部可以通过该对象访问到内部的方法和变量，从而实现模块化的效果。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现缓存：通过闭包，可以将一些计算结果缓存起来，避免重复计算，提高代码的性能。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现函数柯里化：通过闭包，可以将一个多参数的函数转化为多个单参数的函数，从而实现函数柯里化，提高函数的可复用性和灵活性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现回调函数：在JavaScript中，回调函数是非常常见的一种编程模式，通过闭包，可以将函数作为参数传递给另一个函数，并在另一个函数内部执行该函数，从而实现回调函数的功能。</p><p><br></p><h3></h3><h3>35、作用域是什么？</h3><h3></h3><h3></h3><p style=\"text-align: justify;\">作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域</p><p style=\"text-align: justify;\">全局作用域就是Js中最外层的作用域</p><p style=\"text-align: justify;\">函数作用域是js通过函数创建的一个独立作用域，函数可以嵌套，所以作用域也可以嵌套</p><p style=\"text-align: justify;\">Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）</p><h3 style=\"text-align: justify;\"></h3><h3></h3><h3>36、操作数组的方式有哪些？</h3><p><br></p><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">1、forEach——循环遍历</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">2、concat（）——拼接数组</span></p><p style=\"text-align: start;\">3、filter（）——过滤数组</p><p style=\"text-align: start;\">4、slice（）——截取元素</p><p style=\"text-align: start;\">5、splice（）——删除数组中的属性</p><p style=\"text-align: start;\">6、substring（） 和 substr（）</p><p style=\"text-align: start;\">7、every（）——判断数组中是否有满足</p><p style=\"text-align: start;\">8、some（）——只要有一个满足条件返回值就是true，没有满足条件的则为false</p><p style=\"text-align: start;\">9、push（）——从数组末尾追加</p><p style=\"text-align: start;\">10、unshift（）——从数组前面添加</p><p style=\"text-align: start;\">11、pop（）——从数组末尾删除</p><p style=\"text-align: start;\">12、reduce——数组求和</p><p style=\"text-align: start;\">13、reverse（）——反转数组</p><p style=\"text-align: start;\">14、sort（）——排序</p><p style=\"text-align: start;\">15、indexO（）f 和 lastIndexOf （）——查找值</p><p style=\"text-align: start;\">16、findIndex（）——查找数组中第一个满足条件的属性，并返回下标</p><p style=\"text-align: start;\">17、数组转字符串</p><p><br></p><p><br></p><p><br></p><p><br></p><h3>37、0.1 + 0.2 等于 0.3吗？为什么？如何解决？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">当计算 </span>0.1+0.2<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。当然计算机不会用无限的空间去存储这些无限循环的二进制数字，那对于这类数据该怎么处理呢？</span></p><p> <a href=\"https://blog.csdn.net/mubo970901/article/details/108052108?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168179981816800227453533%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168179981816800227453533&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-108052108-null-null.142^v84^control_2,239^v2^insert_chatgpt&utm_term=0.1%20%2B%200.2%20%E7%AD%89%E4%BA%8E%200.3%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F&spm=1018.2226.3001.4187\" target=\"_blank\">详细内容</a> </p><h3></h3><h3>38、keep-alive是什么？有哪几个生命周期阶段？</h3><p><br></p><p><br></p><h3></h3><ol><li style=\"text-align: start;\">keep-alive是什么？</li></ol><p style=\"text-align: start;\"><br>keep-alive是Vue.js的一个内置组件，它可以使被包含的组件保留状态，避免多次重渲染，提升应用性能。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">2. &nbsp;有哪几个生命周期阶段？</p><p style=\"text-align: start;\"><br>keep-alive组件有两个生命周期钩子函数：</p><ul><li style=\"text-align: start; line-height: 1.5;\">activated：被包含的组件被激活时调用，对应组件的activated生命周期钩子函数；</li><li style=\"text-align: start; line-height: 1.5;\">deactivated：被包含的组件被停用时调用，对应组件的deactivated生命周期钩子函数。<br>在keep-alive中缓存的组件也会调用常规的created、mounted和updated生命周期钩子函数，但在activated和deactivated钩子函数中，缓存的组件会暂停或恢复。</li></ul><h3></h3><p><br></p><p><br></p><h3></h3><h3>39、判断一个变量是否是数组，有哪些办法？</h3><h3></h3><ol><li style=\"text-align: start;\">使用Array.isArray()方法。该方法可以验证一个变量是否为数组类型，如果是，则返回true，否则返回false。</li></ol><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (Array.isArray(arr)) {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}\n</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用instanceof操作符。该操作符可以验证一个对象是否为某个类的实例，因为数组是Array类的实例，所以可以使用该操作符判断变量是否为数组。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (arr instanceof Array) {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用Object.prototype.toString()方法。该方法返回一个表示对象类型的字符串，因为数组的类型是Object，所以我们可以使用该方法来判断变量是否为数组。<br></p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (Object.prototype.toString.call(arr) === \'[object Array]\') {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}</code></pre><h3></h3><h3></h3><h3>40、判断一个变量是否是对象，有哪些办法？</h3><p><br></p><p style=\"text-align: start;\">使用typeof操作符。如果变量的类型是object，那么它就有可能是一个对象，但这种方法并不是很准确，因为null的类型也是object，所以需要额外判断。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (typeof obj === \'object\' && obj !== null) {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用Object.prototype.toString()方法。该方法返回一个表示对象类型的字符串，因为对象的类型是Object，所以我们可以使用该方法来判断变量是否为对象。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (Object.prototype.toString.call(obj) === \'[object Object]\') {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用instanceof操作符。该操作符可以验证一个对象是否为某个类的实例，因为对象是Object类的实例，所以我们可以使用该操作符判断变量是否为对象。<br></p><p><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (obj instanceof Object) {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/19/168189208964071.png', '前端面试（四）', '前端基础面试题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-04-23 10:51:53', NULL);
INSERT INTO `blog_essay` VALUES (29, '<h3> 41、对象/数组常用方法有哪些？</h3><p><br></p><p style=\"text-align: start;\"><strong>对象方法：</strong></p><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start; line-height: 1.5;\">Object.keys(obj)：返回一个包含对象中所有属性名称的数组。</li><li style=\"text-align: start; line-height: 1.5;\">Object.values(obj)：返回一个包含对象中所有属性值的数组。</li><li style=\"text-align: start; line-height: 1.5;\">Object.entries(obj)：返回一个包含对象中所有[属性名称，属性值]的二维数组。</li><li style=\"text-align: start; line-height: 1.5;\">Object.assign(target, ...sources)：用于将源对象的所有可枚举属性复制到目标对象中，并返回目标对象。</li></ul><p style=\"text-align: start;\"><strong>数组方法：</strong></p><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start; line-height: 1.5;\">push(item1,item2,...)：向数组末尾添加一个或多个元素，并返回新的长度。</li><li style=\"text-align: start; line-height: 1.5;\">pop()：从数组末尾移除最后一个元素，并返回该元素的值。</li><li style=\"text-align: start; line-height: 1.5;\">shift()：从数组开头移除第一个元素，并返回该元素的值。</li><li style=\"text-align: start; line-height: 1.5;\">unshift(item1,item2,...)：向数组开头添加一个或多个元素，并返回新的长度。</li><li style=\"text-align: start; line-height: 1.5;\">splice(start, deleteCount, item)：从指定索引位置开始删除指定数量的元素，并可选地插入新元素。</li><li style=\"text-align: start; line-height: 1.5;\">slice(start, end)：返回一个新数组，其中包含从开始索引到结束索引（不包括结束索引）的所有元素。</li><li style=\"text-align: start; line-height: 1.5;\">concat(item1,item2,...)：返回一个新数组，其中包含原始数组和所有指定的数组或值。</li><li style=\"text-align: start; line-height: 1.5;\">join(separator)：将数组中的所有元素转换为字符串，并使用指定的分隔符连接它们。</li><li style=\"text-align: start; line-height: 1.5;\">reverse()：将数组中的元素顺序反转。</li><li style=\"text-align: start; line-height: 1.5;\">sort()：对数组元素进行排序。如果未指定比较函数，则将其转换为字符串并按字母顺序排序。<br>以上仅是常用的一些对象和数组方法，还有许多其他方法可以根据具体需求来选择使用。</li></ul><p><br></p><p><br></p><p><br></p><h3>42、创建一个空数组/空对象有哪些方式？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">创建空数组：可以使用</span>[]<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">或</span>new Array()<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">来创建一个空数组，例如</span></p><p><br></p><pre><code class=\"language-javascript\">const arr1 = [];\nconst arr2 = new Array();</code></pre><p><br></p><ol><li style=\"text-align: start;\">创建空对象：可以使用<span style=\"color: var(--tw-prose-code);\"><code>{}</code></span>或<span style=\"color: var(--tw-prose-code);\"><code>new Object()</code></span>来创建一个空对象，例如：</li></ol><p><br></p><pre><code class=\"language-javascript\">const obj1 = {};\nconst obj2 = new Object();</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">需要注意的是，使用</span><span style=\"background-color: rgb(255, 255, 255);\">{}</span><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">和</span><span style=\"background-color: rgb(255, 255, 255);\">new Object()</span><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">创建的对象是等价的，它们都会创建一个空对象。同样的，使用</span><span style=\"background-color: rgb(255, 255, 255);\">[]</span><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">和</span><span style=\"background-color: rgb(255, 255, 255);\">new Array()</span><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">创建的数组也是等价的，它们都会创建一个空数组。 除此之外，还有一些更为简洁的方式可以创建空数组/空对象。例如，使用空的对象/数组字面量：</span></p><p><br></p><pre><code class=\"language-javascript\">const arr = [];\nconst obj = {};</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">或者使用Object.create()方法创建空对象：</span></p><pre><code >const obj = Object.create(null);</code></pre><h3></h3><h3></h3><h3>43、哪些遍历方式会改变原数组？</h3><p><br></p><ol><li style=\"text-align: start;\">push()方法<br>push()方法向数组的末尾添加一个或多个元素，并返回新的长度。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">pop()方法<br>pop()方法从数组的末尾移除最后一个元素，并返回该元素的值。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">shift()方法<br>shift()方法从数组的开头移除第一个元素，并返回该元素的值。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">unshift()方法<br>unshift()方法向数组的开头添加一个或多个元素，并返回新的长度。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">splice()方法<br>splice()方法从指定的索引位置开始删除指定数量的元素，并可选地插入新元素。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">sort()方法<br>sort()方法用于对数组中的元素进行排序。如果未指定比较函数，则将其转换为字符串并按字母顺序排序。这会改变原数组的元素顺序。</li><li style=\"text-align: start;\">reverse()方法<br>reverse()方法用于将数组中的元素顺序反转。这会改变原数组的元素顺序。<br>需要注意的是，这些方法都会直接修改原数组，因此使用它们时需要注意是否需要保留原数组的值。如果需要保留原数组，可以先复制一份，再使用这些方法对复制的数组进行操作。</li></ol><p><br></p><p><br></p><h3>44、Set和Map各是什么？</h3><p><br></p><p><br></p><ol><li style=\"text-align: start;\">Set<br>Set是一种类似于数组的数据结构，但是它的每个元素都是唯一的，没有重复的值。Set可以用于去重，例如：</li></ol><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3, 3, 4, 5, 5];\nconst set = new Set(arr);\nconsole.log(set); // Set(5) {1, 2, 3, 4, 5}</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Set提供了一些常用的方法，例如add、delete、has、clear等等，用于添加、删除、查找和清空Set中的元素。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">2. Map Map是一种类似于对象的数据结构，它也是由键值对组成的。与对象不同的是，Map的键可以是任何数据类型，而不仅仅是字符串。另外，Map中的键是唯一的，每个键对应的值也是唯一的。例如：</span></p><p><br></p><p><br></p><pre><code class=\"language-javascript\">const map = new Map();\nmap.set(\'name\', \'Tom\');\nmap.set(\'age\', 18);\nconsole.log(map); // Map(2) {\"name\" =&gt; \"Tom\", \"age\" =&gt; 18}</code></pre><p><br></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Map提供了一些常用的方法，例如set、get、delete、has、clear等等，用于添加、获取、删除、查找和清空Map中的键值对。 总的来说，Set和Map都是非常实用的数据结构，它们提供了快速、高效地去重、查找和存储数据的功能，可以在开发中大大提高代码的效率和可读性。</span></p><p><br></p><p><br></p><h3>45、介绍一下promise。</h3><p><br></p><ol><li style=\"text-align: start;\">可以解决回调地狱的问题，使得异步操作更加稳定和可控；</li></ol><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">2. &nbsp;可以使用链式调用的方式，使得代码更加优雅和简洁；</p><p style=\"text-align: start;\">3. &nbsp;可以通过then()和catch()方法分别处理异步操作成功和失败的情况，使得代码结构更加清晰和易于维护；</p><p style=\"text-align: start;\">4. &nbsp;可以使用Promise.all()方法和Promise.race()方法来处理多个异步操作的结果，使得代码更加高效和灵活。</p><p style=\"text-align: start;\"><br>需要注意的是，Promise并不是一种新的异步处理方式，它仍然是基于回调函数的异步处理方式的一种封装和升级。此外，Promise也有一些缺点，例如无法取消Promise、无法处理同步代码等等。因此，在使用Promise时需要结合实际情况进行选择和使用。</p><p><br></p><h3>46、Promise通常会解决三种问题</h3><h3>(1)链式回调</h3><h3>(2)同时发起几个异步请求，谁先有结果就拿谁的</h3><h3>(3)发起多个请求，等到所有请求后再做下一步处理</h3><h3>这三种方式promise是怎么处理的？</h3><p><br></p><h3>47、如何改变一个函数a的上下文？</h3><p><br></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">可以使用JavaScript中的call()、apply()或bind()方法来改变一个函数a的上下文。这些方法都是函数的原型方法，可以用于改变函数的this指向。</span></p><p><br></p><p><br></p><p>1. call()方法</p><p>call()方法用于调用一个函数，同时指定该函数的this值和参数。例如：</p><p><br></p><pre><code class=\"language-javascript\">\nfunction a() {\n console.log(this.name);\n}\nconst obj = {name: \'Tom\'};\na.call(obj); // 输出Tom</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，调用a函数时使用了call()方法，将a函数的this指向了obj对象，因此输出了Tom。</span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\"> 2. apply()方法 apply()方法与call()方法类似，也用于调用一个函数，同时指定该函数的this值和参数。唯一的区别是apply()方法接收的参数是一个数组。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function a(x, y) {\n  console.log(this.name, x, y);\n}\nconst obj = {name: \'Tom\'};\na.apply(obj, [1, 2]); // 输出Tom 1 2</code></pre><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，调用a函数时使用了apply()方法，将a函数的this指向了obj对象，同时将参数1和2传递给了a函数，因此输出了Tom 1 2。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">3. bind()方法 bind()方法用于创建一个新函数，并将原函数的this值绑定到指定的对象上。不同于call()和apply()方法，bind()方法不会立即执行函数，而是返回一个新的函数，可以在稍后调用。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function a() {\n  console.log(this.name);\n}\nconst obj = {name: \'Tom\'};\nconst b = a.bind(obj);\nb(); // 输出Tom</code></pre><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，使用bind()方法创建了一个新函数b，并将a函数的this值绑定到obj对象上。然后调用b函数，输出了Tom。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">需要注意的是，使用这些方法改变函数的上下文时，要注意this指向的对象是否存在，否则会出现错误。</span></p><p><br></p><p><br></p><h3>48、Call和apply有什么区别？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">JavaScript中的call()和apply()方法都是用来改变函数中this的指向的，它们的区别在于传参方式不同。 call()方法接收的是一个参数列表，而apply()方法接收的是一个数组。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function func(arg1, arg2, arg3) {\n  console.log(this, arg1, arg2, arg3);\n}\nconst obj = { name: \'Tom\' };\nfunc.call(obj, 1, 2, 3); // 输出{ name: \'Tom\' } 1 2 3\nfunc.apply(obj, [1, 2, 3]); // 输出{ name: \'Tom\' } 1 2 3</code></pre><h3></h3><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在这个例子中，func函数通过call()和apply()方法改变了this的指向，并传入了三个参数。使用call()方法时，参数是按照逗号分隔的列表形式传入的；而使用apply()方法时，参数是按照数组的形式传入的。 另外，call()方法和apply()方法的作用都是相同的，只是传参方式不同，开发者可以根据实际情况选择使用其中的一种。</span></p><h3></h3><h3>49、Evenbus是什么东西？</h3><p><br></p><p><br></p><p style=\"text-align: start;\">\"EventBus\" 是一个在前端框架中经常使用的事件发布/订阅模式的库或工具。它不是 JavaScript 或浏览器本身提供的原生功能之一，而是通过添加额外的代码来实现这种模式。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">\"EventBus\" 的主要思想是将应用程序分解为更小、更易于管理的部分（也称为组件），并使这些部分能够有效地进行通信。\"EventBus\" 基本上是一种可以处理大量自定义事件的框架或库，类似于其他编程语言中常见的“消息队列”或“事件机制”。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">当一个组件需要与另一个组件通信时，它可以以简单的方式向 EventBus 发布（广播）一个事件。然后，任何对该事件感兴趣的组件都可以通过订阅 Event Bus 上的相应事件来接收到这些事件。这使得组件之间的通信变得非常容易，同时也降低了这些组件的耦合度和维护难度。</p><p><br></p><p><br></p><p><br></p><h3>50、Vue中普通的生命周期大概有哪些？</h3><p><br></p><p><br></p><p style=\"text-align: start;\">Vue.js 中的生命周期钩子，是指 在组件实例化、更新、销毁等过程中 自动执行的一些函数，通过这些函数我们可以轻松地监控和控制组件的状态和行为。</p><p style=\"text-align: start;\">Vue.js 组件的生命周期分为8个阶段，分别是：</p><ul><li style=\"text-align: start;\">beforeCreate：在实例化时，组件的数据观测和 event/watcher 事件还未初始化，el 属性也不存在。此时不能访问组件 data、methods 等属性。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">created：数据观测和 event/watcher 事件都已创建好，但还未挂载到 DOM 前，即编译模板前，放置 all elements 钩子之前。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">beforeMount：在挂载开始之前调用，相关的 render 函数首次被调用。此时组件的 template 和 render 函数都已经编译完成。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">mounted: 表示 el 被新创建的 vm.$el元素替换，并挂载到实例上去之后调用该钩子函数。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">beforeUpdate：数据更新时，在虚拟 DOM 重新渲染和打补丁之前，调用 beforeUpdate 钩子。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在此过程中触发updated钩子。当然这个钩子函数是不能操作DOM的。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">beforeDestroy：调用 vm.$destroy()之前立即触发。该方法调用后，会立即删除当前组件实例以及子孙组件。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">destroyed：在当前实例被销毁之前调用。这个函数用于清理一些无效监听器和定时器等占用系统资源的操作。</li></ul><p style=\"text-align: start;\"><br></p><ul><li style=\"text-align: start;\">总体来说，通过钩子函数的执行顺序，可以清晰地了解到组件创建/更新/销毁的整个流程，从而更好地进行自定义逻辑和处理异常情况。</li></ul><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/22/1682149518857251.jpeg', '前端面试（五）', '前端面试基础题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-04-22 15:45:18', NULL);
INSERT INTO `blog_essay` VALUES (30, '<h3>51、父子组件生命周期执行顺序是怎么样的？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在Vue.js中，父子组件的生命周期执行顺序如下：</span></p><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeCreate()\ncreated()\nbeforeMount()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeCreate()\ncreated()\nbeforeMount()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >mounted()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >mounted()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeUpdate()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeUpdate()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >updated()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >updated()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeDestroy()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeDestroy()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >destroyed()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >destroyed()</code></pre><p style=\"text-align: start; line-height: 1.5;\"><span style=\"background-color: rgb(255, 255, 255);\"><br>在这个过程中，父组件的生命周期方法会优先于子组件的生命周期方法执行，而当父组件的生命周期方法返回时，子组件的生命周期方法才会执行。当父组件被销毁时，子组件也会随之被销毁。需要注意的是，子组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mounted()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法在父组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mounted()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法之后执行，但在父组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>updated()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法之前执行。这是因为子组件的渲染必须在父组件之后才能进行，但是子组件的数据更新需要在父组件之前进行。</span></p><p><br></p><p><br></p><h3>52、mixins有几个生命周期阶段？</h3><p><br></p><p><br></p><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">在Vue.js中，</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255);\">混入的选项和组件的选项合并后，都会按照特定的生命周期顺序调用。</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255);\">有以下生命周期阶段：</span></p><ol><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeCreate</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在实例初始化之后、数据观测 (data observation) 和 event/watcher 事件配置之前被调用。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>created</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例已经创建完成之后被调用。在这里可以进行一些数据的处理，如异步请求数据等。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeMount</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在挂载开始之前被调用。相关的 </span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>render</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\"> 函数首次被调用。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mounted</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例挂载之后调用，可以访问到 </span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>DOM</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\"> 元素，并进行相应的操作。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeUpdate</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>updated</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeDestroy</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在实例销毁之前调用。在这里可以进行一些清理工作，比如清除计时器、解绑全局事件等等。</span></li><li style=\"text-align: start;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>destroyed</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例销毁之后调用，此时所有的事件监听器都已经被移除，子实例也被销毁。<br>需要注意的是，</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">会按照数组顺序依次执行对应的生命周期函数，而组件的生命周期函数会在</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">的生命周期函数之后执行。</span></li></ol><p><br></p><p><br></p><h3>53、弹性布局，一行两列，一列固定宽，如何实现？</h3><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">可以使用弹性布局中的</span>flex<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">属性来实现一行两列的布局，其中一列固定宽可以通过设置该列的</span>flex-basis<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">属性来实现。具体实现如下：</span></p><p><br></p><pre><code class=\"language-html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"left\"&gt;固定宽度&lt;/div&gt;\n  &lt;div class=\"right\"&gt;自适应宽度&lt;/div&gt;\n&lt;/div&gt;</code></pre><pre><code class=\"language-css\">.container {\n  display: flex;\n  flex-direction: row;\n}\n.left {\n  width: 100px; /* 固定宽度 */\n  flex-basis: 100px; /* 列宽度 */\n}\n.right {\n  flex: 1; /* 自适应宽度 */\n}</code></pre><h3></h3><h3></h3><h3>54、Flex包含哪三种属性</h3><p><br></p><p style=\"text-align: start;\">在 CSS 中，\"flex\" 是一个重要的属性，是实现弹性布局 (Flexible Box Layout) 的基础。而 \"flex\" 属性包含以下三个子属性：</p><ol><li style=\"text-align: start;\">flex-grow：定义项目在剩余空间中放大的比例，默认为 0，即如果存在剩余空间，也不会放大。</li><li style=\"text-align: start;\">flex-shrink：定义项目在空间不足时缩小的比例，默认为 1，即如果空间不足，也会自动缩小。</li><li style=\"text-align: start;\">flex-basis：定义项目在分配多余空间之前，应该占据的主轴空间（即项目的原始大小），默认值为 auto，也可以设置为具体的长度或百分比。</li></ol><p style=\"text-align: start;\">这三个属性一般结合使用，例如 \"flex: 1 1 auto;\"，就表示项目既可以在剩余空间中放大，也可以在空间不足时缩小，并且占据的主轴空间为其本身的大小。</p><p style=\"text-align: start;\">总之，\"flex\" 属性是很常用的 CSS 属性，它可以帮助开发者更好地实现弹性布局，提高网页设计的灵活性和可适应性。</p><p><br></p><p><br></p><h3>55、简单描述一下同步和异步</h3><p><br></p><p>1.同步任务</p><p> &nbsp;在主线程上排队执行的任务,在最前面的任务执行完成之后,才执行后面的任务.</p><p><br></p><p>2.异步任务</p><p>指不进入主线程,而是进入了“任务队列”的任务,只有“任务队列”通知主线程,某个异步任务可执行了,该任务才会进入主线程执行.</p><p><br></p><p>异步任务: 分为宏任务 和 微任务</p><p><br></p><p>宏任务: 包含整体代码script、setTimeout、setInterval</p><p><br></p><p>微任务: Promise.then(非 new Promise)、process.nextTick(node中)</p><p><br></p><h3>56、router.push和router.replace的区别</h3><p><br></p><p><br></p><p><br></p><p style=\"text-align: start;\"><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.push</code></span><span style=\"font-size: 16px;\"> 方法会在浏览历史中新增一个记录，即可通过浏览器的“后退”按钮返回到之前的页面；而 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.replace</code></span><span style=\"font-size: 16px;\"> 方法不会新增历史记录，所以无法通过“后退”按钮返回之前的页面。</span></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">举个例子，如果我们有一个 URL 为 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 的页面（假设这是我们当前的页面），使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.push(\'/about\')</code></span><span style=\"font-size: 16px;\"> 会导航到一个新的页面，并且浏览器的 URL 地址会从 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 变成 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/about</code></span><span style=\"font-size: 16px;\">，因此用户可以通过“后退”按钮回到刚才的 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 页面。而使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.replace(\'/about\')</code></span><span style=\"font-size: 16px;\"> 也会导航到新的页面，但浏览器 URL 不会改变，因此无法通过“后退”按钮返回到之前的页面。</span></p><p style=\"text-align: start;\"><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/20/1681974396589618.png', '前端面试（六）', '前端面试基础题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-08 23:56:14', NULL);
INSERT INTO `blog_essay` VALUES (31, '<h3>1.Webpack是什么？</h3><p><br></p><p>webpack 是一个静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。</p><p><br></p><p>webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。</p><p>插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。</p><p><br></p><p><br></p><h3 style=\"text-align: start;\">2.Webpack的打包过程/打包原理/构建流程？</h3><p><br></p><p><img src=\"http://127.0.0.1:7001/public/uploads/2023/04/27/1682594499999232.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p><p>命令行执行npx webpack打包命令开始</p><p>1.初始化编译参数:从配置文件和shell命令中读取与合并参数</p><p>2.开始编译:根据上一步得到的参数初始化Compiler对象，加载所有配置的Plugin，执行对象的 run 方法开始执行编译。</p><p>3.确定入口:根据配置中的 entry 找出所有的入口文件</p><p>4.编译模块:从入口文件触发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，然后递归本步骤直到所有入口依赖的文件都进行翻译。</p><p>5.完成模块编译:在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系图。</p><p>6.输出资源：根据依赖关系图，组装成一个个包含多个模块的Chunk，再把每个Chunk转化成一个单独的文件加入到输出列表，根据配置确定输出的路径和文件名，输出。</p><p><br></p><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。</p><p><br></p><h3 style=\"text-align: start;\">3.Webpack中loader的作用/ loader是什么？</h3><p><br></p><p>Loader 是webpack中提供了一种处理多种文件格式的机制，因为webpack只认识JS和JSON，所以Loader相当于翻译官，将其他类型资源进行预处理。</p><p>用于对模块的\"源代码\"进行转换。</p><p>loader支持链式调用,**调用的顺序是从右往左。**链中的每个loader会处理之前已处理过的资源，最终变为js代码。</p><p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。</p><p><br></p><h3 style=\"text-align: start;\">4.常见的loader有哪些？</h3><p><br></p><p>less-loader:将less文件编译成css文件</p><p>开发中，我们常常会使用less预处理器编写css样式，使开发效率提高</p><p><br></p><p>css-loader:将css文件变成commonjs模块加载到js中，模块内容是样式字符串</p><p>style-loader: 创建style标签，将js中的样式资源插入标签内，并将标签添加到head中生效</p><p>ts-loader: 打包编译Typescript文件</p><p><br></p><h3>5.Plugin有什么作用？/Plugin是什么</h3><p><br></p><p>Plugin功能更强大，主要目的就是解决loader 无法实现的事情，比如打包优化和代码压缩等。</p><p>Plugin加载后，在webpack构建的某个时间节点就会触发plugin定义的功能，帮助webpack做一些事情。实现对webpack的功能扩展。</p><p><br></p><h3>6.常见的Plugin有哪些</h3><p><br></p><p>html-webpack-plugin 处理html资源，默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css）</p><p>mini-css-extract-plugin 打包过后的css在js文件里，该插件可以把css单独抽出来</p><p>clean-webpack-plugin 每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除</p><p><br></p><h3>7.Webpack 做过哪些优化手段？有哪些优化手段？</h3><p><br></p><p>tree-shaking 删除没有使用的代码 优化前端性能/提高构建速度</p><p>tree-shaking是一种基于 ES Module 规范的 Dead Code Elimination 技术打包，在打包过程中检测工程中没有引用过的模块并进行标记，删除没有引用过的模块，提高构建速度，较少程序运行时间。</p><p><br></p><h3>8.使用tree-shaking需要注意什么？</h3><p><br></p><p>1.默认mode = production ，生产环境默认开启tree-shaking功能。</p><p>2.需要是使用 ES6 规范编写模块代码,ES6的模块依赖关系是确定的，和运行时状态无关</p><p>3.尽量不写带有副作用的代码。如编写了立即执行函数，在函数里使用了外部变量等。</p><p><br></p><p><br></p><h3>9.如何利用webpack来优化前端性能？</h3><p><br></p><p><br></p><p><strong>代码压缩</strong></p><p><br></p><p><br></p><p><strong>按需加载</strong></p><p><br></p><p><br></p><p><strong>代码分割 splitChunks - 在optimization配置项中配置</strong></p><p><br></p><p>1.可以将node__mudules中代码单独打包成一个chunk输出（比如使用了jqury？）</p><p>2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包</p><p><br></p><p><br></p><p><strong>使用Dll进行分包</strong></p><p><br></p><p>正常情况下node_module会被打包成一个文件</p><p>使用dll技术，对可以将那些不常更新的框架和库进行单独打包，生成一个chunk</p><p><br></p><p><br></p><p><strong>使用路由懒加载</strong></p><p><br></p><p>在代码中所有被 import()函数引用的模块，都将打成一个单独的包，放在 chunk 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/27/1682594919650391.png', 'webpack面试题', '了解webpack打包，基础面试题', '以webpack的定义，打包过程，流程，原理以及如何优化前端代码来帮助你了解webpack', 'webpack,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-08 20:10:13', NULL);
INSERT INTO `blog_essay` VALUES (32, '<h1>一、前端基础</h1><p><br></p><h3>1.javascript的typeof返回那些数据类型?</h3><p><br></p><p>string、number、 bool、 undefined、 function、 object</p><p><br></p><p><br></p><h3>2.列举三种强制类型转换和两种隐式类型转换</h3><p><br></p><p><br></p><p>强制: . parseInt，parseFloat, number</p><p>隐式: number+string ，if 条件语句</p><p><br></p><h3>3. split()和join()的区别</h3><p><br></p><p><br></p><p>split字符串转数组</p><p>join数组转字符串</p><p><br></p><h3>4.数组方法pop () , push ()，unshift () , shift()</h3><p><br></p><p><br></p><p>pop()尾部删除，push() 尾部添加，unshift() 头部添加，shift() 头部删除</p><p><br></p><h3>5.Ajaxget和post的区别</h3><p><br></p><p>get拼在url里，post放在虚拟载体里，get大小有限制，</p><p>get 请求数据，post提交数据</p><p><br></p><p><br></p><h3>6. ajax解析json字符串</h3><p><br></p><p><br></p><pre><code class=\"language-javascript\">json.parse()</code></pre><p><br></p><h3>7.事件委托是什么</h3><p><br></p><p>利用事件冒泡让作用在自身触发的事件由父元素代替执行</p><p><br></p><p><br></p><h3>8.闭包是什么</h3><p><br></p><p>闭包就是能读取其他函数内部变量的函数,使得函数不被gc回收,闭包过多容易</p><p>导致内存泄漏</p><p><br></p><p><br></p><h3>9.如何阻止事件冒泡</h3><p><br></p><p><br></p><p>ie: ev.cancelBubble = true;</p><p>非ie: ev.stopPropagation()</p><h3></h3><h3></h3><p><br></p><h3>10.如何阻止默认事件</h3><p><br></p><p><br></p><pre><code class=\"language-javascript\">@click.prevent()\nevent.preventDefault()\n</code></pre><p><br></p><h3>11. JS延迟加载的方式</h3><p><br></p><p>defer和async ;</p><p>动态创建dom,按需异步引入</p><p><br></p><p><br></p><h3>12.写一个获取非行间样式的函数</h3><p><br></p><pre><code class=\"language-javascript\">function getStyle (obj,attr) {\n    if (obj.currentStyle) {\n    return obj.currentStyle[attr];\n    }else{\n    getComputedStyle(obj, false)[attr]\n}</code></pre><h3></h3><h3></h3><h3>13.获取页面所有的checkbox</h3><p><br></p><pre><code class=\"language-javascript\">var check=[]\nfor(const obj in arr) {\n    if(obj.type =\'checkbox\') {\n    check.push(obj)\n    }\n}</code></pre><p><br></p><p><br></p><p><br></p><h3>14. cookie在客户机上如何存储</h3><p><br></p><p>cookies就是服务器暂时存放在电脑里的文本文件,好让服务器用来辨认你的计算机。当你在浏览网站的时候，web服务器会先送一份资料放在你的计算机上，cookies会帮你在网站上所打的文字或是一些选择都记录下来，当你下次在访问同一个网站，web 服务器会先看看有没有上次留下的cookies资料，有的话就根据cookie内容判断使用者，送出特定网页。</p><p><br></p><p><br></p><h3>15.获取三个数中的最大值和最小值</h3><p><br></p><p>Math. max() //最大值Math. min() //最小值，</p><p><br></p><p><br></p><h3>16. javaScript是面向对象的，怎么体现javaScript的继承关系</h3><p><br></p><p>使用prototype</p><p><br></p><p><br></p><h3>17. form 中的input可以设置为readonly和disabled,请问两者有什么区别</h3><p><br></p><p>readonly不可编辑，可以选择复制，值可以传到后台。</p><p>disabled不可编辑，不能选择复制，值不能传到后台。</p><p><br></p><p><br></p><h3>18.列举JavaScript的三种主要数据类型, 两种复合数据类型,和两种特殊数据类型</h3><p><br></p><p>主要数据类型: string number boolean</p><p>复合数据类型: function object</p><p>特殊数据类型: undefined null</p><p><br></p><p><br></p><h3>19. ajax原理</h3><p><br></p><p>(1)创建对象; (2)打开请求; (3) 发送请求; (4)接受响应.</p><p><br></p><p><br></p><h3>20.解释什么是json</h3><p><br></p><p>(1)json是一种轻量级数据交换格式</p><p>(2)json独立于语言数据平台，json 解析器和json库支持多种语言</p><p>(3)json语法表示三种类型:值简单值(字符串，数值，布尔值，null);数组;对象</p><p><br></p><h3>21.js中三种弹出消息提醒</h3><p><br></p><p>alert; confirm; &nbsp;prompt</p><p><br></p><p><br></p><h3>22.浏览器的滚动距离</h3><p><br></p><p>可视区域距离页面顶部的距离</p><p><br></p><pre><code class=\"language-javascript\">scrollTop=document.documentElement.scrollTop||document.body.scrollTop</code></pre><p><br></p><p><br></p><h3>23.可视区的大小</h3><p><br></p><p><br></p><pre><code class=\"language-javascript\">window.innerHeight\nwindow.innerWidth</code></pre><p>(不兼容IE)</p><pre><code class=\"language-javascript\">document.documentElement.clientWidth\ndocument.documenElement.clientHeight</code></pre><p>(兼容IE)</p><p><br></p><p><br></p><h3>24.节点的类型有几种，分别是什么</h3><p><br></p><p>(1)元素节点: nodetype == 1</p><p>(2)属性节点: nodetype == 2</p><p>(3) 文本节点: nodetype == 3</p><p><br></p><p><br></p><h3>25. innerHtml和outerHtml的区别</h3><p><br></p><p>innerHtml不包括自身</p><p>outerHtml包括自身</p><p><br></p><p><br></p><h3>26.闭包的好处</h3><p><br></p><p>(1)希望一个变量长期驻扎在内存当中</p><p>(2)避免全局变量的污染.</p><p>(3)私有成员的存在</p><p>(4)安全性的提高</p><p><br></p><h3>27. 冒泡排序</h3><p><br></p><pre><code class=\"language-javascript\">function bubbleSort(arr) {\n let len = arr.length; \n     for (let i = 0; i &lt; len - 1; i++) { \n         for (let j = 0; j &lt; len - 1 - i; j++) { \n             if (arr[j] &gt; arr[j + 1]) { \n             //交换两个元素的位置 \n             [arr[j],arr[j + 1]] = [arr[j + 1], arr[j]]; \n             } \n        } \n     }\n  return arr; \n  }</code></pre><h3></h3><p><br></p><h3>28. js实现-一个函数对JavaScript中的json对象进行克隆</h3><p><br></p><pre><code class=\"language-javascript\">function() {\nvar obj = {id: 123}\nvar new0bj = JSON. parse (JSON. stringify (obj))</code></pre><h3></h3><h3></h3><h3>29. js实现一个函数，获取url参数</h3><p><br></p><pre><code class=\"language-javascript\">function getQueryString (name) {\nvar reg = new RegEXP(\"(^|&)\" + name+ \"=([^ &]*) (&|$)\",\"i\");\nvar r = window. localtion. search. substr (1). match (reg) ;\nif(r!=null) return unescape(r[2]); return null;\n}</code></pre><h3></h3><h3></h3><h3>30.写出三个使用this的典型应用</h3><p><br></p><p>事件: onclick this -&gt;发生事件的对象</p><p>构造函数: this -&gt; new 出来的object</p><p>call/apply改变this指向</p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683092237317515.jpeg', '码上前端基础面试（上）', '码上面试|前端面试题', '', '面试,码上', '其他', '1', '2022-07-04 19:49:39', '2023-05-06 11:34:40', NULL);
INSERT INTO `blog_essay` VALUES (33, '<h3>31.为什么利用多个域名来储存网站资源会更有效</h3><p><br></p><p>确保用户在不同地区能用最快的速度打开网站,其中某个域名崩溃用户也能用其它域名访问</p><p><br></p><p><br></p><h3>32.请说出三种降低页面加载时间的方法</h3><p><br></p><p>(1)压缩js, css</p><p>(2)合并js, css</p><p>(3)外部js,css放在页面底部</p><p>(4)减少dom操作</p><p><br></p><p><br></p><h3>33.文档类型的作用是什么，你知道多少种文档类型</h3><p><br></p><p><br></p><p>影响浏览器对代码的编译渲染</p><p>html2.0 xhtml html5</p><p><br></p><p><br></p><h3>34.标准模式和怪异模式的区别是什么</h3><p><br></p><p><br></p><p>盒模型解释不同</p><p><br></p><h3></h3><p>标准模式（也叫严格模式）：浏览器按照 Web 标准来解析 HTML 和 CSS，保证了页面的正确性和稳定性。在 HTML 文档中使用 &lt;!DOCTYPE&gt; 声明来指定文档类型时，浏览器会以标准模式进行渲染。这种模式一般情况下可以保证浏览器的兼容性。</p><p><br></p><p>怪异模式（也称为混杂模式、Quirks mode）：浏览器以一种比较宽松的方式解析 HTML 和 CSS，会考虑过去老版本的浏览器的渲染行为，以保证老旧网页的正常显示。在 HTML 文档没有使用或使用了错误的 &lt;!DOCTYPE&gt;声明时，浏览器会以怪异模式进行渲染。该模式下，页面的解析存在很大的不确定性，而且可能导致排版混乱、兼容性差、加载速度慢等问题。</p><p><br></p><h3>35.请解释什么是JavaScript的模块模式，并列举出实用案例</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">JavaScript 的模块模式是一种用于实现模块化编程的设计模式。使用这种模式，可以将一个大型应用程序划分为功能相对独立、易于维护和测试的小模块，同时通过封装变量和方法，避免了全局命名空间的污染。</p><p style=\"text-align: start;\">常见的 JavaScript 模块模式包括：</p><p style=\"text-align: start; line-height: 2;\">立即执行函数：将要暴露给外部的变量挂载在立即执行函数中，只能通过返回值或引用其内部方法来访问。该模式的优点是简单易用且用户无法直接访问加密方法和数据。常见案例如下：</p><pre style=\"text-align: start;\"><code class=\"language-hljs code\">(function(){\n    let privateVariable = \'I am private\'; // 私有变量\n    let publicVariable = \'I am public\'; // 公共变量\n    function privateMethod() {...}; // 私有方法\n    function publicMethod() {...}; // 公共方法\n\n    // 将公共变量和方法添加到暴露对象\n    window.myModule = {\n        publicVariable,\n        publicMethod\n    };\n})();\n</code></pre><p style=\"text-align: start; line-height: 2;\">对象字面量：使用对象字面量的方式创建模块，将要公开的方法和属性添加到返回的对象上。该模式简洁易用，适合创建工厂方法和单例模式。常见案例如下：</p><pre style=\"text-align: start;\"><code class=\"language-hljs code\">let myModule = {\n    publicVariable: \'I am public\',\n    publicMethod: function() {...},\n    privateVariable: \'I am private\',\n    privateMethod: function() {...}\n};\n</code></pre><p style=\"text-align: start; line-height: 2;\">暴露模块功能：通过将需要暴露的方法和变量添加到导出对象上，从而实现外部代码可以直接访问暴露内容的效果。这个模式通常在使用 CommonJS 或 ES6 的 export 语法时出现。</p><p style=\"text-align: start; line-height: 2;\">JavaScript 模块模式适用于任何规模的项目，可以有效地组织代码、避免全局命名空间污染，并优化代码结构。</p><p style=\"text-align: start; line-height: 2;\">还经常运用于以下案例：</p><p style=\"line-height: 2;\"> sea.js</p><p style=\"line-height: 2;\"> 命名空间</p><p><br></p><p><br></p><h3>36.你如何优化自己的代码</h3><p><br></p><p><br></p><p>(1)代码重用。</p><p>(2)避免全局变量。</p><p>(3)拆分函数避免函数过于臃肿。</p><p>(4)注释</p><p><br></p><p><br></p><h3>37. javaScript中的继承是如何工作的</h3><p><br></p><p><br></p><p>子函数中执行父构造函数，并用call/apply改变this</p><p>克隆父构造函数原型上的方法</p><p><br></p><p><br></p><h3>38. dom事件委托的原理，有什么缺点</h3><p><br></p><p>事件委托原理:事件冒泡机制</p><p><br></p><p>(1) 可以节省大量内存占用，减少事件注册</p><p>(2)可以实现当新增子对象时，无需再对其进行事件绑定</p><p>缺点:可能会出现事件误判</p><p><br></p><p><br></p><h3>39.dom选择器的优先级以及权重值计算</h3><p><br></p><p>行内样式1000</p><p>id 100</p><p>类选择器，伪类选择器，属性选择器10</p><p>标签选择器伪元素选择器1</p><p>通配符子选择器相邻选择器0</p><p><br></p><h3>40. Vue数据双向绑定的原理</h3><p><br></p><p>采用数据劫持，通过object. definePropety()劫持setter和getter在数据变动时发送消息给订阅者，触发监听回调。</p><p><br></p><h3>41.网页布局有哪几种</h3><p><br></p><p>静态;自适应;流式布局;响应式。</p><p><br></p><p><br></p><h3>42.怎么判断两个对象相等</h3><p><br></p><p>JSON.stringify(obj) = JSON.stringify (obj)</p><p><br></p><p><br></p><h3>43. Vue router 除了router- link实现跳转</h3><p><br></p><p>router. go()</p><p>router. push ()</p><p><br></p><p><br></p><h3>44. Vue router 和location. href有什么区别</h3><p><br></p><p>router是虛拟路由，不刷新页面</p><p>href是页面跳转，刷新页面</p><p><br></p><h3>48. CSS margin 重叠问题</h3><p><br></p><p><br></p><p>外间距均为正数，会选择最大的外边距作为间距</p><p>设置display: inner-block 不会出现重叠</p><p>position: absolute 也不会重叠</p><p><br></p><p><br></p><h3>49.cssx选择器优先级</h3><p><br></p><p>id&gt;类&gt;标签&gt;相邻&gt;子选择器&gt;后代选择器&gt;属性&gt;伪类</p><p><br></p><p><br></p><h3>50.跨域相关</h3><p><br></p><p>协议、域名、端口有一个不同都属于不同的域</p><p>解决方案</p><p>(1)服务器设置响应头</p><p>(2) jsonp</p><p>(3) document.domain + iframe</p><p>(4) window.name + iframe</p><p>(5) window.postMessage</p><p><br></p><p><br></p><h3>51. foreach和map的区别</h3><p><br></p><p>相同点:</p><p>(1)都是循环遍历数组中每一项</p><p>(2)每次执行都支持三个匿名参数(item, index, arr)</p><p>(3) 匿名函数中的this指向都是window .</p><p>(4)只能遍历数组</p><p>(5)都有兼容问题</p><p>不同点</p><p>(1) map速度比foreach快:</p><p>(2) map会返回一个新数组，对原数组无影响，foreach 不会产生新数组</p><p>(3) map返回数组可以链式操作，foreach不能</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683100038258363.png', '码上前端基础面试（下）', '前端面试', '', '前端,码上,面试', 'HTML', '1', '2022-07-04 19:49:39', '2023-05-06 23:31:59', NULL);
INSERT INTO `blog_essay` VALUES (34, '<h3> 1.浏览器中，从输入ur1到页面显示出来，具体的流程是什么?</h3><p><br></p><p><br></p><p>(1) DNS解析</p><p>(2) TCP连接</p><p>(3)发送HTTP请求</p><p>(4)服务器处理请求并返回需要的数据</p><p>(5)浏览器解析渲染页面</p><p>A.解析HTML,生成DOM树，解析CSS，生成CSSOM树</p><p>B.将DOM树和CSSOM树结合，生成渲染树(Render Tree)</p><p>C. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息(位置，大小)</p><p>D. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p><p>E. Display:将像素发送给GPU，展示在页面上</p><p>(6)连接结束</p><p><br></p><p><br></p><h3>2. get post 区别?</h3><p><br></p><p>(1) get在浏览器回退时不会再次发送请求，post会在此提交请求</p><p>(2) get的请求及参数会被保留在浏览器历史记录里，post不会.</p><p>(3) get提交数据有大小限制，根据浏览器来定(一般为1024字节)，post则</p><p>没有，或是根据服务器设置和内存大小来定</p><p>(4) get参数会直接暴露在地址栏里，post相对更安全</p><p>(5) get参数通过url传递，post的参数通过request body</p><p><br></p><h3>3. url最长有多少?</h3><p>根据不同浏览器长度不一致1024、2083...字节</p><p><br></p><h3>4.XsS攻击的了解?</h3><p>(1)跨站脚本攻击</p><p style=\"line-height: 2;\">(2)攻击者提交脚本数据后，网站保存到服务器数据库里，其他人访问读取到该数据浏览器会执行这段脚本。</p><p>(3)常见的xss攻击方式</p><p><br></p><pre><code >A. &lt;script&gt;alert(\' XSS\')&lt;/script&gt;:最普通的xSs\nB. &lt;script&gt;alert (document. cookie) &lt;/script&gt;:获取cookie .\nC. &lt;img src =\" javascript:alert(\' XSS\')\"&gt;:img链接地址xss\nD. &lt;script src=\' ls. js\'&gt;&lt;/script&gt;:外部攻击代码\nE. &lt;script&gt;alert/*注释*/(\' XSS\')&lt;/script&gt;:注释方法防止过滤\nF. &lt;img src = \'’onerror=alert(\'XSS\')&gt;:加载图像失败执行\nG. &lt;iframe onload = alert(\' XSS\')&gt;:框架\nH. &lt;script&gt;location = \' baidu. com\' ;&lt;/script&gt;:跳转某页面\nI. &lt;a href =\" javascript:alert(\' XSS\')\"&gt;&lt;/a&gt;:a链接的xss\nJ. body {bockground- image: url (javascript:alert(\'XSS))}:在css样式中加入</code></pre><p><br></p><p>(4)预防</p><p>A.输入内容长度控制:对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止XSS发生，但可以增加XSS 攻击的难度。</p><p>B.其他安全措施HTTP- -only Cookie: 禁止JavaScript读取某些敏感Cookie, 攻击者完成XSS注入后也无法窃取此Cookie。</p><p>验证码:防止脚本冒充用户提交危险操作。</p><p><br></p><h3>5.图片优化?</h3><p><br></p><p>懒加载;压缩;响应式;图片大小;字体图标;精灵图</p><p><br></p><p><br></p><h3>6.前后端鉴权?</h3><p><br></p><p>HTTP Basic Authentication</p><p>session-cookie</p><p>Token验证</p><p>0Auth(开放授权)</p><p><br></p><p><br></p><h3>7.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</h3><p><br></p><p>Chrome: webkit</p><p>Safari: webkit</p><p>fire fox: Gecko</p><p>Edge: Chromium</p><p>Ie: Trident</p><p><br></p><p><br></p><h3>8. pwa (Progressive Web Apps) ?</h3><p><br></p><p>(1)是Google 提出的用前沿的Web技术为网页提供App般使用体验的一系列方案。</p><p style=\"line-height: 2;\">(2)一个PWA应用首先是一个网页，可以通过Web技术编写出一个网页应用.随后添加_上App Manifest 和Service Worker来实现PWA 的安装和离线等功能。</p><p><br></p><h3>9. https有几次握手?</h3><p><br></p><p>7次握手，TCP 3次、SSL/TLS 4次</p><p><br></p><p>(了解即可)</p><p>(1) TCP: 三次握手</p><p style=\"line-height: 2;\">A.第一次握手:建立连接。客户端发送连接请求报文段，将SYN位置为1,Sequence Number 为x;然后，客户端进入SYN_ SEND状态，等待服务器的确认;</p><p style=\"line-height: 2;\">B.第二次握手:服务器收到SYN报段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认,设置Acknowl edgmentNumber为x+1 (SequenceNumber+1) ; 同时，自己自己还要发送SYN请求信息，SYN位置为1, SequenceNumber为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_ RECV 状态;</p><p style=\"line-height: 2;\">C.第三次握手:客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number 设置为y+1，向服务器发送ACK报文段这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态。</p><p style=\"line-height: 2;\">D.为什么要三次握手:为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p style=\"line-height: 2;\">(2) SSL/TLS: 四次挥手</p><p style=\"line-height: 2;\">A.第一次挥手:主机1(可以使客户端，也可以是服务器端)，设置SequenceNumber，向主机2发送一个FIN报文段;此时，主机1进入FIN_ WAIT_ 1状态;这表示主机1没有数据要发送给主机2了;</p><p style=\"line-height: 2;\">B.第二次挥手:主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文，Acknowledgment Number 为Sequence Number加1;主机1进入FIN_ _WAIT_ 2状态;主机2告诉主机1，我“同意”你的关闭请求;</p><p style=\"line-height: 2;\">C.第三次挥手:主机2向主机1发送FIN报文段,请求关闭连接，同时主机2进入LAST_ ACK状态;</p><p style=\"line-height: 2;\">D.第四次挥手:主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段,然后主机1进入TIME_ WAIT 状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了</p><p style=\"line-height: 2;\">E.为什么要四次挥手: TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时,只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了;但是，这个时候主机1还是可以接受来自主机2的数据;当 主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的;当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1,我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><br></p><p><br></p><h3>10.页面刷新不出来，是有哪些问题?</h3><p><br></p><p>(1)域名不存在，或者ip地址错误.</p><p>(2)网络问题，不能建立正常的tcp连接</p><p>(3)服务器找不到正确的资源</p><p><br></p><p><br></p><p><br></p><h3>11.请描述cookies、 sessionStorage 和localStorage 的区别?</h3><p><br></p><p><br></p><p>(1) cookies大小为4kb，sess ionStorage 和localStorage一般为5m</p><p style=\"line-height: 2;\">(2) cookies 可以使用setMaxAge来设置它的失效时间，sessionStorage的失效时间是当会话关闭，localStorage 是永久存储除非用户清空缓存。</p><p>(3) cookies会参与服务器端通信，sessionStorage和localStorage不会参与服务器端通信。</p><p><br></p><p><br></p><h3>12.为什么通常推荐将CSS&lt;link&gt; 放置在&lt;head&gt;&lt;/head&gt; 之间，而</h3><h3>将JS，&lt;script&gt;放置在&lt;/body&gt; 之前?你知道有哪些例外吗?</h3><p><br></p><p style=\"line-height: 2;\">(1) &lt;link&gt; 放置在&lt;head&gt;&lt;/head&gt; 之间可以使页面逐步呈现，防止出现空白页面，放在尾部的话部分浏览器里会阻止渲染，以避免在样式发生变化的时候重绘页面。</p><p style=\"line-height: 2;\">(2)脚本在下载和执行期间会阻止HTML解析，所以JS &lt;script&gt;放置在&lt;/body&gt;之前可以保证HTML首先解析完成，尽早将页面呈现给用户。</p><p style=\"line-height: 2;\">(3)例外:在JS里使用window. onload, 这时候把js放在&lt;script&gt;放置在&lt;head&gt;&lt;/head&gt;之间也可以保证在HTML解析完成后执行脚本。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683101032189416.webp', '浏览器面试题', '了解浏览器||浏览器面试基础题||前端', '', '浏览器,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-06 14:36:44', NULL);
INSERT INTO `blog_essay` VALUES (35, '<h3> 1. Vue mvvm? </h3><p>(1)解析</p><p>A.m: model 数据层(存储数据)</p><p>B.v: view视图层(UI用户界面)</p><p>C. vm: ViewModel 业务逻辑层(一切js可视为业务逻辑)</p><p>(2) MVVM将数据双向绑定(data-binding)作为核心思想，View和Model 之间没有联系，它们通过ViewModel 这个桥梁进行交互。</p><p>(3) Model和ViewModel 之间的交互是双向的，因此View的变化会自动同步到Model，而Model 的变化也会立即反映到View. 上 显示。</p><p>(4)当用户操作View， ViewModel 感知到变化，然后通知Model 发生相应改变;反之当Model发生改变，ViewModel也能感知到变化，使View 作出相应更新。</p><p>(5) 相比于mvc， mvvm少了c (Controller) 解析数据这一步骤</p><p><br></p><p><br></p><h3>2.Vue的双向绑定的原理是什么?</h3><p><br></p><p>(1) Vue双向绑定主要通过数据监听器、指令解析器、订阅者来进行一个双向绑定的整个流程</p><p>A.数据监听器Observer, 能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p><p>B.指令解析器Compile,对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p><p>C.订阅者Watcher, 作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p><p>(2) Vue2</p><p>A.通过Object. defineProperty属性劫持来实现双向绑定</p><p>B.缺点</p><p>object.defineProperty无法监听对象属性的删除和添加，所以类似直接通过修改数组元素，双向绑定就不会生效.</p><p>object.defineProperty只能遍历对象属性直接修改(需要深拷贝进行修改)</p><p>C. Vue3</p><p>通过Proxy来劫持</p><p><br></p><p><br></p><h3>3.Vue生命周期钩子函数有哪些?</h3><p><br></p><p>(1) beforeCreate:数据初始化之前</p><p>(2) created: 数据初始化之后，但未生成dom</p><p>(3) beforeMount: 准备生成dom</p><p>(4) mounted: 生成dom之后</p><p>(5) beforeUpdate: 准备修改dom</p><p>(6) updated: 修改dom之后</p><p>(7) beforeDestroy: 组件销毁之前</p><p>(8) destroyed: 组件销毁之后</p><p><br></p><p><br></p><h3>4.请问v-if和v-show有什么区别?</h3><p><br></p><p>(1) v-if 是控制是否删除dom。</p><p>(2) v-show 是使用css display: none 来控制是否显示隐藏。</p><p><br></p><p><br></p><h3>5. Vue常用的修饰符?</h3><p>(1) number 将用户的输入值转为数值类型</p><p>(2) trim 自动过滤用户输入的首尾空白字符</p><p>(3)事件修饰符</p><p>A.stop阻止单击事件继续传播</p><p>B. capture添加事件监听器时使用事件捕获模式</p><p>C.self 只当在event. target 是当前元素自身时触发处理函数</p><p>D. prevent阻止默认行为</p><p>E. sync &nbsp; 通常用于控制组件的显示隐藏</p><p><br></p><p><br></p><h3>6. nextTick?</h3><p><br></p><p><br></p><p>每次Vue编译后更新dom过后会触发this. $nextTick()方法，参数是回调函数</p><p><br></p><h3>7.什么是Vue生命周期?</h3><p><br></p><p>组件在初始化、生成dom、修改dom、销毁组件的整个过程</p><p><br></p><h3>8. virtual dom 原理实现?</h3><p><br></p><p>是由js来描述dom的对象，也叫虛拟dom。这个对象里面由描述这个dom节点的属性，最后需要渲染到真是dom上的时候，只需要调用render函数，也就是用虚拟dom.上的标签名、dom属性这些转换成真是的dom,最后再渲染到dom上</p><p><br></p><h3>9.Vue中key值的作用?</h3><p><br></p><p>修改dom或删除dom的时候，有了key 的化，diff 算法就可以更高效的识别到这个节点，然后进行修改、删除、新增操作。</p><p><br></p><h3>10. Vue组件中data 为什么必须是函数? </h3><p><br></p><p>如果不使用函数的话，每次创建组件data都指向的是同一个对象，使用函数的话每次创建组件都会在内存开辟一个新的空间去存放data。</p><p><br></p><h3>11. v- for与v-if的优先级?</h3><p><br></p><p>(1) v-for和v-if的优先级高。</p><p>(2)不推荐同时使用，如果需要过滤用计算属性去计算返回数组。因此哪怕我们只渲染出一小部分数组的元素,也得在每次重渲染的时候遍历整个列表。</p><p><br></p><p><br></p><h3>12.说出至少4种Vue当中的指令和它的用法?</h3><p><br></p><p>(1) v-text: 渲染当前dom节点的纯文本内容</p><p>(2) v-html: 渲染当前dom节点的html内容</p><p>(3) v-pre: 用来跳过这个元素和它的子元素编译过程</p><p>(4) v-if、 v-else-if、v-else:控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><p>(6) v-for: 遍历dom节点</p><p>(7) v-once: 只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视为静态内容跳过，这可以用于优化更新性能</p><p>(8) v-bind: 用来动态绑定属性，简写为:</p><p>(9) v-model: 用于在表单上创建双向数据绑定，他会忽略表单元素的value、checked、selected 的初始值</p><p>(10) v-on:</p><p>用来监听dom的事件</p><p><br></p><h3>13. Vue跟react的区别是什么?</h3><p><br></p><p>(1)数据流</p><p>A. Vue是双向，表单双向数据绑定</p><p>B. react是单向，表单使用onChange事件监听数据的变化</p><p>(2)模板</p><p>A. Vue是通过一种拓展的HTML语法进行渲染</p><p>B. react更倾向于原生js</p><p><br></p><h3>14. diff算法?</h3><p><br></p><p>(1)比较同层级虚拟dom .</p><p>(2)如果虛拟dom的key存在，并且选择器没有发生变化则不会重新生成虚拟dom，而是进行深层次比较</p><p>(3)在更新子节点的时候，会使用新节点和旧节点的头尾开始向中间开始比较。</p><p><br></p><p><br></p><h3>15. slot插槽、slot- -scope?</h3><p><br></p><p><br></p><pre><code class=\"language-html\">&lt;body&gt;\n&lt;div id=\" app\"&gt;\n    &lt;Test&gt;\n    &lt;div slot= ”default\" slot-scope=\" scope\"&gt;//作用域插槽的用法\n    (slot-scope)\n    {{ scope. msg }}\n    &lt;/div&gt;\n    &lt;!-- Vue2. 6.0取代了slot slot-scope的写法，但是v-slot只能写在template里--&gt;\n    &lt;template v-slot: header= \" scope\"&gt;//v-slot定义作用域插槽\n        &lt;div&gt;\n            &lt;h3&gt;slot&lt;/h3&gt;\n            &lt;p&gt; {{scope. msg}} &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/Test&gt;\n&lt;/div&gt;\n    &lt;template id=\"test\"&gt;\n        &lt;div&gt;\n            &lt;slot name=\"default\" :msg=\"msg\"&gt;&lt;/slot&gt;\n            &lt;p&gt;这里是test组件&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/body&gt;\n</code></pre><p><br></p><p><br></p><h3>16. v-model实现方法?</h3><p><br></p><p>(1)向组件里面传一个value的参数</p><p>(2) 组件改变值的时候使用this. $emit(\'input\', 参数)去修改值</p><p><br></p><p><br></p><h3>17. mixin?</h3><p><br></p><p>(1)两个类似的组件，大部分逻辑相同，可以使用mixin混入的方法抽取公共的代码逻辑</p><p>(2) mixin 的生命周期钩子函数执行顺序要大于组件</p><p><br></p><p><br></p><h3>18.动态路由注册?</h3><p><br></p><p>(1)事先配置好路由、动态配置组件导航菜单</p><p><br></p><p>(2)动态获取指定文件夹下的路由文件</p><p><br></p><pre><code class=\"language-javascript\">const files = require. context (\n//其组件目录的相对路径\n\'.. /views\'\n//是否查询其子目录\ntrue,\n// 匹配基 础组件文件名的正则表达式\n/\\. Vue/\nfiles.keys().forEach(item =&gt; {\nlet name = item. split(\'/\')[2]. replace(\'.Vue\', \");\nitems. push({\npath:`/$ {name}`,\ncomponent: files(item).default\n})\n})\n</code></pre><p><br></p><p>(3)动态添加路由:addRoutes</p><p><br></p><h3>19. Vue为什么不建议使用索引作为key?</h3><p>(1)对数组进行删除或新增的话，渲染会出现问题</p><p>(2)表单会有bug待确定</p><p><br></p><h3>20. Vue- router的钩子函数?</h3><p><br></p><p>(1)全局的路由钩子函数</p><p>A. beforeEach全局前置守卫</p><p>①每次每一个路由改变的时候都得执行一遍</p><p>②可进行一些页面跳转前处理，例如判断需要登录的页面进行拦截，做登录跳转!!</p><p>③参数</p><p>to: (Route 路由对象)即将要进入的目标路由对象to 对象下面的属性:</p><p>path params query hash fullPath matched name meta (在matched下，但是本例可以直接用)</p><p>from: (Route 路由对象)当前导航正要 离开的路由</p><p>next: (Function函数)一 定要调用该方法来resolve 这个钩子。调用方法:next(跳转地址或者空) ***必须 调用</p><p>B. afterEach:页 面加载之后</p><p>C.单个路由钩子函数: beforeEnter</p><p><br></p><pre><code class=\"language-javascript\">const router = new VueRouter({\nroutes:[\npath: \' /foo\',\ncomponent: Foo,\nbeforeEnter: (to， from， next) =&gt; {\n// ...\n}\n})</code></pre><p><br></p><p>D.组件内的路由钩子函数</p><p>①beforeRouteEnter</p><p>②beforeRouteLeave</p><p>③beforeRouteUpdate</p><pre><code class=\"language-javascript\">const Foo = {\ntemplate:\nbeforeRouteEnter (to, from, next) {\n// 在渲染该组 件的对应路由被confirm前调用\n//不!能!获取组件实例、 this\'\n//因为当钩子执行前，组件实例还没被创建\nbeforeRouteUpdate (to， from， next) {\n//在当前路由改变，但是该组件被复用时调用\n//举例来说，对于一个带有动态参数的路径/foo/:id, 在/foo/1 和\n/foo/2之间跳转的时候，\n//由于会渲染同样的Foo组件，因此组件实例会被复用。而这个钩子就\n会在这个情况下被调用。\n//可以访问组件实例、this\n},\nbeforeRouteLeave (to， from， next){\n//导航离开该组件的对应路由时调用\n. //可以访问组件实例`this`</code></pre><p><br></p><p><br></p><h3>21.如何需要动态给组件添加属性?</h3><p><br></p><pre><code class=\"language-javascript\">&lt;template&gt;\n&lt;!-- 这样就可以动态给a-button. 上添加type何shape属性了--&gt;\n&lt;a-button v-bind=\" opt ions \"&gt;&lt;/a -button&gt;\n&lt;/ template&gt;\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\nopt ions:\ntype:\' primary\',\nshape:\' circle\'\n}\n}\n&lt;/script&gt;</code></pre><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683101897799218.png', 'VUE面试题', '码上vue面试题', '', 'vue,面试', 'VUE', '1', '2022-07-04 19:49:39', '2023-05-10 14:40:34', NULL);
INSERT INTO `blog_essay` VALUES (36, '<h3> 1.你对HTML语义化的理解?</h3><p><br></p><p>语义化是指使用恰当语义的html标签，让页面具有良好的结构与含义，比</p><p>如&lt;p&gt;标签就代表段落，&lt;article&gt; 代表正文内容等等。</p><p>语义化的好处主要有两点:</p><p>开发者友好:使用语义类标签增强了可读性，开发者也能够清晰地看出网页</p><p>的结构，也更为便于团队的开发和维护。</p><p>机器友好:带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信</p><p>息，语义类还可以支持读屏软件，根据文章可以自动生成目录，这对于简书、知</p><p>乎这种富文本类的应用很重要，语义化对于其网站的内容传播有很大的帮助。</p><p><br></p><p><br></p><h3>2.你对媒体查询的理解?</h3><p><br></p><p>媒体查询由一个可选的媒体类型和零个或多个使用媒体功能的限制了样式</p><p>表范围的表达式组成，例如宽度、高度和颜色。媒体查询，添加自CSS3，允许</p><p>内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容本身,非</p><p>常适合web网页应对不同型号的设备而做出对应的响应适配。</p><p>如何使用?</p><p>媒体查询包含一个可选的媒体类型和，满足CSS3规范的条件下，包含零个</p><p>或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。</p><p>如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表</p><p>达式的值都是true,那么该媒体查询的结果为true. 那么媒体查询内的样式将</p><p>会生效。</p><p><br></p><p><br></p><h3>3.盒模型的理解</h3><p><br></p><p><br></p><p>当对一个文档进行布局(lay out) 的时候，浏览器的渲染引擎会根据标准</p><p>之一的CSS基础框盒模型(CSS basic box model)， 将所有元素表示为一个个</p><p>矩形的盒子(box)。 CSS决定这些盒子的大小、 位置以及属性(例如颜色、背</p><p>景、边框尺寸..)。</p><p>标准盒模型和怪异盒模型有什么区别?</p><p>在W3C标准下,我们定义元素的width值即为盒模型中的content的宽度值,</p><p>height值即为盒模型中的content的高度值。因此， 标准盒模型下:</p><p>元素的宽度=margin-left + border-left + padding-left + width +</p><p>padding- right + border- right + margin-right</p><p>而IE怪异盒模型(IE8 以下) width的宽度并不是content的宽度，而是</p><p>border-left + padding- 1eft + content 的宽度值+ padding -right +</p><p>border-right之和，height 同理。</p><p>在怪异盒模型下:</p><p>元素占据的宽度= margin-left + width + margin-right</p><p><br></p><p><br></p><h3>4.解释下变量提升</h3><p><br></p><p>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然</p><p>后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提</p><p>升到代码的头部，这就叫做变量提升(hoisting)。</p><p><br></p><p><br></p><h3>5.理解闭包吗?</h3><p><br></p><p>(1)闭包是什么</p><p>MDN的解释:闭包是函数和声明该函数的词法环境的组合。按照我的理 解</p><p>就是:闭包=[函数」和「函数体内可访问的变量总和」举个简单的例子:</p><p><br></p><pre><code class=\"language-javascript\">(function() {\nvar a = 1; function add() {\nvarb=2\nvar sun = b + a console. log(sum); // 3\nadd ()\n})()\nvar sum =b + a console. log(sum); // 3\nadd ()\n})()</code></pre><p><br></p><p>add函数本身，以及其内部可访问的变量，即a=1，这两个组合在一起就</p><p>被称为闭包，仅此而已。</p><p>(2)闭包的作用</p><p>闭包最大的作用就是隐藏变量，闭包的一大特性就是内部函数总是可以访问</p><p>其所在的外部函数中声明的参数和变量，即使在其外部函数被返回(寿命终结)</p><p>了之后。</p><p>基于此特性，JavaScript 可以实现私有变量、特权变量、储存变量等</p><p>我们就以私有变量举例，私有变量的实现方法很多，有靠约定的(变量名前</p><p>加_) ,有靠Proxy代理的，也有靠Symbol这种新数据类型的。</p><p>但是真正广泛流行的其实是使用闭包。</p><h3>6.变量提升</h3><p>JavaScript属于静态作用域，即声明的作用域是根据程序正文在编译时就</p><p>确定的，有时也称为词法作用域。</p><p>其本质是JavaScript在执行过程中会创造可执行上下文，可执行上下文中</p><p>的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法</p><p>环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了</p><p>作用域链。</p><p><br></p><p><br></p><h3>7. ES6 Module和CommonJS模块的区别</h3><p><br></p><p>ES6 Module 和CommonJS模块的区别:</p><p>CommonJS是对模块的浅拷贝，ES6 Module 是对模块的引用,即ES6 Module</p><p>只存只读，不能改变其值，具体点就是指针指向不能变，类似const</p><p>import的接口是read-only (只读状态)，不能修改其变量值。即不能修改</p><p>其变量的指针指向，但可以改变变量内部指针指向,可以对commonJS对重新赋</p><p>值(改变指针指向)，但是对ES6 Module赋值会编译报错。</p><p>ES6 Module 和CommonJS模块的共同点:</p><p>CommonJS和ES6 Module 都可以对引入的对象进行赋值，即对对象内部属</p><p>性的值进行改变。</p><p><br></p><p><br></p><h3>8.谈一谈你对this的了解</h3><p><br></p><p>this的指向不是在编写时确定的，而是在执行时确定的，同时，this不同的</p><p>指向在于遵循了一定的规则。</p><p>首先，在默认情况下，this 是指向全局对象的，比如在浏览器就是指向</p><p>wi ndow。</p><p>箭头函数的this指向哪里。.</p><p><br></p><p><br></p><h3>9. async/await是什么?</h3><p><br></p><p>async</p><p>函数，就是Generator函数的语法糖，它是建立在Promises上，并</p><p>且与所有现有的基于Promise的API兼容。</p><p>(1) Async- 声明一个异步函数(async function someName() {...})</p><p>(2)自动将常规函数转换成Promise, 返回值也是一-个Promise对象</p><p>(3)只有async函数内部的异步操作执行完，才会执行then方法指定的回</p><p>调函数</p><p>异步函数内部可以使用await</p><p>(1) Await- 暂停异步的功能执行(var result = await someAsyncCall);) </p><p>(2)放置在Promise调用之前，await强制其他代码等待，直到Promise</p><p>完成并返回结果</p><p>(3)只能与Promise- 起使用，不适用与回调</p><p>(4)只能在async函数内部使用</p><p><br></p><p><br></p><h3>10. async/await相比于Promise的优势?</h3><p><br></p><p>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是then的链式调</p><p>用也会带来额外的阅读负担Promise 传递中间值非常麻烦,而async/ await几乎</p><p>是同步的写法,非常优雅错误处理友好,async/await可以用成熟的try/catch,</p><p>Promise的错误捕获非常冗余调试友好，Promise的调试很差,由于没有代码块，</p><p>你不能在一个返回表达式的箭头函数中设置断点，如果你在一个. then代码块</p><p>中使用调试器的步进(step-over)功能，调试器并不会进入后续的. then代码块，</p><p>因为调试器只能跟踪同步代码的「每一步」。</p><p><br></p><p><br></p><h3>11. HTTP有哪些方法?</h3><p><br></p><p>HTTP1.0定义了三种请求方法: GET, POST 和HEAD方法; HTTP1.1新增了五</p><p>种请求方法: OPTIONS，PUT，DELETE, TRACE 和ONNECT</p><p>(1) GET:通常用于请求服务器发送某些资源</p><p>(2) HEAD:请求资源的头部信息，并且这些头部与HTTPGET 方法请求时返</p><p>回的一致;该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决</p><p>定是否要下载,以此可以节约带宽资源</p><p>(3) OPTIONS:用于 获取目的资源所支持的通信选项</p><p>(4) POST: 发送数据给服务器</p><p>(5) PUT:用于新增资源或者使用请求中的有效负载替换目标资源的表现形</p><p>式</p><p>(6) DELETE:用于删除指定的资源</p><p>(7) PATCH:用于对资源进行部分修改</p><p>(8) CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p><p>(9) TRACE:回显服务器收到的请求，主要用于测试或诊断</p><p><br></p><p><br></p><h3>12. HTTP的状态码有哪些?</h3><p><br></p><p>2XX成功</p><p>(1) 200 0K，表示从客户端发来的请求在服务器端被正确处理.</p><p>(2) 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的</p><p>需要而建立</p><p>(3) 202 Accepted 请求已接受，但是还没执行，不保证完成请求</p><p>(4) 204 No content, 表示请求成功，但响应报文不含实体的主体部分206</p><p>Partial Content， 进行范围请求</p><p>3XX重定向</p><p>(1) 301 moved permanently,永久性重定向，表示资源已被分配了新的URL</p><p>302 found, 临时性重定向，表示资源临时被分配了新的URL</p><p>(2) 303 see other,表示资源存在着另一个URL， 应使用GET方法丁香获</p><p>取资源</p><p>(3) 304 not</p><p>modified, 表示服务器允许访问资源，但因发送请求未满足</p><p>条件的情况</p><p>(4) 307 temporary redirect,临时重定向，和302含义相同4XX客户端</p><p>错误</p><p>(5) 400 bad request， 请求报文存在语法错误</p><p>(6) 401 unauthorized, 表示发送的请求需要有通过HTTP 认证的认证信</p><p>息</p><p>(7) 403 forbidden， 表示对请求资源的访问被服务器拒绝</p><p>(8) 404 not found, 表示在服务器.上没有找到请求的资源</p><p>(9) 408 Request timeout, 客户端请求超时</p><p>(10) 409 Confict， 请求的资源可能引起冲突</p><p>5XX服务器错误</p><p>(1) 500 internal sever error， 表示服务器端在执行请求时发生了错误</p><p>(2) 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持</p><p>当前请求所需要的某个功能，或者请求是服务器不支持的某个方法</p><p>(2) 503 service unavailable，表明服务器暂时处于超负载或正在停机维</p><p>护，无法处理请求505 http version not supported 服务器不支持，或者拒绝</p><p>支持在请求中使用的HTTP版本</p><p><br></p><p><br></p><h3>13.为什么有了HTTP为什么还要HTTPS?</h3><p><br></p><p>https是安全版的http，因为http协议的数据都是明文进行传输的，所以</p><p>对于一些敏感信息的传输就很不安全，HTTPS 就是为了解决HTTP的不安全而生</p><p>的。</p><h3>14.Vue生命周期的理解.</h3><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模</p><p>版、挂载Dom -&gt;渲染、更新-&gt;渲染、卸载等一系列过程，我们称这是Vue的生</p><p>命周期。</p><p><br></p><h3>15.node.js面试题</h3><p><br></p><p> <a href=\"https://blog.csdn.net/pengxian00007/article/details/118731719?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168337312616800227494188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168337312616800227494188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118731719-null-null.142^v86^koosearch_v1,239^v2^insert_chatgpt&utm_term=node%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187\" target=\"_blank\">基础面试题</a> </p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683101897832917.png', '前端面试（其他）', '码上前端前面||一些其他需要了解的面试知识', '', '其他,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-06 19:41:33', NULL);
INSERT INTO `blog_essay` VALUES (37, '<p style=\"line-height: 2;\"><br></p><p><br></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">题目：如何走好中国式现代化道路</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">学院：计算机与网络空间安全学院</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">专业：软件工程</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">学号：116052020052</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">姓名：谢林昌</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">摘要：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">本文以现代化到中国式现代化的理解进行阐述，层层递进，讲述为什么要走中国式现代化这条路，以及现在的青少年身处于中国式现代化的路线中如何理解这条道路并走好，续写激荡人心的东方传奇。</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">关键词：青少年，中国式现代化，实践，可持续发展，</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">正文：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">现代化是一个包括经济、政治、文化、社会、科技等在内的综合发展进程，是人类文明发展与进步的显著标志。在现代化中，重点关注的是对经济、文化和社会变革推进的综合推动策略。现代化极大地提高了人们的生活质量、减轻了人们的工作负担，具有极其重要的实践意义。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">中国式现代化具体来讲，包括经济、政治、文化等各个领域的现代化，相互联系及相互输入。但基础在于发展实体经济，不断扩大中产阶层，推进城市化与工业化，形成完整的中等收入群体，增加消费需求。1840 年鸦片战争以后，中国逐步成为半殖民地半封建社会，国家蒙辱、人民蒙难、文明蒙尘，中华民族遭受了前所未有的劫难。从那时起，实现中华民族伟大复兴,就成为中国人民和中华民族最伟大的梦想。为了拯救民族危亡,中国人民奋起反抗,仁人志士奔走呐喊，太平天国运动、戊戌变法、义和团运动、辛亥革命接连而起，各种救国方案轮番出合,但都以败而告终。而中国产生了共产党，则开天辟地的大事变, 100 多年来,中国共产党团结带领中国人民进行的- -切奋斗、- -切辆牲、- -切创造，就是为了把我国建设成为现代化强国，实现中华民族伟大复兴。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">首先产生了人口规模巨大的现代化,现代化的本质是人的现代化。实现“人口规模巨大的现代化\"，必须坚特人民至.上的价值理念，让现代化建设成果更多更公平惠及全体人民。新时代这10 年，更好的教育改变着无数人的命运，更稳定的工作托举起更多精彩的人生,更满意的收人充实了普通家庭的物质基础，可靠的社会保障为亿万人民的生活兜底,更高水平的医疗卫生服务护佑着人们身体健康...一个个突破性进展，-项项标志性成果,始终把实现好、维护好、发展好最广大人民根不利益作为- -切工作的出发点和落脚点。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">其次也实现了物质文明和精神文明相协调的现代化,物质富足、精神富有是社会主义现代化的根本要求。在现代化进程中，“两个文明”犹如车之两轮、鸟之两翼，只有二者相辅相成、协同发力,才能推动社会整体跃升、行稳致远。改革开放以来,我们完在推动经济快速发展的同时，大力加强社会主义精神文明建设,促进社会主义先进文化繁荣发展,使社会文明程度提高、人民精神力量不断增强。浩渺行无极，扬帆但信风。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">可以说，建设中国特色社会主义、实现中华民族伟大复兴的历史任务，就是要持续推进中国式现代化的进程。并非仅仅是快速地经济增长，而是从全方位、系统性、战略性、总体性方面对我国的先进性进行加强，以及回应世界现代文明发展趋势所要求的改革进程。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">中国式现代化具有自己独特的内涵和路径，因此，青少年需要掌握相关的知识和理论。从学校教育开始，我们应该对中国的历史和文化有更深入的了解，深化对中国式现代化的认识和理解。同时，在日常生活中积极关注国家政策和发展方向，掌握时事动态和国内外新闻信息。这不仅可以提高我们的思想觉悟，更有助于积极参与中国式现代化进程中去。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">理论知识只是中国式现代化的一部分，更重要的是将其转化为实际行动。青少年应该积极参与到社会实践和公益活动中去，提升个人素质和能力。例如，发挥自己的特长和优势，加入创新团队或者志愿服务组织，尝试解决社会问题和满足人民需求。通过实践，不仅能够推动中国式现代化的进程，还可以锤炼我们的责任心、创新能力和领导才能。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">在中国式现代化的过程中，环境保护和生态文明建设同样重要。作为青少年，我们应该具有绿色发展、低碳经济和生态文明建设等理念，为可持续发展贡献自己的力量。例如，我们可以从日常生活中入手，节约资源、减少浪费，同时促进环保产业发展，支持传统产业的绿色转型。在城市化和工业化的进程中，我们也可以通过科技创新、发展智能制造等方式，推动中国式现代化的进一步发展。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">作为青少年，我们应该从自己做起，通过多种形式积极投身于中国式现代化的实践当中。首先，我们应该树立远大的理想和抱负，在追求个人成功的同时，也要为国家和社会的发展做出自己的贡献。其次，我们应该注重提高自身素质和能力，不断学习新知识、掌握新技能，并积极参与各种实践活动和社会公益事业。特别是在科技创新领域，青少年可以结合自己的兴趣和优势，参与到各类创新竞赛和项目当中。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">此外，青少年还应该倡导可持续发展的理念，积极参与环境保护和生态文明建设。中国式现代化不能以牺牲环境和生态为代价，我们必须坚持绿色发展、低碳经济和可持续发展的道路，并为此奋斗终身。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">最后，作为青少年，我们还应该增强家国情怀，锤炼爱国精神。爱国主义是中华民族的传统美德，也是中国式现代化进程中不可缺少的因素。我们应该热爱祖国，尊崇国家法律和制度，勇于维护国家利益和民族尊严。</span></p><p><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">在中国式现代化的征程中，青少年扮演着至关重要的角色。我们应该坚定信念、勇于担当，为实现中国式现代化梦想而努力奋斗，成为当之无愧的时代新人。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">今天，我们比历史上任何时期都更按近、更有信心和能力实现中华民族伟大复兴的目标,同时必须准备付出更为艰巨、更为艰苦的努力。新时代新征程,全国人民在党的旗帜下团结成“-块坚硬的钢铁”，心往一处想、 劲往一处使，矢志不渝沿着中国式现代化这条光明大道走下去,必将续写激荡人心的东方传奇,赢得令人惊叹的大国荣光。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">注释：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">本文所使用的相关材料和观点来源于以下参考文献。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">参考文献：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">《时事报告大学生版》2021-2022学年度下学期，中共中央宣传部时事报告杂志社</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">王宏志、陈洁：《关于中国式现代化的理论思考》，人文社科出版社，2019年。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">刘建军：《中国特色社会主义形成与中国式现代化的探索历程》，江苏人民出版社，2020年。</span></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/04/1683185517288513.jpg', '形势与政策小论文', '期末大作业', '', '形势与政策', '其他', '1', '2022-07-04 19:49:39', '2023-05-04 19:42:15', NULL);

-- ----------------------------
-- Table structure for blog_record
-- ----------------------------
DROP TABLE IF EXISTS `blog_record`;
CREATE TABLE `blog_record`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `message` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of blog_record
-- ----------------------------
INSERT INTO `blog_record` VALUES (1, '2022-07-05 09:07:42', '2022-07-05 09:07:44', '海滩上的人换了一轮，又一轮。只有灼热的太阳和大海未曾变过。他们不说话，但他们什么都懂了', NULL);
INSERT INTO `blog_record` VALUES (2, '2022-07-05 09:08:12', '2022-07-05 09:08:15', '好好学习，天天向上', NULL);
INSERT INTO `blog_record` VALUES (4, '2022-10-14 20:05:33', '2022-10-14 20:05:33', '微信订餐小程序', NULL);
INSERT INTO `blog_record` VALUES (5, '2023-03-21 18:02:01', '2023-03-21 18:02:01', '最新更新', NULL);
INSERT INTO `blog_record` VALUES (6, '2023-04-27 09:38:05', '2023-04-27 09:38:05', '最新更新--改善页面，删除花里胡哨的页面样式', NULL);
INSERT INTO `blog_record` VALUES (7, '2023-04-28 13:04:04', '2023-04-28 13:04:04', 'unicorn意为独角兽', NULL);
INSERT INTO `blog_record` VALUES (8, '2023-05-09 23:25:50', '2023-05-09 23:25:50', '好忙好忙', NULL);
INSERT INTO `blog_record` VALUES (9, '2023-05-09 23:26:26', '2023-05-09 23:26:26', '太阳会是我融化，但我依然向阳', NULL);

-- ----------------------------
-- Table structure for blog_share
-- ----------------------------
DROP TABLE IF EXISTS `blog_share`;
CREATE TABLE `blog_share`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `html` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of blog_share
-- ----------------------------
INSERT INTO `blog_share` VALUES (1, '/public/uploads/2022/08/04/1659575550058157.jpg', '如果我的一生见过雪 踏过浪 也牵过爱人的手 我就变成一颗松果 变成半只贝壳 变成挣扎的心脏 于是我就不盼望春天 不赞美海底 蹦蹦跳跳 下一秒就死去 永远沉溺于失去前的最后一秒 我践踏着浪漫走向永眠走向岸边 我丰富而慷慨 帮助人们获得爱又把自己关进冬天 等另一个自己出现 ', '<p>如果我的一生见过雪 踏过浪 也牵过爱人的手 我就变成一颗松果 变成半只贝壳 变成挣扎的心脏 于是我就不盼望春天 不赞美海底 蹦蹦跳跳 下一秒就死去 永远沉溺于失去前的最后一秒 我践踏着浪漫走向永眠走向岸边 我丰富而慷慨 帮助人们获得爱又把自己关进冬天 等另一个自己出现 </p>', '2022-08-01 08:00:00', '2023-03-26 11:48:25', '1dad', NULL);
INSERT INTO `blog_share` VALUES (2, '/public/uploads/2022/08/04/1659575588104356.jpg', '哈哈哈哈哈', '<h1>这是一个测试的随笔记录</h1>', '2022-08-02 14:03:54', '2022-08-04 01:13:42', '动漫,生活', NULL);
INSERT INTO `blog_share` VALUES (3, '/public/uploads/2022/08/03/1659524422501607.jpg', '368386', '<p>你真好看</p>', '2022-09-01 17:54:30', '2022-09-01 17:54:46', '36', NULL);

-- ----------------------------
-- Table structure for comment_reply
-- ----------------------------
DROP TABLE IF EXISTS `comment_reply`;
CREATE TABLE `comment_reply`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `comment_id` int NULL DEFAULT NULL,
  `reply` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `user_id` int NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `reply_user_id`(`user_id`) USING BTREE,
  INDEX `reply_comment_id`(`comment_id`) USING BTREE,
  CONSTRAINT `reply_comment_id` FOREIGN KEY (`comment_id`) REFERENCES `blog_comments` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `reply_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment_reply
-- ----------------------------
INSERT INTO `comment_reply` VALUES (2, 6, '123', 8, '2023-03-21 15:52:16', '2023-03-21 15:52:17', NULL);
INSERT INTO `comment_reply` VALUES (4, 90, '555', 8, '2023-03-21 17:43:46', '2023-03-21 17:43:46', NULL);

-- ----------------------------
-- Table structure for default_portrait
-- ----------------------------
DROP TABLE IF EXISTS `default_portrait`;
CREATE TABLE `default_portrait`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of default_portrait
-- ----------------------------
INSERT INTO `default_portrait` VALUES (1, '/public/uploads/2022/08/03/1659524422501607.jpg', '2023-03-19 11:33:48', '2023-03-19 11:33:51');
INSERT INTO `default_portrait` VALUES (2, '/public/uploads/2022/08/03/1659525306960790.jpg', NULL, NULL);
INSERT INTO `default_portrait` VALUES (3, '/public/uploads/2022/08/04/1659575550058157.jpg', NULL, NULL);
INSERT INTO `default_portrait` VALUES (4, '/public/uploads/2022/08/04/1659575588104356.jpg', NULL, NULL);

-- ----------------------------
-- Table structure for essay_comments
-- ----------------------------
DROP TABLE IF EXISTS `essay_comments`;
CREATE TABLE `essay_comments`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `essay_id` int NULL DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `portrait` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `message` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `essay_id`(`essay_id`) USING BTREE,
  CONSTRAINT `essay_id` FOREIGN KEY (`essay_id`) REFERENCES `blog_essay` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of essay_comments
-- ----------------------------
INSERT INTO `essay_comments` VALUES (13, 25, '777', '福建省福州市', '/public/uploads/2022/08/04/1659575588104356.jpg', '哈哈哈', '2023-04-21 09:41:03', '2023-04-21 09:41:03', NULL);
INSERT INTO `essay_comments` VALUES (15, 25, '我要路过你了', '福建省福州市', '/public/uploads/2023/04/21/1682061056437239.png', '🙃', '2023-04-22 23:56:06', '2023-04-22 23:56:06', NULL);
INSERT INTO `essay_comments` VALUES (16, 29, '我要路过你了', '福建省福州市', '/public/uploads/2023/04/21/1682061056437239.png', '我测试一下', '2023-05-04 23:22:04', '2023-05-04 23:22:04', NULL);
INSERT INTO `essay_comments` VALUES (17, 32, '我要路过你了', '福建省福州市', '/public/uploads/2023/04/21/1682061056437239.png', '这个不错', '2023-05-08 17:17:55', '2023-05-08 17:17:55', NULL);
INSERT INTO `essay_comments` VALUES (18, 31, '我要路过你了', '福建省福州市', '/public/uploads/2023/04/21/1682061056437239.png', '111', '2023-05-08 20:31:45', '2023-05-08 20:31:45', NULL);
INSERT INTO `essay_comments` VALUES (19, 31, '我要路过你了', '福建省福州市', '/public/uploads/2023/04/21/1682061056437239.png', '222', '2023-05-08 20:31:53', '2023-05-08 20:31:53', NULL);

-- ----------------------------
-- Table structure for essay_detail
-- ----------------------------
DROP TABLE IF EXISTS `essay_detail`;
CREATE TABLE `essay_detail`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `essay_id` int NULL DEFAULT NULL,
  `good` int NULL DEFAULT NULL,
  `collect` int NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `essay_data_id`(`essay_id`) USING BTREE,
  CONSTRAINT `essay_data_id` FOREIGN KEY (`essay_id`) REFERENCES `blog_essay` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of essay_detail
-- ----------------------------
INSERT INTO `essay_detail` VALUES (21, 25, 1, 3, '2023-04-10 23:28:52', '2023-04-22 15:55:31');
INSERT INTO `essay_detail` VALUES (22, 26, 0, 1, '2023-04-25 14:21:22', '2023-04-25 14:21:22');

-- ----------------------------
-- Table structure for record_default
-- ----------------------------
DROP TABLE IF EXISTS `record_default`;
CREATE TABLE `record_default`  (
  `id` int NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of record_default
-- ----------------------------
INSERT INTO `record_default` VALUES (1, '爱尔兰语Coisíní，翻译过来意为“怦然心动”', 'Coisíní', '/public/uploads/2023/05/09/1683646933795721.jpg', '2023-03-23 14:49:47', '2023-05-09 23:45:16');

-- ----------------------------
-- Table structure for save_essay
-- ----------------------------
DROP TABLE IF EXISTS `save_essay`;
CREATE TABLE `save_essay`  (
  `id` int NOT NULL,
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `coverUrl` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `subtitle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `digest` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '每个标签按逗号分开',
  `domain` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `radio` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '1表示原创，2表示转载',
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of save_essay
-- ----------------------------
INSERT INTO `save_essay` VALUES (0, '<p> </p>', '', '', '', '', '', 'NODE', NULL, '2022-07-04 19:49:39', '2023-05-09 11:24:55');

-- ----------------------------
-- Table structure for save_share
-- ----------------------------
DROP TABLE IF EXISTS `save_share`;
CREATE TABLE `save_share`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `html` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of save_share
-- ----------------------------
INSERT INTO `save_share` VALUES (0, NULL, '', '<p> </p>', '2023-05-09 23:18:52', '2023-05-09 23:19:25', '');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `identity` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `portrait` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (7, 'qqq', 'd8728532b9113159a897a580d0c1f99a', 'qqqq', '游客', '2022-09-24 12:38:43', '2023-05-09 23:33:42', '/public/uploads/2023/05/09/1683646422314456.png', NULL);
INSERT INTO `user` VALUES (8, '123456', '14e1b600b1fd579f47433b88e8d85291', '我要路过你了', '管理员', '2022-09-27 14:56:36', '2023-05-09 23:05:19', '/public/uploads/2023/04/21/1682061056437239.png', NULL);
INSERT INTO `user` VALUES (9, 'aaa', 'd4fbb7d8d5603db43ac2094f5955787c', 'aaaaa', '游客', '2022-10-12 08:44:11', '2022-10-12 08:44:11', '/public/uploads/2023/03/19/1679193091369277.jpeg', NULL);
INSERT INTO `user` VALUES (10, '123', 'd9b1d7db4cd6e70935368a1efb10e377', '12345', '游客', '2023-03-17 09:49:06', '2023-03-19 10:31:31', '/public/uploads/2023/03/19/1679193091369277.jpeg', NULL);
INSERT INTO `user` VALUES (18, '6666', 'd10f5ff10a6985db3e6802e9ed9d2bb9', '6666', '游客', '2023-03-19 11:52:47', '2023-03-19 11:52:47', '/public/uploads/2022/08/03/1659524422501607.jpg', NULL);
INSERT INTO `user` VALUES (19, '777777', 'c8929accccba45e09481353d863c44af', '777', '游客', '2023-03-23 14:21:07', '2023-03-23 14:21:07', '/public/uploads/2022/08/04/1659575588104356.jpg', NULL);

-- ----------------------------
-- Table structure for user_detail
-- ----------------------------
DROP TABLE IF EXISTS `user_detail`;
CREATE TABLE `user_detail`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL,
  `collect` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '收藏的文章id，以‘，’隔开',
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `good` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  CONSTRAINT `user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_detail
-- ----------------------------
INSERT INTO `user_detail` VALUES (1, 10, '19,20', '2023-03-19 14:30:02', '2023-03-19 10:53:12', '19,20');
INSERT INTO `user_detail` VALUES (3, 19, '21,25', '2023-03-23 14:21:49', '2023-04-22 15:55:31', ',20,25');
INSERT INTO `user_detail` VALUES (4, 8, ',25,26', '2023-03-23 14:27:23', '2023-04-25 14:21:22', '');

SET FOREIGN_KEY_CHECKS = 1;
