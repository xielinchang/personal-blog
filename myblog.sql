/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80023
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 80023
 File Encoding         : 65001

 Date: 01/09/2023 21:22:48
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for aboutme_detail
-- ----------------------------
DROP TABLE IF EXISTS `aboutme_detail`;
CREATE TABLE `aboutme_detail`  (
  `id` int NOT NULL,
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `qq` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `phone` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `techniques` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `web_declare` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of aboutme_detail
-- ----------------------------
INSERT INTO `aboutme_detail` VALUES (1, '307001300@qq.com', '307001300', '15860128125', '前端三件套,vue2,webpack, node.js,egg.js,mysql,vue3', '本站由vue2  mysql  node.js(egg) sass 等技术栈搭建，所有内容仅供学习，建站初心只是为了自身学习分享，目前正处于学习过程且在不断完善网站，欢迎留言指出不足~');

-- ----------------------------
-- Table structure for blog_essay
-- ----------------------------
DROP TABLE IF EXISTS `blog_essay`;
CREATE TABLE `blog_essay`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `coverUrl` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `subtitle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `digest` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '每个标签按逗号分开',
  `domain` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `radio` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '1表示原创，2表示转载',
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `state` int NULL DEFAULT NULL COMMENT '1为发布，2为不发布',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 56 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_essay
-- ----------------------------
INSERT INTO `blog_essay` VALUES (25, '<h3>移动端如何适配不同屏幕尺寸？</h3><p><br></p><p>使用js修改rem值的大小</p><p><br></p><p> <a href=\"https://blog.csdn.net/qq_41988669/article/details/125361197?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168232724616800213085257%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168232724616800213085257&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125361197-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E9%80%82%E9%85%8D&spm=1018.2226.3001.4187\" target=\"_blank\">媒体查询适配</a></p><p><br></p><p> <a href=\"https://blog.csdn.net/weixin_45602227/article/details/117416761?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168232379716782427483317%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168232379716782427483317&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117416761-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80&spm=1018.2226.3001.4187\" target=\"_blank\">媒体查询详解-响应式布局</a> </p><p><br></p><p>flex布局</p><p><br></p><h3>本地存储有哪一些？他们三者有什么区别？</h3><p><br></p><p>(1) cookies大小为4kb， sessionStorage 和localStorage 一般为5mb</p><p><br></p><p>(2) cookies可以使用setMaxAge来设置它的失效时间，</p><p>sessionStorage的失效时间是当会话关闭，localStorage是永久存储除非用户清空缓存。</p><p><br></p><p>(3) cookies会参与服务器端通信，sessionStorage 和localStorage 不会参与</p><p>服务器端通信。</p><p><br></p><p><br></p><h3>JS的数据类型？如何判断js的数据类型?</h3><p><br></p><p>主要数据类型: string number boolean</p><p>复合数据类型: function object</p><p>特殊数据类型: undefined null</p><p><br></p><p>常见的判断方法 typeof</p><p><br></p><p>判断已知对象类型的方法 instanceof</p><p><br></p><p>根据对象的constructor判断： constructor</p><p><br></p><p>通用但很繁琐的方法： prototype</p><h3></h3><h3>Let、const、var三者有什么区别？</h3><p><br></p><p>var定义的变量，可以预解析提前调用的结果是undefined，let和const定义的变量不能预解析，提前调用的结果是报错（不能变量提升）。</p><p><br></p><p>var定义的变量，变量名称可以重复，效果是重复赋值，let和const定义的变量不能重复，否则执行报错。</p><p><br></p><p>var定义的变量作用域是全局/局部作用域。let和const定义的变量如果在{}中只能在{}中调用。</p><p><br></p><p><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">let声明的变量可被重新赋值，而const声明的变量不可更改。</span></p><p><br></p><h3>数组去重有哪些办法？</h3><p><br></p><p>ES6新增构造函数set，利用set具有天然去重功能</p><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 2, 3, 3, 4];\n const uniqueArr = [...new Set(arr)]; \nconsole.log(uniqueArr); // [1, 2, 3, 4]</code></pre><p><br></p><p>数组迭代，例如：</p><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 2, 3, 3, 4]; \nconst uniqueArr = []; \narr.forEach(item =&gt; { \nif (!uniqueArr.includes(item)) { \nuniqueArr.push(item);\n }\n });</code></pre><h3></h3><h3>说一下深拷贝和浅拷贝？</h3><p><br></p><p>浅拷贝：有两种方式，一种是把一个对象里面的所有的属性值和方法都复制给另一个对象，另一种是直接把一个对象赋给另一个对象，使得两个都指向同一个对象。</p><p><br></p><p>深拷贝：把一个对象的属性和方法一个个找出来，在另一个对象中开辟对应的空间，一个个存储到另一个对象中。</p><p><br></p><p>两者就在于，浅拷贝只是简单的复制，对对象里面的对象属性和数组属性只是复制了地址，并没有创建新的相同对象或者数组。而深拷贝是完完全全的复制一份，空间大小占用一样但是位置不同！！</p><p><br></p><p>(示例)深拷贝:拷贝还是复制,深:把一个对象中所有的属性或者方法,一个一个的找到.并且在另一个对象中开辟相应的空间,一个一个的存储到另一个对象中</p><p><br></p><p>对于普通数组（数组元素为数字或者字符串），深拷贝很简单，拷贝之后两个数组指针指向的存储地址不同，从而完成深拷贝</p><pre><code class=\"language-javascript\">\n\nar test = [1,2,3];//原数组\n\nvar testCopy = [].concat(test);//拷贝数组\n\ntestCopy[0]=4;\n\nconsole.log(test);// [1,2,3]\n\nconsole.log(testCopy);//[4,2,3]\n</code></pre><p> </p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">对于对象数组</span></p><p style=\"line-height: 2;\">方案1：JSON（不推荐）</p><pre><code class=\"language-javascript\">var test = [{\"name\":\"demi\"},{\"name\":\"lily\"}];//原数组\n\nvar testCopy = [].concat(JSON.parse(JSON.stringify(test ))); //拷贝数组\n\ntestCopy[1].name=\"test\";\n\nconsole.log(test);// [{\"name\":\"demi\"},{\"name\":\"test\"}]\n\nconsole.log(testCopy);//[{\"name\":\"demi\"},{\"name\":\"test\"}]\n\n// undefined，Function，Symbol 时，它被忽略掉\n// Infinity，NaN 会被变成 null\n// Date 对象会被转化为 String (默认调用date.toISOString())\n</code></pre><p>方案2：lodash的cloneDeep（推荐）</p><pre><code class=\"language-javascript\">const _ = require(\'lodash\');\n \nlet one_brand = [\n    {name: \'A\', count: 1, value: Infinity},\n    {name: \'B\', count: 2},\n]\n \n// 深拷贝\nlet two_brand = _.cloneDeep(one_brand);\n</code></pre><h3></h3><h3>Vue的生命周期有哪一些？说一下它们每个阶段做什么操作？</h3><p><br></p><p> &nbsp; &nbsp;(1) beforeCreate:数据初始化之前</p><p><br></p><p> &nbsp; &nbsp;(2) created:数据初始化之后，但未生成dom</p><p><br></p><p> &nbsp; &nbsp;(3) beforeMount: 准备生成dom</p><p><br></p><p> &nbsp; &nbsp;(4) mounted:生成dom之后</p><p><br></p><p> &nbsp; &nbsp;(5) beforeUpdate: 准备修改dom</p><p><br></p><p> &nbsp; &nbsp;(6) updated: 修改dom之后</p><p><br></p><p> &nbsp; &nbsp;(7) beforeDestroy:组件销毁之前</p><p><br></p><p> &nbsp; &nbsp;(8) destroyed:组件销毁之后</p><p style=\"text-indent: 2em;\"><br></p><h3>组件通讯方式有哪一些？</h3><p><br></p><p>1、props和$emit(常用)；</p><p><br></p><p>2、$attrs和$listeners；</p><p><br></p><p>3、eventBus &nbsp;中央事件总线（非父子组件间通信）；</p><p><br></p><p>4、v-model；</p><p><br></p><p>5、provide和inject；</p><p><br></p><p>6、$parent和$children；</p><p> </p><h3>Vuex有几个属性及作用？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">1.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">state</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：定义了应用程序的状态，就是我们要管理的数据。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: {\n count: 0 \n}\n })</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">2.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">getters</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：用于获取State中的状态，主要用于对state进行逻辑上的组合和应用，类似于</span><a href=\"https://so.csdn.net/so/search?q=Vue%E7%BB%84%E4%BB%B6&amp;spm=1001.2101.3001.7020\" target=\"_blank\" style=\"text-align: start;\">Vue组件</a><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">中的计算属性。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: { \ntodos: [ {\n id: 1,\n text: \'Learn Vue\', \ndone: true\n }, \n {\n id: 2, \ntext: \'Learn Vuex\', \ndone: false \n    }\n       ] }, \ngetters: { \ndoneTodos: state =&gt; { \nreturn state.todos.filter(todo =&gt; todo.done) \n}\n }\n })</code></pre><p>3.<span style=\"font-size: 19px;\">mutations</span>：用于修改state中的数据，是唯一可以修改state的地方。mutations接收state作为第一个参数，接收payload作为第二个参数。用于修改State中的状态，只能同步执行。Mutation必须是同步函数，因为它们不能处理异步行为，异步行为应该放在Action中处理。</p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: { \ncount: 0 \n}, \nmutations: { \nincrement (state) { \nstate.count++\n }\n }\n })</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">4.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">actions</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：用于异步操作和提交mutations，在actions中可以进行任何异步操作，最后再提交到mutations中同步修改state。actions接收context作为第一个参数，其中包含了state、getters和commit等属性。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: {\n count: 0 \n}, \nmutations: { \nincrement (state) { \nstate.count++\n }\n },\n actions: {\n asyncIncrement ({ commit }) { \nsetTimeout(() =&gt; { \ncommit(\'increment\')\n }, 1000) \n} \n}\n })</code></pre><p style=\"text-align: start;\">5.<span style=\"font-size: 19px;\">modules</span>：用于将store分割成模块，每个模块都拥有自己的state、mutation、action、getters和子模块，以便提高应用程序的可维护性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"> <a href=\"https://blog.csdn.net/u013517229/article/details/127906004?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vuex%20moudules&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-127906004.142^v86^koosearch_v1,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187\" target=\"_blank\">modules简单使用</a> </p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">总结：</p><p style=\"text-align: start;\">state:所有共享数据统一放到state中，与data类似</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">mutation: 类似于事件，用于改变状态</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">action: 和mutation相似，但是action是异步操作</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">getter: 类似vue中的computed，进行缓存，形成新的数据</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">modules: 分模块，大型项目一个对象管理会很臃肿</p><p style=\"text-align: start;\"><br></p><h3>Vue的监听属性和计算属性有什么区别？</h3><p><br></p><p>computed（计算属性）：</p><p>1，监听值未在data中定义，以return返回值形式；</p><p>2，计算属性的值会被缓存，只有实例中相关依赖值改变时，才重新计算，性能好但不适合做异步请求；</p><p>3，计算属性默认只有get来读取，手动修改计算属性时，会触发手写的set函数。</p><p> </p><p>watch(监听器）：</p><p>1，监听值要在data中先定义，可以不写return返回值；</p><p>2，不支持缓存，可以做异步操作；</p><p>3，监听值改变，回调函数自动调用。</p><p><br></p><p style=\"text-align: left; line-height: 2;\">用官网的一句话来说，所有需要用到计算的都应该使用计算属性。多条数据影响一条数据时使用计算属性，使用场景购物车。</p><p style=\"text-align: left; line-height: 2;\">如果是一条数据更改，影响多条数据时，使用watch，使用场景搜索框。</p><h3></h3><h3>说一下防抖和节流。怎么实现？</h3><p> &nbsp;</p><h4>防抖：</h4><pre><code class=\"language-javascript\">function debounce(fn) {\n        let timer = null;\n        return function (...args) {\n          clearTimeout(timer);\n          // 箭头函数没有自己的this，改变指向，使其指向input。同时执行fn函数\n          timer = setTimeout(() =&gt; {\n            fn.apply(this, args);\n          }, 500);\n        };\n      }</code></pre><h4>节流：</h4><p style=\"text-align: start;\">时间戳版</p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function throttle(fn, delay) {\n  let lastTime = 0;\n  return function() {\n    const context = this;\n    const args = arguments;\n    const nowTime = Date.now();\n    if (nowTime - lastTime &gt; delay) {\n      fn.apply(context, args);\n      lastTime = nowTime;\n    }\n  };\n}\n</code></pre><p style=\"text-align: start;\">定时器版：</p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function throttle(fn, delay) {\n  let timer;\n  return function (...args) {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() =&gt; {\n      fn.apply(this, args);\n      timer = null;\n    }, delay);\n  }\n}</code></pre><p><br></p><p><a href=\"https://blog.csdn.net/slient033/article/details/124359616?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168128871316800217277193%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168128871316800217277193&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124359616-null-null.142^v82^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E3%80%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F&spm=1018.2226.3001.4187\" target=\"_blank\">防抖和节流</a> </p><p> &nbsp;</p><h3>Vue的导航守卫有哪一些？</h3><p><br></p><p> <a href=\"https://blog.csdn.net/weixin_38083836/article/details/113932103?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168128920216800217217704%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168128920216800217217704&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-113932103-null-null.142^v82^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=Vue%E7%9A%84%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B&spm=1018.2226.3001.4187\" target=\"_blank\">路由守卫</a> </p><h3></h3><h3>你的登录拦截怎么实现的？</h3><p><br></p><p style=\"text-align: start;\">1.requireAuth</p><p style=\"text-align: start;\">requireAuth属性作用是表明该路由是否需要登陆验证，在进行全局拦截时，通过该属性进行判断，该属性包含在meta属性中。</p><p style=\"text-align: start;\"><br></p><p>2.router.beforeEach</p><p>beforeEach时router的钩子函数，该函数在进入每个网页之前调用，该函数接收三个参数：</p><p>①from：即将离开的路由</p><p>②to：即将要跳转的路由</p><p>③next：跳转方法，在beforeEach函数中作为结束语句调用，以实现页面跳转。</p><p>next(false)：中断当前的导航。如果浏览器的url改变了(可能是手动或浏览器按钮后退)，那么url地址会重置到from路由对应的地址。</p><p>next(’/’)或者next({path:’/’})：跳转到一个不同的地址。当前导航被中断，然后进行一个新的导航。</p><p> </p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">3.通过使用axios拦截器</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">如果要统一处理所有的http请求和响应，就需要使用axios的拦截器。通过配置http response inteceptor，当后端接口返回错误信息，让用户重新登陆</span></p><h3></h3><h3>闭包是什么？如何实现？</h3><h3> </h3><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身就形成了一个闭包。</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>一个闭包是一个可以自己拥有独立的环境与变量的的表达式（通常是函数，因为ES6有了块级作用域的概念）。</strong></span></p><p> </p><p><br></p><h3>Vue2.0和vue3.0有什么区别？</h3><p> </p><p><br></p><p style=\"text-align: start;\">数据双向绑定方面</p><p style=\"text-align: start;\">Vue2使用Object.defineProperty</p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">Vue3使用ES6的新特性porxy</span></p><p style=\"text-align: start;\"> </p><p style=\"text-align: start;\">生命周期函数方面</p><p> 例如：</p><ol><li style=\"text-align: start; line-height: 2;\">beforeCreate和created钩子函数合并为了一个新的setup函数，用于组件的初始化和数据的响应式处理。</li><li style=\"text-align: start; line-height: 2;\">mounted和unmounted钩子函数合并为了一个新的onMounted函数和onUnmounted函数，分别用于组件挂载后和卸载时的操作。</li></ol><h3> Vue常用的指令有哪些？</h3><p><br></p><p>(1) v-text: 渲染当前dom节点的纯文本内容</p><p><br></p><p>(2) v-html: 渲染当前dom节点的html内容</p><p><br></p><p>(3) v-pre: 用来跳过这个元素和它的子元素编译过程</p><p><br></p><p>(4) v-if、v-else-if、 v-else: 控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p><br></p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><p><br></p><p>(6) v-for:遍历dom节点</p><p><br></p><p>(7) v-once: 只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视</p><p><br></p><p>为静态内容跳过，这可以用于优化更新性能</p><p><br></p><p>(8) v-bind: 用来动态绑定属性，简写为:</p><p><br></p><p>(9) v--model: 用于在表单上创建双向数据绑定，他会忽略表单元素的value、checked、selected 的初始值</p><p><br></p><p>(10) v-on: 用来监听dom的事件</p><p><br></p><h3>v-If和v-show有什么区别？</h3><p><br></p><p><br></p><p>(4) v-if、v-else-if、 v-else: 控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p><br></p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><h3></h3><h3>v-for为什么要加一个key？</h3><p><br></p><p>修改dom或删除dom的时候，有了key的化，diff算法就可以更高效的识别到</p><p>这个节点，然后进行修改、删除、新增操作。</p><h3></h3><h3>Url到浏览器的一个过程有哪些步骤？</h3><p><br></p><p>(1) DNS解析</p><p><br></p><p>(2)TCP连接</p><p><br></p><p>(3)发送HTTP请求.</p><p><br></p><p>(4)服务器处理请求并返回需要的数据</p><p><br></p><p>(5)浏览器解析渲染页面</p><p><br></p><p>A.解析HTML， 生成DOM树，解析CSS，生成CSSOM树</p><p><br></p><p>B.将DOM树和CSSOM树结合，生成渲染树(RenderTree)</p><p><br></p><p>C. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息(位置，大小)</p><p><br></p><p>D. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p><p><br></p><p>E. Display:将像素发送给GPU,展示在页面上</p><p><br></p><p>(6)连接结束</p><p><br></p><h3>什么是Js原型？原型链是什么？</h3><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start;\">在JavaScript中，每个对象都有一个称为原型（prototype）的内部属性。原型是一个包含属性和方法的对象，其他对象可以从中继承属性和方法。</p><p style=\"text-align: start;\">原型链是一种对象之间的关系，它通过原型属性链接对象。当我们访问一个对象的属性或方法时，如果该对象自身没有这个属性或方法，JavaScript会沿着原型链往上查找，直到找到该属性或方法或者到达原型链的末尾（即Object.prototype）。这样的查找过程就是原型链。</p><p style=\"text-align: start;\">简单来说，当我们通过对象访问属性或方法时，JavaScript首先在对象自身查找，如果找不到，则会继续在对象的原型上查找，直到找到或者到达原型链的末尾。</p><p style=\"text-align: start;\">通过使用原型和原型链，JavaScript实现了面向对象的继承和代码复用。</p><p>例如：</p><pre><code class=\"language-javascript\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, my name is ${this.name}`);\n}\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\nStudent.prototype.sayGrade = function() {\n  console.log(`I\'m in grade ${this.grade}`);\n}\nlet tom = new Student(\"Tom\", 5);\ntom.sayHello();  // 输出：Hello, my name is Tom\ntom.sayGrade();  // 输出：I\'m in grade 5</code></pre><h3>用闭包的原理做过哪些？</h3><p><br></p><p style=\"text-align: start;\">封装私有变量和方法：通过闭包，可以在函数外部无法访问到函数内部的变量和方法，从而实现对这些变量和方法的封装，避免了全局变量的污染。</p><p style=\"text-align: start;\">例如：</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">var user = (function(){\nvar __name = \'sven\',\n__age = 29;\nreturn {\ngetUserInfo: function(){\nreturn __name + \'-\' + __age;\n}\n}\n})();\n \nalert(user.getUserInfo());\n</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现模块化：通过使用闭包，可以将一组相关的方法和变量封装在一个函数内部，并返回一个对象，外部可以通过该对象访问到内部的方法和变量，从而实现模块化的效果。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现缓存：通过闭包，可以将一些计算结果缓存起来，避免重复计算，提高代码的性能。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现函数柯里化：通过闭包，可以将一个多参数的函数转化为多个单参数的函数，从而实现函数柯里化，提高函数的可复用性和灵活性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现回调函数：在JavaScript中，回调函数是非常常见的一种编程模式，通过闭包，可以将函数作为参数传递给另一个函数，并在另一个函数内部执行该函数，从而实现回调函数的功能。</p><h3></h3><h3>作用域是什么？</h3><p style=\"text-align: justify; line-height: 2;\"><br></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域</span></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">全局作用域就是Js中最外层的作用域</span></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">函数作用域是js通过函数创建的一个独立作用域，函数可以嵌套，所以作用域也可以嵌套</span></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）</span></p><h3 style=\"text-align: justify;\"></h3><h3>操作数组的方式有哪些？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">1、forEach——循环遍历</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">2、concat（）——拼接数组</span></p><p style=\"text-align: start;\">3、filter（）——过滤数组</p><p style=\"text-align: start;\">4、slice（）——截取元素</p><p style=\"text-align: start;\">5、splice（）——删除数组中的属性</p><p style=\"text-align: start;\">6、substring（） 和 substr（）</p><p style=\"text-align: start;\">7、every（）——判断数组中是否有满足</p><p style=\"text-align: start;\">8、some（）——只要有一个满足条件返回值就是true，没有满足条件的则为false</p><p style=\"text-align: start;\">9、push（）——从数组末尾追加</p><p style=\"text-align: start;\">10、unshift（）——从数组前面添加</p><p style=\"text-align: start;\">11、pop（）——从数组末尾删除</p><p style=\"text-align: start;\">12、reduce——数组求和</p><p style=\"text-align: start;\">13、reverse（）——反转数组</p><p style=\"text-align: start;\">14、sort（）——排序</p><p style=\"text-align: start;\">15、indexO（）f 和 lastIndexOf （）——查找值</p><p style=\"text-align: start;\">16、findIndex（）——查找数组中第一个满足条件的属性，并返回下标</p><p style=\"text-align: start;\">17、数组转字符串</p><p><br></p><h3>0.1 + 0.2 等于 0.3吗？为什么？如何解决？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">当计算 </span>0.1+0.2<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。当然计算机不会用无限的空间去存储这些无限循环的二进制数字，那对于这类数据该怎么处理呢？</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以将其转换为整数后再进行运算</span></p><pre><code >var a = 0.1, b = 0.2\nvar result = (a * 100 + b * 100) / 100\nconsole.log(result) // 0.3\nconsole.log(result === 0.3) // true</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">利用 </span>ES6<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 中的极小数 </span>Number.EPSILON<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 来进行判断。</span></p><pre><code >var a = 0.1, b = 0.2, c = 0.3;\nvar result = (Math.abs(a + b - c) &lt; Number.EPSILON);\nconsole.log(result) // true</code></pre><h3></h3><h3>keep-alive是什么？有哪几个生命周期阶段？</h3><h3></h3><p style=\"text-align: start;\">keep-alive是什么？</p><p style=\"text-align: start;\"><br>keep-alive是Vue.js的一个内置组件，它可以使被包含的组件保留状态，避免多次重渲染，提升应用性能。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">有哪几个生命周期阶段？</p><p style=\"text-align: start;\"><br>keep-alive组件有两个生命周期钩子函数：</p><p style=\"text-align: start; line-height: 1.5;\">activated：被包含的组件被激活时调用，对应组件的activated生命周期钩子函数；</p><p style=\"text-align: start; line-height: 2;\">deactivated：被包含的组件被停用时调用，对应组件的deactivated生命周期钩子函数。<br>在keep-alive中缓存的组件也会调用常规的created、mounted和updated生命周期钩子函数，但在activated和deactivated钩子函数中，缓存的组件会暂停或恢复。</p><h3></h3><p style=\"text-align: start;\">如果 Vue 的菜单栏不使用 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>keep-alive</code></span> 缓存组件，会出现以下问题：</p><ol><li style=\"text-align: start; line-height: 2;\">每次切换菜单都要重新渲染组件：由于没有使用 keep-alive 缓存组件，每次切换菜单时都需要重新创建和渲染组件。这可能会导致性能问题，特别是当组件比较复杂或包含大量数据时。</li><li style=\"text-align: start; line-height: 2;\">丢失组件状态：由于每次重新渲染组件时，组件的所有状态都会被重置为默认值，因此很容易丢失用户的一些操作状态（比如输入框中的文本、选中的复选框等）。</li><li style=\"text-align: start; line-height: 2;\">无法实现动画效果：如果希望在切换菜单时实现过渡效果或动画效果，那么必须使用 keep-alive 缓存组件。否则，在菜单切换时就无法实现任何过渡效果，用户体验会受到影响。</li></ol><p><br></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">简单地说：如果菜单栏不使用keep-alive缓存的话，点击菜单栏二级菜单切换页面时，菜单栏就要重新渲染，所有值都会重置，那么二级菜单就会自动关闭。所以为了不影响用户体验，需要将其状态缓存。</span></p><h3></h3><h3>判断一个变量是否是数组，有哪些办法？</h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用Array.isArray()方法。该方法可以验证一个变量是否为数组类型，如果是，则返回true，否则返回false。</p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (Array.isArray(arr)) {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}\n</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用instanceof操作符。该操作符可以验证一个对象是否为某个类的实例，因为数组是Array类的实例，所以可以使用该操作符判断变量是否为数组。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (arr instanceof Array) {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用Object.prototype.toString()方法。该方法返回一个表示对象类型的字符串，因为数组的类型是Object，所以我们可以使用该方法来判断变量是否为数组。<br></p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (Object.prototype.toString.call(arr) === \'[object Array]\') {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}</code></pre><h3></h3><h3>判断一个变量是否是对象，有哪些办法？</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">使用typeof操作符。如果变量的类型是object，那么它就有可能是一个对象，但这种方法并不是很准确，因为null的类型也是object，所以需要额外判断。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (typeof obj === \'object\' && obj !== null) {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用Object.prototype.toString()方法。该方法返回一个表示对象类型的字符串，因为对象的类型是Object，所以我们可以使用该方法来判断变量是否为对象。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (Object.prototype.toString.call(obj) === \'[object Object]\') {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用instanceof操作符。该操作符可以验证一个对象是否为某个类的实例，因为对象是Object类的实例，所以我们可以使用该操作符判断变量是否为对象。<br></p><p><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (obj instanceof Object) {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p><br></p><h3>对象/数组常用方法有哪些？</h3><p><br></p><p style=\"text-align: start;\"><strong>对象方法：</strong></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">Object.keys(obj)：返回一个包含对象中所有属性名称的数组。</p><p style=\"text-align: start; line-height: 2;\">Object.values(obj)：返回一个包含对象中所有属性值的数组。</p><p style=\"text-align: start; line-height: 2;\">Object.entries(obj)：返回一个包含对象中所有[属性名称，属性值]的二维数组。</p><p style=\"text-align: start; line-height: 2;\">Object.assign(target, ...sources)：用于将源对象的所有可枚举属性复制到目标对象中，并返回目标对象。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\"><strong>数组方法：</strong></p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">push(item1,item2,...)：向数组末尾添加一个或多个元素，并返回新的长度。</p><p style=\"text-align: start; line-height: 2;\">pop()：从数组末尾移除最后一个元素，并返回该元素的值。</p><p style=\"text-align: start; line-height: 2;\">shift()：从数组开头移除第一个元素，并返回该元素的值。</p><p style=\"text-align: start; line-height: 2;\">unshift(item1,item2,...)：向数组开头添加一个或多个元素，并返回新的长度。</p><p style=\"text-align: start; line-height: 2;\">splice(start, deleteCount, item)：从指定索引位置开始删除指定数量的元素，并可选地插入新元素。</p><p style=\"text-align: start; line-height: 2;\">slice(start, end)：返回一个新数组，其中包含从开始索引到结束索引（不包括结束索引）的所有元素。</p><p style=\"text-align: start; line-height: 2;\">concat(item1,item2,...)：返回一个新数组，其中包含原始数组和所有指定的数组或值。</p><p style=\"text-align: start; line-height: 2;\">join(separator)：将数组中的所有元素转换为字符串，并使用指定的分隔符连接它们。</p><p style=\"text-align: start; line-height: 2;\">reverse()：将数组中的元素顺序反转。</p><p style=\"text-align: start; line-height: 2;\">sort()：对数组元素进行排序。如果未指定比较函数，则将其转换为字符串并按字母顺序排序。</p><h3></h3><h3>哪些遍历方式会改变原数组？</h3><p><br></p><ol><li style=\"text-align: start;\">push()方法<br>push()方法向数组的末尾添加一个或多个元素，并返回新的长度。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">pop()方法<br>pop()方法从数组的末尾移除最后一个元素，并返回该元素的值。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">shift()方法<br>shift()方法从数组的开头移除第一个元素，并返回该元素的值。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">unshift()方法<br>unshift()方法向数组的开头添加一个或多个元素，并返回新的长度。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">splice()方法<br>splice()方法从指定的索引位置开始删除指定数量的元素，并可选地插入新元素。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">sort()方法<br>sort()方法用于对数组中的元素进行排序。如果未指定比较函数，则将其转换为字符串并按字母顺序排序。这会改变原数组的元素顺序。</li><li style=\"text-align: start;\">reverse()方法<br>reverse()方法用于将数组中的元素顺序反转。这会改变原数组的元素顺序。<br>需要注意的是，这些方法都会直接修改原数组，因此使用它们时需要注意是否需要保留原数组的值。如果需要保留原数组，可以先复制一份，再使用这些方法对复制的数组进行操作。</li></ol><p><br></p><p><br></p><h3>Set和Map各是什么？</h3><p><br></p><p><br></p><p style=\"text-align: start;\">Set<br>Set是一种类似于数组的数据结构，但是它的每个元素都是唯一的，没有重复的值。Set可以用于去重，例如：</p><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3, 3, 4, 5, 5];\nconst set = new Set(arr);\nconsole.log(set); // Set(5) {1, 2, 3, 4, 5}</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Set提供了一些常用的方法，例如add、delete、has、clear等等，用于添加、删除、查找和清空Set中的元素。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Map Map是一种类似于对象的数据结构，它也是由键值对组成的。与对象不同的是，Map的键可以是任何数据类型，而不仅仅是字符串。另外，Map中的键是唯一的，每个键对应的值也是唯一的。例如：</span></p><p><br></p><p><br></p><pre><code class=\"language-javascript\">const map = new Map();\nmap.set(\'name\', \'Tom\');\nmap.set(\'age\', 18);\nconsole.log(map); // Map(2) {\"name\" =&gt; \"Tom\", \"age\" =&gt; 18}</code></pre><p><br></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Map提供了一些常用的方法，例如set、get、delete、has、clear等等，用于添加、获取、删除、查找和清空Map中的键值对。 总的来说，Set和Map都是非常实用的数据结构，它们提供了快速、高效地去重、查找和存储数据的功能，可以在开发中大大提高代码的效率和可读性。</span></p><p><br></p><p><br></p><h3>介绍一下promise。</h3><p><br></p><ol><li style=\"text-align: start;\">可以解决回调地狱的问题，使得异步操作更加稳定和可控；</li></ol><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">2. &nbsp;可以使用链式调用的方式，使得代码更加优雅和简洁；</p><p style=\"text-align: start;\">3. &nbsp;可以通过then()和catch()方法分别处理异步操作成功和失败的情况，使得代码结构更加清晰和易于维护；</p><p style=\"text-align: start;\">4. &nbsp;可以使用Promise.all()方法和Promise.race()方法来处理多个异步操作的结果，使得代码更加高效和灵活。</p><p style=\"text-align: start;\"><br>需要注意的是，Promise并不是一种新的异步处理方式，它仍然是基于回调函数的异步处理方式的一种封装和升级。此外，Promise也有一些缺点，例如无法取消Promise、无法处理同步代码等等。因此，在使用Promise时需要结合实际情况进行选择和使用。</p><p><br></p><h3>Promise通常会解决三种问题，<span style=\"font-size: 16px;\">这三种方式promise是怎么处理的？</span></h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">(1)链式回调</span></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">具体来说，Promise可以通过then方法实现链式调用。每次调用then方法时，会返回一个新的Promise对象。我们可以在这个新对象上再次调用then方法来继续执行后续操作，以此类推。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">(2)同时发起几个异步请求，谁先有结果就拿谁的</span></p><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">Promise可以通过Promise.race方法来解决同时发起几个异步请求，并且谁先有结果就拿谁的问题。</span></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">Promise.race接受一个数组参数，其中每个元素都是一个Promise对象。当其中任意一个Promise对象的状态变为fulfilled或rejected时，Promise.race返回一个新的Promise对象，并将第一个有结果的Promise对象的结果传递给新Promise对象的回调函数。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">(3)发起多个请求，等到所有请求后再做下一步处理</span></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">Promise可以通过Promise.all方法来解决多个请求并发，等到所有请求都完成后再进行下一步处理的问题。</span></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">Promise.all接受一个数组参数，其中每个元素都是一个Promise对象。当所有Promise对象都变为fulfilled状态时，Promise.all返回一个新的Promise对象，这个新的Promise对象的状态也会变为fulfilled</span></p><p style=\"text-align: start;\"><br></p><h3>如何改变一个函数a的上下文？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">可以使用JavaScript中的call()、apply()或bind()方法来改变一个函数a的上下文。这些方法都是函数的原型方法，可以用于改变函数的this指向。</span></p><p><br></p><p>call()方法</p><p>call()方法用于调用一个函数，同时指定该函数的this值和参数。例如：</p><p><br></p><pre><code class=\"language-javascript\">\nfunction a() {\n console.log(this.name);\n}\nconst obj = {name: \'Tom\'};\na.call(obj); // 输出Tom</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，调用a函数时使用了call()方法，将a函数的this指向了obj对象，因此输出了Tom。</span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">apply()方法 apply()方法与call()方法类似，也用于调用一个函数，同时指定该函数的this值和参数。唯一的区别是apply()方法接收的参数是一个数组。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function a(x, y) {\n  console.log(this.name, x, y);\n}\nconst obj = {name: \'Tom\'};\na.apply(obj, [1, 2]); // 输出Tom 1 2</code></pre><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，调用a函数时使用了apply()方法，将a函数的this指向了obj对象，同时将参数1和2传递给了a函数，因此输出了Tom 1 2。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">3. bind()方法 bind()方法用于创建一个新函数，并将原函数的this值绑定到指定的对象上。不同于call()和apply()方法，bind()方法不会立即执行函数，而是返回一个新的函数，可以在稍后调用。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function a() {\n  console.log(this.name);\n}\nconst obj = {name: \'Tom\'};\nconst b = a.bind(obj);\nb(); // 输出Tom</code></pre><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，使用bind()方法创建了一个新函数b，并将a函数的this值绑定到obj对象上。然后调用b函数，输出了Tom。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">需要注意的是，使用这些方法改变函数的上下文时，要注意this指向的对象是否存在，否则会出现错误。</span></p><p><br></p><h3>Call和apply有什么区别？</h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">JavaScript中的call()和apply()方法都是用来改变函数中this的指向的，它们的区别在于传参方式不同。 call()方法接收的是一个参数列表，而apply()方法接收的是一个数组。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function func(arg1, arg2, arg3) {\n  console.log(this, arg1, arg2, arg3);\n}\nconst obj = { name: \'Tom\' };\nfunc.call(obj, 1, 2, 3); // 输出{ name: \'Tom\' } 1 2 3\nfunc.apply(obj, [1, 2, 3]); // 输出{ name: \'Tom\' } 1 2 3</code></pre><h3></h3><p style=\"line-height: 2;\"><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在这个例子中，func函数通过call()和apply()方法改变了this的指向，并传入了三个参数。使用call()方法时，参数是按照逗号分隔的列表形式传入的；而使用apply()方法时，参数是按照数组的形式传入的。 另外，call()方法和apply()方法的作用都是相同的，只是传参方式不同，开发者可以根据实际情况选择使用其中的一种。</span></p><h3>Evenbus是什么东西？</h3><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">\"EventBus\" 是一个在前端框架中经常使用的事件发布/订阅模式的库或工具</p><p style=\"text-align: start; line-height: 2;\">当一个组件需要与另一个组件通信时，它可以以简单的方式向 EventBus 发布（广播）一个事件。然后，任何对该事件感兴趣的组件都可以通过订阅 Event Bus 上的相应事件来接收到这些事件。这使得组件之间的通信变得非常容易，同时也降低了这些组件的耦合度和维护难度。</p><p style=\"text-align: start;\">创建一个新的EventBus对象</p><pre style=\"text-align: left;\"><code>import Vue from \'vue\';\nexport const EventBus = new Vue();\n\n</code></pre><p style=\"text-align: start;\">触发事件并传递数据</p><pre style=\"text-align: left;\"><code>// 在发送组件中触发事件\nimport { EventBus } from \'./event-bus\';\nEventBus.$emit(\'event-name\', data);\n\n// 在接收组件中监听事件\nimport { EventBus } from \'./event-bus\';\nEventBus.$on(\'event-name\', (data) =&gt; {\n  // 在该函数中处理接收到的数据\n});\n\n</code></pre><p style=\"text-align: start; line-height: 2;\">例如，在Vue中，$emit函数用于触发事件，并且该事件被emit函数用于触发事件，并且该事件被on函数监听。在上面的示例中，emit函数发送了一个名为’event-name’的事件，并传递了数据。在接收组件中，通过$on函数监听该事件，并在回调函数中处理接收到的数据。</p><p><br></p><h3>父子组件生命周期执行顺序是怎么样的？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在Vue.js中，父子组件的生命周期执行顺序如下：</span></p><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeCreate()\ncreated()\nbeforeMount()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeCreate()\ncreated()\nbeforeMount()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >mounted()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >mounted()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeUpdate()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeUpdate()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >updated()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >updated()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeDestroy()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeDestroy()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >destroyed()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >destroyed()</code></pre><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: rgb(255, 255, 255);\"><br>在这个过程中，父组件的生命周期方法会优先于子组件的生命周期方法执行，而当父组件的生命周期方法返回时，子组件的生命周期方法才会执行。当父组件被销毁时，子组件也会随之被销毁。需要注意的是，子组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mounted()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法在父组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mounted()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法之后执行，但在父组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>updated()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法之前执行。这是因为子组件的渲染必须在父组件之后才能进行，但是子组件的数据更新需要在父组件之前进行。</span></p><p><br></p><h3>mixins有几个生命周期阶段？</h3><p><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: rgb(255, 255, 255);\">在Vue.js中，</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255);\">混入的选项和组件的选项合并后，都会按照特定的生命周期顺序调用。</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255);\">有以下生命周期阶段：</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeCreate</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在实例初始化之后、数据观测 (data observation) 和 event/watcher 事件配置之前被调用。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>created</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例已经创建完成之后被调用。在这里可以进行一些数据的处理，如异步请求数据等。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeMount</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在挂载开始之前被调用。相关的 </span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>render</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\"> 函数首次被调用。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mounted</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例挂载之后调用，可以访问到 </span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>DOM</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\"> 元素，并进行相应的操作。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeUpdate</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>updated</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeDestroy</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在实例销毁之前调用。在这里可以进行一些清理工作，比如清除计时器、解绑全局事件等等。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>destroyed</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例销毁之后调用，此时所有的事件监听器都已经被移除，子实例也被销毁。<br>需要注意的是，</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">会按照数组顺序依次执行对应的生命周期函数，而组件的生命周期函数会在</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">的生命周期函数之后执行。</span></p><p><br></p><h3>弹性布局，一行两列，一列固定宽，如何实现？</h3><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">可以使用弹性布局中的</span>flex<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">属性来实现一行两列的布局，其中一列固定宽可以通过设置该列的</span>flex-basis<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">属性来实现。具体实现如下：</span></p><p><br></p><pre><code class=\"language-html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"left\"&gt;固定宽度&lt;/div&gt;\n  &lt;div class=\"right\"&gt;自适应宽度&lt;/div&gt;\n&lt;/div&gt;</code></pre><pre><code class=\"language-css\">.container {\n  display: flex;\n  flex-direction: row;\n}\n.left {\n  width: 100px; /* 固定宽度 */\n  flex-basis: 100px; /* 列宽度 */\n}\n.right {\n  flex: 1; /* 自适应宽度 */\n}</code></pre><h3></h3><h3>Flex包含哪三种属性</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">在 CSS 中，\"flex\" 是一个重要的属性，是实现弹性布局 (Flexible Box Layout) 的基础。而 \"flex\" 属性包含以下三个子属性：</p><p style=\"text-align: start; line-height: 2;\">1.flex-grow：定义项目在剩余空间中放大的比例，默认为 0，即如果存在剩余空间，也不会放大。</p><p style=\"text-align: start; line-height: 2;\">2.flex-shrink：定义项目在空间不足时缩小的比例，默认为 1，即如果空间不足，也会自动缩小。</p><p style=\"text-align: start; line-height: 2;\">3.flex-basis：定义项目在分配多余空间之前，应该占据的主轴空间（即项目的原始大小），默认值为 auto，也可以设置为具体的长度或百分比。</p><p style=\"text-align: start; line-height: 2;\">这三个属性一般结合使用，例如 \"flex: 1 1 auto;\"，就表示项目既可以在剩余空间中放大，也可以在空间不足时缩小，并且占据的主轴空间为其本身的大小。</p><p style=\"text-align: start; line-height: 2;\">总之，\"flex\" 属性是很常用的 CSS 属性，它可以帮助开发者更好地实现弹性布局，提高网页设计的灵活性和可适应性。</p><p><br></p><h3>简单描述一下同步和异步</h3><p><br></p><p>1.同步任务</p><p> &nbsp;在主线程上排队执行的任务,在最前面的任务执行完成之后,才执行后面的任务.</p><p><br></p><p>2.异步任务</p><p>指不进入主线程,而是进入了“任务队列”的任务,只有“任务队列”通知主线程,某个异步任务可执行了,该任务才会进入主线程执行.</p><p><br></p><p>异步任务: 分为宏任务 和 微任务</p><p><br></p><p>宏任务: 包含整体代码script、setTimeout、setInterval</p><p><br></p><p>微任务: Promise.then(非 new Promise)、process.nextTick(node中)</p><h3></h3><h3>router.push和router.replace的区别</h3><p><br></p><p><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.push</code></span><span style=\"font-size: 16px;\"> 方法会在浏览历史中新增一个记录，即可通过浏览器的“后退”按钮返回到之前的页面；而 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.replace</code></span><span style=\"font-size: 16px;\"> 方法不会新增历史记录，所以无法通过“后退”按钮返回之前的页面。</span></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">举个例子，如果我们有一个 URL 为 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 的页面（假设这是我们当前的页面），使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.push(\'/about\')</code></span><span style=\"font-size: 16px;\"> 会导航到一个新的页面，并且浏览器的 URL 地址会从 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 变成 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/about</code></span><span style=\"font-size: 16px;\">，因此用户可以通过“后退”按钮回到刚才的 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 页面。而使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.replace(\'/about\')</code></span><span style=\"font-size: 16px;\"> 也会导航到新的页面，但浏览器 URL 不会改变，因此无法通过“后退”按钮返回到之前的页面。</span></p><p style=\"text-align: start;\"><br></p><h3>Grid布局</h3><p><br></p><p style=\"line-height: 2;\">grid布局虽然强大，但学习起来不如flex方便，需多加使用</p><p> <a href=\"https://juejin.cn/post/7189877500212674616\" target=\"_blank\">稀土掘金</a> </p><p><br></p><h3> 说一下 HTML5 drag api</h3><p><br></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</span></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/21/1684646456039995.png', '前端面试', '面试常见题目', '前端基础面试题，不断更新中。', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-02 15:15:55', 'U', 1);
INSERT INTO `blog_essay` VALUES (26, '<h3>Vue的生命周期有哪一些？说一下它们每个阶段做什么操作？</h3><p><br></p><p> &nbsp; &nbsp;(1) beforeCreate:数据初始化之前</p><p><br></p><p> &nbsp; &nbsp;(2) created:数据初始化之后，但未生成dom</p><p><br></p><p> &nbsp; &nbsp;(3) beforeMount: 准备生成dom</p><p><br></p><p> &nbsp; &nbsp;(4) mounted:生成dom之后</p><p><br></p><p> &nbsp; &nbsp;(5) beforeUpdate: 准备修改dom</p><p><br></p><p> &nbsp; &nbsp;(6) updated: 修改dom之后</p><p><br></p><p> &nbsp; &nbsp;(7) beforeDestroy:组件销毁之前</p><p><br></p><p> &nbsp; &nbsp;(8) destroyed:组件销毁之后</p><p style=\"text-indent: 2em;\"><br></p><h3>组件通讯方式有哪一些？</h3><p><br></p><p>1、props和$emit(常用)；</p><p><br></p><p>2、$attrs和$listeners；</p><p><br></p><p>3、eventBus &nbsp;中央事件总线（非父子组件间通信）；</p><p><br></p><p>4、v-model；</p><p><br></p><p>5、provide和inject；</p><p><br></p><p>6、$parent和$children；</p><p> </p><h3>Vuex有几个属性及作用？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">1.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">state</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：定义了应用程序的状态，就是我们要管理的数据。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: {\n count: 0 \n}\n })</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">2.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">getters</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：用于获取State中的状态，主要用于对state进行逻辑上的组合和应用，类似于</span><a href=\"https://so.csdn.net/so/search?q=Vue%E7%BB%84%E4%BB%B6&amp;spm=1001.2101.3001.7020\" target=\"_blank\" style=\"text-align: start;\">Vue组件</a><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">中的计算属性。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: { \ntodos: [ {\n id: 1,\n text: \'Learn Vue\', \ndone: true\n }, \n {\n id: 2, \ntext: \'Learn Vuex\', \ndone: false \n    }\n       ] }, \ngetters: { \ndoneTodos: state =&gt; { \nreturn state.todos.filter(todo =&gt; todo.done) \n}\n }\n })</code></pre><p>3.<span style=\"font-size: 19px;\">mutations</span>：用于修改state中的数据，是唯一可以修改state的地方。mutations接收state作为第一个参数，接收payload作为第二个参数。用于修改State中的状态，只能同步执行。Mutation必须是同步函数，因为它们不能处理异步行为，异步行为应该放在Action中处理。</p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: { \ncount: 0 \n}, \nmutations: { \nincrement (state) { \nstate.count++\n }\n }\n })</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">4.</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 19px;\">actions</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">：用于异步操作和提交mutations，在actions中可以进行任何异步操作，最后再提交到mutations中同步修改state。actions接收context作为第一个参数，其中包含了state、getters和commit等属性。</span></p><pre><code class=\"language-javascript\">const store = new Vuex.Store({\n state: {\n count: 0 \n}, \nmutations: { \nincrement (state) { \nstate.count++\n }\n },\n actions: {\n asyncIncrement ({ commit }) { \nsetTimeout(() =&gt; { \ncommit(\'increment\')\n }, 1000) \n} \n}\n })</code></pre><p style=\"text-align: start;\">5.<span style=\"font-size: 19px;\">modules</span>：用于将store分割成模块，每个模块都拥有自己的state、mutation、action、getters和子模块，以便提高应用程序的可维护性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"> <a href=\"https://blog.csdn.net/u013517229/article/details/127906004?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vuex%20moudules&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-127906004.142^v86^koosearch_v1,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187\" target=\"_blank\">modules简单使用</a> </p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">总结：</p><p style=\"text-align: start;\">state:所有共享数据统一放到state中，与data类似</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">mutation: 类似于事件，用于改变状态</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">action: 和mutation相似，但是action是异步操作</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">getter: 类似vue中的computed，进行缓存，形成新的数据</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">modules: 分模块，大型项目一个对象管理会很臃肿</p><p style=\"text-align: start;\"><br></p><h3>Vue的监听属性和计算属性有什么区别？</h3><p><br></p><p>computed（计算属性）：</p><p>1，监听值未在data中定义，以return返回值形式；</p><p>2，计算属性的值会被缓存，只有实例中相关依赖值改变时，才重新计算，性能好但不适合做异步请求；</p><p>3，计算属性默认只有get来读取，手动修改计算属性时，会触发手写的set函数。</p><p> </p><p>watch(监听器）：</p><p>1，监听值要在data中先定义，可以不写return返回值；</p><p>2，不支持缓存，可以做异步操作；</p><p>3，监听值改变，回调函数自动调用。</p><p><br></p><p style=\"text-align: left; line-height: 2;\">用官网的一句话来说，所有需要用到计算的都应该使用计算属性。多条数据影响一条数据时使用计算属性，使用场景购物车。</p><p style=\"text-align: left; line-height: 2;\">如果是一条数据更改，影响多条数据时，使用watch，使用场景搜索框。</p><h3></h3><h3>说一下防抖和节流。怎么实现？</h3><p> &nbsp;</p><h4>防抖：</h4><pre><code class=\"language-javascript\">function debounce(fn) {\n        let timer = null;\n        return function (...args) {\n          clearTimeout(timer);\n          // 箭头函数没有自己的this，改变指向，使其指向input。同时执行fn函数\n          timer = setTimeout(() =&gt; {\n            fn.apply(this, args);\n          }, 500);\n        };\n      }</code></pre><h4>节流：</h4><p style=\"text-align: start;\">时间戳版</p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function throttle(fn, delay) {\n  let lastTime = 0;\n  return function() {\n    const context = this;\n    const args = arguments;\n    const nowTime = Date.now();\n    if (nowTime - lastTime &gt; delay) {\n      fn.apply(context, args);\n      lastTime = nowTime;\n    }\n  };\n}\n</code></pre><p style=\"text-align: start;\">定时器版：</p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function throttle(fn, delay) {\n  let timer;\n  return function (...args) {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() =&gt; {\n      fn.apply(this, args);\n      timer = null;\n    }, delay);\n  }\n}</code></pre><p><br></p><p><a href=\"https://blog.csdn.net/slient033/article/details/124359616?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168128871316800217277193%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168128871316800217277193&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124359616-null-null.142^v82^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E3%80%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F&spm=1018.2226.3001.4187\" target=\"_blank\">防抖和节流</a> </p><p> &nbsp;</p><h3>Vue的导航守卫有哪一些？</h3><p><br></p><p> <a href=\"https://blog.csdn.net/weixin_38083836/article/details/113932103?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168128920216800217217704%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168128920216800217217704&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-113932103-null-null.142^v82^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=Vue%E7%9A%84%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%B8%80%E4%BA%9B&spm=1018.2226.3001.4187\" target=\"_blank\">路由守卫</a> </p><h3></h3><h3>你的登录拦截怎么实现的？</h3><p><br></p><p style=\"text-align: start;\">1.requireAuth</p><p style=\"text-align: start;\">requireAuth属性作用是表明该路由是否需要登陆验证，在进行全局拦截时，通过该属性进行判断，该属性包含在meta属性中。</p><p style=\"text-align: start;\"><br></p><p>2.router.beforeEach</p><p>beforeEach时router的钩子函数，该函数在进入每个网页之前调用，该函数接收三个参数：</p><p>①from：即将离开的路由</p><p>②to：即将要跳转的路由</p><p>③next：跳转方法，在beforeEach函数中作为结束语句调用，以实现页面跳转。</p><p>next(false)：中断当前的导航。如果浏览器的url改变了(可能是手动或浏览器按钮后退)，那么url地址会重置到from路由对应的地址。</p><p>next(’/’)或者next({path:’/’})：跳转到一个不同的地址。当前导航被中断，然后进行一个新的导航。</p><p> </p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">3.通过使用axios拦截器</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">如果要统一处理所有的http请求和响应，就需要使用axios的拦截器。通过配置http response inteceptor，当后端接口返回错误信息，让用户重新登陆</span></p><h3></h3><h3>闭包是什么？如何实现？</h3><h3> </h3><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身就形成了一个闭包。</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>一个闭包是一个可以自己拥有独立的环境与变量的的表达式（通常是函数，因为ES6有了块级作用域的概念）。</strong></span></p><p> </p><p><br></p><h3>Vue2.0和vue3.0有什么区别？</h3><p> </p><p><br></p><p style=\"text-align: start;\">数据双向绑定方面</p><p style=\"text-align: start;\">Vue2使用Object.defineProperty</p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">Vue3使用ES6的新特性porxy</span></p><p style=\"text-align: start;\"> </p><p style=\"text-align: start;\">生命周期函数方面</p><p> 例如：</p><ol><li style=\"text-align: start; line-height: 2;\">beforeCreate和created钩子函数合并为了一个新的setup函数，用于组件的初始化和数据的响应式处理。</li><li style=\"text-align: start; line-height: 2;\">mounted和unmounted钩子函数合并为了一个新的onMounted函数和onUnmounted函数，分别用于组件挂载后和卸载时的操作。</li></ol><p><br></p>', '/public/uploads/2023/04/19/1681892071092678.png', '前端面试（二）', '前端面试问题', '', '前端,面试', 'VUE', '1', '2022-07-04 19:49:39', '2023-05-09 15:15:49', 'D', 1);
INSERT INTO `blog_essay` VALUES (27, '<h3> Vue常用的指令有哪些？</h3><p><br></p><p>(1) v-text: 渲染当前dom节点的纯文本内容</p><p><br></p><p>(2) v-html: 渲染当前dom节点的html内容</p><p><br></p><p>(3) v-pre: 用来跳过这个元素和它的子元素编译过程</p><p><br></p><p>(4) v-if、v-else-if、 v-else: 控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p><br></p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><p><br></p><p>(6) v-for:遍历dom节点</p><p><br></p><p>(7) v-once: 只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视</p><p><br></p><p>为静态内容跳过，这可以用于优化更新性能</p><p><br></p><p>(8) v-bind: 用来动态绑定属性，简写为:</p><p><br></p><p>(9) v--model: 用于在表单上创建双向数据绑定，他会忽略表单元素的value、checked、selected 的初始值</p><p><br></p><p>(10) v-on: 用来监听dom的事件</p><p><br></p><h3>v-If和v-show有什么区别？</h3><p><br></p><p><br></p><p>(4) v-if、v-else-if、 v-else: 控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p><br></p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><h3></h3><h3>v-for为什么要加一个key？</h3><p><br></p><p>修改dom或删除dom的时候，有了key的化，diff算法就可以更高效的识别到</p><p>这个节点，然后进行修改、删除、新增操作。</p><h3></h3><h3>Url到浏览器的一个过程有哪些步骤？</h3><p><br></p><p>(1) DNS解析</p><p><br></p><p>(2)TCP连接</p><p><br></p><p>(3)发送HTTP请求.</p><p><br></p><p>(4)服务器处理请求并返回需要的数据</p><p><br></p><p>(5)浏览器解析渲染页面</p><p><br></p><p>A.解析HTML， 生成DOM树，解析CSS，生成CSSOM树</p><p><br></p><p>B.将DOM树和CSSOM树结合，生成渲染树(RenderTree)</p><p><br></p><p>C. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息(位置，大小)</p><p><br></p><p>D. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p><p><br></p><p>E. Display:将像素发送给GPU,展示在页面上</p><p><br></p><p>(6)连接结束</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/19/1681892140752754.jpeg', '前端面试（三）', '前端基础面试题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-04-24 11:26:51', 'D', 1);
INSERT INTO `blog_essay` VALUES (28, '<h3>什么是Js原型？原型链是什么？</h3><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start;\">在JavaScript中，每个对象都有一个称为原型（prototype）的内部属性。原型是一个包含属性和方法的对象，其他对象可以从中继承属性和方法。</p><p style=\"text-align: start;\">原型链是一种对象之间的关系，它通过原型属性链接对象。当我们访问一个对象的属性或方法时，如果该对象自身没有这个属性或方法，JavaScript会沿着原型链往上查找，直到找到该属性或方法或者到达原型链的末尾（即Object.prototype）。这样的查找过程就是原型链。</p><p style=\"text-align: start;\">简单来说，当我们通过对象访问属性或方法时，JavaScript首先在对象自身查找，如果找不到，则会继续在对象的原型上查找，直到找到或者到达原型链的末尾。</p><p style=\"text-align: start;\">通过使用原型和原型链，JavaScript实现了面向对象的继承和代码复用。</p><p>例如：</p><pre><code class=\"language-javascript\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, my name is ${this.name}`);\n}\nfunction Student(name, grade) {\n  Person.call(this, name);\n  this.grade = grade;\n}\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\nStudent.prototype.sayGrade = function() {\n  console.log(`I\'m in grade ${this.grade}`);\n}\nlet tom = new Student(\"Tom\", 5);\ntom.sayHello();  // 输出：Hello, my name is Tom\ntom.sayGrade();  // 输出：I\'m in grade 5</code></pre><h3>用闭包的原理做过哪些？</h3><p><br></p><p style=\"text-align: start;\">封装私有变量和方法：通过闭包，可以在函数外部无法访问到函数内部的变量和方法，从而实现对这些变量和方法的封装，避免了全局变量的污染。</p><p style=\"text-align: start;\">例如：</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">var user = (function(){\nvar __name = \'sven\',\n__age = 29;\nreturn {\ngetUserInfo: function(){\nreturn __name + \'-\' + __age;\n}\n}\n})();\n \nalert(user.getUserInfo());\n</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现模块化：通过使用闭包，可以将一组相关的方法和变量封装在一个函数内部，并返回一个对象，外部可以通过该对象访问到内部的方法和变量，从而实现模块化的效果。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现缓存：通过闭包，可以将一些计算结果缓存起来，避免重复计算，提高代码的性能。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现函数柯里化：通过闭包，可以将一个多参数的函数转化为多个单参数的函数，从而实现函数柯里化，提高函数的可复用性和灵活性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">实现回调函数：在JavaScript中，回调函数是非常常见的一种编程模式，通过闭包，可以将函数作为参数传递给另一个函数，并在另一个函数内部执行该函数，从而实现回调函数的功能。</p><h3></h3><h3>作用域是什么？</h3><p style=\"text-align: justify; line-height: 2;\"><br></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域</span></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">全局作用域就是Js中最外层的作用域</span></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">函数作用域是js通过函数创建的一个独立作用域，函数可以嵌套，所以作用域也可以嵌套</span></p><p style=\"text-align: justify; line-height: 2;\"><span style=\"font-size: 16px;\">Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）</span></p><h3 style=\"text-align: justify;\"></h3><h3>操作数组的方式有哪些？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">1、forEach——循环遍历</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">2、concat（）——拼接数组</span></p><p style=\"text-align: start;\">3、filter（）——过滤数组</p><p style=\"text-align: start;\">4、slice（）——截取元素</p><p style=\"text-align: start;\">5、splice（）——删除数组中的属性</p><p style=\"text-align: start;\">6、substring（） 和 substr（）</p><p style=\"text-align: start;\">7、every（）——判断数组中是否有满足</p><p style=\"text-align: start;\">8、some（）——只要有一个满足条件返回值就是true，没有满足条件的则为false</p><p style=\"text-align: start;\">9、push（）——从数组末尾追加</p><p style=\"text-align: start;\">10、unshift（）——从数组前面添加</p><p style=\"text-align: start;\">11、pop（）——从数组末尾删除</p><p style=\"text-align: start;\">12、reduce——数组求和</p><p style=\"text-align: start;\">13、reverse（）——反转数组</p><p style=\"text-align: start;\">14、sort（）——排序</p><p style=\"text-align: start;\">15、indexO（）f 和 lastIndexOf （）——查找值</p><p style=\"text-align: start;\">16、findIndex（）——查找数组中第一个满足条件的属性，并返回下标</p><p style=\"text-align: start;\">17、数组转字符串</p><p><br></p><h3>0.1 + 0.2 等于 0.3吗？为什么？如何解决？</h3><p><br></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">当计算 </span>0.1+0.2<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。当然计算机不会用无限的空间去存储这些无限循环的二进制数字，那对于这类数据该怎么处理呢？</span></p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以将其转换为整数后再进行运算</span></p><pre><code >var a = 0.1, b = 0.2\nvar result = (a * 100 + b * 100) / 100\nconsole.log(result) // 0.3\nconsole.log(result === 0.3) // true</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">利用 </span>ES6<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 中的极小数 </span>Number.EPSILON<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"> 来进行判断。</span></p><pre><code >var a = 0.1, b = 0.2, c = 0.3;\nvar result = (Math.abs(a + b - c) &lt; Number.EPSILON);\nconsole.log(result) // true</code></pre><h3></h3><h3>keep-alive是什么？有哪几个生命周期阶段？</h3><h3></h3><p style=\"text-align: start;\">keep-alive是什么？</p><p style=\"text-align: start;\"><br>keep-alive是Vue.js的一个内置组件，它可以使被包含的组件保留状态，避免多次重渲染，提升应用性能。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">有哪几个生命周期阶段？</p><p style=\"text-align: start;\"><br>keep-alive组件有两个生命周期钩子函数：</p><p style=\"text-align: start; line-height: 1.5;\">activated：被包含的组件被激活时调用，对应组件的activated生命周期钩子函数；</p><p style=\"text-align: start; line-height: 2;\">deactivated：被包含的组件被停用时调用，对应组件的deactivated生命周期钩子函数。<br>在keep-alive中缓存的组件也会调用常规的created、mounted和updated生命周期钩子函数，但在activated和deactivated钩子函数中，缓存的组件会暂停或恢复。</p><h3></h3><p style=\"text-align: start;\">如果 Vue 的菜单栏不使用 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>keep-alive</code></span> 缓存组件，会出现以下问题：</p><ol><li style=\"text-align: start; line-height: 2;\">每次切换菜单都要重新渲染组件：由于没有使用 keep-alive 缓存组件，每次切换菜单时都需要重新创建和渲染组件。这可能会导致性能问题，特别是当组件比较复杂或包含大量数据时。</li><li style=\"text-align: start; line-height: 2;\">丢失组件状态：由于每次重新渲染组件时，组件的所有状态都会被重置为默认值，因此很容易丢失用户的一些操作状态（比如输入框中的文本、选中的复选框等）。</li><li style=\"text-align: start; line-height: 2;\">无法实现动画效果：如果希望在切换菜单时实现过渡效果或动画效果，那么必须使用 keep-alive 缓存组件。否则，在菜单切换时就无法实现任何过渡效果，用户体验会受到影响。</li></ol><p><br></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">简单地说：如果菜单栏不使用keep-alive缓存的话，点击菜单栏二级菜单切换页面时，菜单栏就要重新渲染，所有值都会重置，那么二级菜单就会自动关闭。所以为了不影响用户体验，需要将其状态缓存。</span></p><h3></h3><h3>判断一个变量是否是数组，有哪些办法？</h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">使用Array.isArray()方法。该方法可以验证一个变量是否为数组类型，如果是，则返回true，否则返回false。</p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (Array.isArray(arr)) {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}\n</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用instanceof操作符。该操作符可以验证一个对象是否为某个类的实例，因为数组是Array类的实例，所以可以使用该操作符判断变量是否为数组。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (arr instanceof Array) {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用Object.prototype.toString()方法。该方法返回一个表示对象类型的字符串，因为数组的类型是Object，所以我们可以使用该方法来判断变量是否为数组。<br></p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3];\nif (Object.prototype.toString.call(arr) === \'[object Array]\') {\n  console.log(\'arr is an array\');\n} else {\n  console.log(\'arr is not an array\');\n}</code></pre><h3></h3><h3>判断一个变量是否是对象，有哪些办法？</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">使用typeof操作符。如果变量的类型是object，那么它就有可能是一个对象，但这种方法并不是很准确，因为null的类型也是object，所以需要额外判断。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (typeof obj === \'object\' && obj !== null) {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用Object.prototype.toString()方法。该方法返回一个表示对象类型的字符串，因为对象的类型是Object，所以我们可以使用该方法来判断变量是否为对象。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (Object.prototype.toString.call(obj) === \'[object Object]\') {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">使用instanceof操作符。该操作符可以验证一个对象是否为某个类的实例，因为对象是Object类的实例，所以我们可以使用该操作符判断变量是否为对象。<br></p><p><br></p><pre><code class=\"language-javascript\">const obj = { name: \'Tom\', age: 20 };\nif (obj instanceof Object) {\n  console.log(\'obj is an object\');\n} else {\n  console.log(\'obj is not an object\');\n}</code></pre><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/19/168189208964071.png', '前端面试（四）', '前端基础面试题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-04-23 10:51:53', 'D', 1);
INSERT INTO `blog_essay` VALUES (29, '<h3>对象/数组常用方法有哪些？</h3><p><br></p><p style=\"text-align: start;\"><strong>对象方法：</strong></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">Object.keys(obj)：返回一个包含对象中所有属性名称的数组。</p><p style=\"text-align: start; line-height: 2;\">Object.values(obj)：返回一个包含对象中所有属性值的数组。</p><p style=\"text-align: start; line-height: 2;\">Object.entries(obj)：返回一个包含对象中所有[属性名称，属性值]的二维数组。</p><p style=\"text-align: start; line-height: 2;\">Object.assign(target, ...sources)：用于将源对象的所有可枚举属性复制到目标对象中，并返回目标对象。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\"><strong>数组方法：</strong></p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">push(item1,item2,...)：向数组末尾添加一个或多个元素，并返回新的长度。</p><p style=\"text-align: start; line-height: 2;\">pop()：从数组末尾移除最后一个元素，并返回该元素的值。</p><p style=\"text-align: start; line-height: 2;\">shift()：从数组开头移除第一个元素，并返回该元素的值。</p><p style=\"text-align: start; line-height: 2;\">unshift(item1,item2,...)：向数组开头添加一个或多个元素，并返回新的长度。</p><p style=\"text-align: start; line-height: 2;\">splice(start, deleteCount, item)：从指定索引位置开始删除指定数量的元素，并可选地插入新元素。</p><p style=\"text-align: start; line-height: 2;\">slice(start, end)：返回一个新数组，其中包含从开始索引到结束索引（不包括结束索引）的所有元素。</p><p style=\"text-align: start; line-height: 2;\">concat(item1,item2,...)：返回一个新数组，其中包含原始数组和所有指定的数组或值。</p><p style=\"text-align: start; line-height: 2;\">join(separator)：将数组中的所有元素转换为字符串，并使用指定的分隔符连接它们。</p><p style=\"text-align: start; line-height: 2;\">reverse()：将数组中的元素顺序反转。</p><p style=\"text-align: start; line-height: 2;\">sort()：对数组元素进行排序。如果未指定比较函数，则将其转换为字符串并按字母顺序排序。</p><h3></h3><h3>哪些遍历方式会改变原数组？</h3><p><br></p><ol><li style=\"text-align: start;\">push()方法<br>push()方法向数组的末尾添加一个或多个元素，并返回新的长度。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">pop()方法<br>pop()方法从数组的末尾移除最后一个元素，并返回该元素的值。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">shift()方法<br>shift()方法从数组的开头移除第一个元素，并返回该元素的值。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">unshift()方法<br>unshift()方法向数组的开头添加一个或多个元素，并返回新的长度。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">splice()方法<br>splice()方法从指定的索引位置开始删除指定数量的元素，并可选地插入新元素。这会改变原数组的长度和元素值。</li><li style=\"text-align: start;\">sort()方法<br>sort()方法用于对数组中的元素进行排序。如果未指定比较函数，则将其转换为字符串并按字母顺序排序。这会改变原数组的元素顺序。</li><li style=\"text-align: start;\">reverse()方法<br>reverse()方法用于将数组中的元素顺序反转。这会改变原数组的元素顺序。<br>需要注意的是，这些方法都会直接修改原数组，因此使用它们时需要注意是否需要保留原数组的值。如果需要保留原数组，可以先复制一份，再使用这些方法对复制的数组进行操作。</li></ol><p><br></p><p><br></p><h3>Set和Map各是什么？</h3><p><br></p><p><br></p><p style=\"text-align: start;\">Set<br>Set是一种类似于数组的数据结构，但是它的每个元素都是唯一的，没有重复的值。Set可以用于去重，例如：</p><p><br></p><pre><code class=\"language-javascript\">const arr = [1, 2, 3, 3, 4, 5, 5];\nconst set = new Set(arr);\nconsole.log(set); // Set(5) {1, 2, 3, 4, 5}</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Set提供了一些常用的方法，例如add、delete、has、clear等等，用于添加、删除、查找和清空Set中的元素。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Map Map是一种类似于对象的数据结构，它也是由键值对组成的。与对象不同的是，Map的键可以是任何数据类型，而不仅仅是字符串。另外，Map中的键是唯一的，每个键对应的值也是唯一的。例如：</span></p><p><br></p><p><br></p><pre><code class=\"language-javascript\">const map = new Map();\nmap.set(\'name\', \'Tom\');\nmap.set(\'age\', 18);\nconsole.log(map); // Map(2) {\"name\" =&gt; \"Tom\", \"age\" =&gt; 18}</code></pre><p><br></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">Map提供了一些常用的方法，例如set、get、delete、has、clear等等，用于添加、获取、删除、查找和清空Map中的键值对。 总的来说，Set和Map都是非常实用的数据结构，它们提供了快速、高效地去重、查找和存储数据的功能，可以在开发中大大提高代码的效率和可读性。</span></p><p><br></p><p><br></p><h3>介绍一下promise。</h3><p><br></p><ol><li style=\"text-align: start;\">可以解决回调地狱的问题，使得异步操作更加稳定和可控；</li></ol><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">2. &nbsp;可以使用链式调用的方式，使得代码更加优雅和简洁；</p><p style=\"text-align: start;\">3. &nbsp;可以通过then()和catch()方法分别处理异步操作成功和失败的情况，使得代码结构更加清晰和易于维护；</p><p style=\"text-align: start;\">4. &nbsp;可以使用Promise.all()方法和Promise.race()方法来处理多个异步操作的结果，使得代码更加高效和灵活。</p><p style=\"text-align: start;\"><br>需要注意的是，Promise并不是一种新的异步处理方式，它仍然是基于回调函数的异步处理方式的一种封装和升级。此外，Promise也有一些缺点，例如无法取消Promise、无法处理同步代码等等。因此，在使用Promise时需要结合实际情况进行选择和使用。</p><p><br></p><h3>Promise通常会解决三种问题，<span style=\"font-size: 16px;\">这三种方式promise是怎么处理的？</span></h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">(1)链式回调</span></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">具体来说，Promise可以通过then方法实现链式调用。每次调用then方法时，会返回一个新的Promise对象。我们可以在这个新对象上再次调用then方法来继续执行后续操作，以此类推。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">(2)同时发起几个异步请求，谁先有结果就拿谁的</span></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">Promise可以通过Promise.all方法来解决多个请求并发，等到所有请求都完成后再进行下一步处理的问题。</span></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">Promise.all接受一个数组参数，其中每个元素都是一个Promise对象。当所有Promise对象都变为fulfilled状态时，Promise.all返回一个新的Promise对象，这个新的Promise对象的状态也会变为fulfilled</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">(3)发起多个请求，等到所有请求后再做下一步处理</span></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">Promise可以通过Promise.race方法来解决同时发起几个异步请求，并且谁先有结果就拿谁的问题。</span></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">Promise.race接受一个数组参数，其中每个元素都是一个Promise对象。当其中任意一个Promise对象的状态变为fulfilled或rejected时，Promise.race返回一个新的Promise对象，并将第一个有结果的Promise对象的结果传递给新Promise对象的回调函数。</span></p><p style=\"text-align: start;\"><br></p><h3>如何改变一个函数a的上下文？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">可以使用JavaScript中的call()、apply()或bind()方法来改变一个函数a的上下文。这些方法都是函数的原型方法，可以用于改变函数的this指向。</span></p><p><br></p><p>call()方法</p><p>call()方法用于调用一个函数，同时指定该函数的this值和参数。例如：</p><p><br></p><pre><code class=\"language-javascript\">\nfunction a() {\n console.log(this.name);\n}\nconst obj = {name: \'Tom\'};\na.call(obj); // 输出Tom</code></pre><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，调用a函数时使用了call()方法，将a函数的this指向了obj对象，因此输出了Tom。</span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">apply()方法 apply()方法与call()方法类似，也用于调用一个函数，同时指定该函数的this值和参数。唯一的区别是apply()方法接收的参数是一个数组。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function a(x, y) {\n  console.log(this.name, x, y);\n}\nconst obj = {name: \'Tom\'};\na.apply(obj, [1, 2]); // 输出Tom 1 2</code></pre><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，调用a函数时使用了apply()方法，将a函数的this指向了obj对象，同时将参数1和2传递给了a函数，因此输出了Tom 1 2。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">3. bind()方法 bind()方法用于创建一个新函数，并将原函数的this值绑定到指定的对象上。不同于call()和apply()方法，bind()方法不会立即执行函数，而是返回一个新的函数，可以在稍后调用。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function a() {\n  console.log(this.name);\n}\nconst obj = {name: \'Tom\'};\nconst b = a.bind(obj);\nb(); // 输出Tom</code></pre><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在上面的例子中，使用bind()方法创建了一个新函数b，并将a函数的this值绑定到obj对象上。然后调用b函数，输出了Tom。 </span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">需要注意的是，使用这些方法改变函数的上下文时，要注意this指向的对象是否存在，否则会出现错误。</span></p><p><br></p><h3>Call和apply有什么区别？</h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">JavaScript中的call()和apply()方法都是用来改变函数中this的指向的，它们的区别在于传参方式不同。 call()方法接收的是一个参数列表，而apply()方法接收的是一个数组。例如：</span></p><p><br></p><pre><code class=\"language-javascript\">function func(arg1, arg2, arg3) {\n  console.log(this, arg1, arg2, arg3);\n}\nconst obj = { name: \'Tom\' };\nfunc.call(obj, 1, 2, 3); // 输出{ name: \'Tom\' } 1 2 3\nfunc.apply(obj, [1, 2, 3]); // 输出{ name: \'Tom\' } 1 2 3</code></pre><h3></h3><p style=\"line-height: 2;\"><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在这个例子中，func函数通过call()和apply()方法改变了this的指向，并传入了三个参数。使用call()方法时，参数是按照逗号分隔的列表形式传入的；而使用apply()方法时，参数是按照数组的形式传入的。 另外，call()方法和apply()方法的作用都是相同的，只是传参方式不同，开发者可以根据实际情况选择使用其中的一种。</span></p><h3>Evenbus是什么东西？</h3><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">\"EventBus\" 是一个在前端框架中经常使用的事件发布/订阅模式的库或工具。它不是 JavaScript 或浏览器本身提供的原生功能之一，而是通过添加额外的代码来实现这种模式。</p><p style=\"text-align: start; line-height: 2;\">\"EventBus\" 的主要思想是将应用程序分解为更小、更易于管理的部分（也称为组件），并使这些部分能够有效地进行通信。\"EventBus\" 基本上是一种可以处理大量自定义事件的框架或库，类似于其他编程语言中常见的“消息队列”或“事件机制”。</p><p style=\"text-align: start; line-height: 2;\">当一个组件需要与另一个组件通信时，它可以以简单的方式向 EventBus 发布（广播）一个事件。然后，任何对该事件感兴趣的组件都可以通过订阅 Event Bus 上的相应事件来接收到这些事件。这使得组件之间的通信变得非常容易，同时也降低了这些组件的耦合度和维护难度。</p><p style=\"text-align: start;\">创建一个新的EventBus对象</p><pre style=\"text-align: left;\"><code>import Vue from \'vue\';\nexport const EventBus = new Vue();\n\n</code></pre><p style=\"text-align: start;\">触发事件并传递数据</p><pre style=\"text-align: left;\"><code>// 在发送组件中触发事件\nimport { EventBus } from \'./event-bus\';\nEventBus.$emit(\'event-name\', data);\n\n// 在接收组件中监听事件\nimport { EventBus } from \'./event-bus\';\nEventBus.$on(\'event-name\', (data) =&gt; {\n  // 在该函数中处理接收到的数据\n});\n\n</code></pre><p style=\"text-align: start; line-height: 2;\">例如，在Vue中，$emit函数用于触发事件，并且该事件被emit函数用于触发事件，并且该事件被on函数监听。在上面的示例中，emit函数发送了一个名为’event-name’的事件，并传递了数据。在接收组件中，通过$on函数监听该事件，并在回调函数中处理接收到的数据。</p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/22/1682149518857251.jpeg', '前端面试（五）', '前端面试基础题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-04-22 15:45:18', 'D', 1);
INSERT INTO `blog_essay` VALUES (30, '<h3>父子组件生命周期执行顺序是怎么样的？</h3><p><br></p><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(255, 255, 255); font-size: 14px;\">在Vue.js中，父子组件的生命周期执行顺序如下：</span></p><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeCreate()\ncreated()\nbeforeMount()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeCreate()\ncreated()\nbeforeMount()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >mounted()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >mounted()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeUpdate()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeUpdate()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >updated()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >updated()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >beforeDestroy()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >beforeDestroy()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">子组件的生命周期：</span></p><pre><code >destroyed()</code></pre><p style=\"text-align: start;\"><span style=\"background-color: rgb(255, 255, 255);\">父组件的生命周期：</span></p><pre><code >destroyed()</code></pre><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: rgb(255, 255, 255);\"><br>在这个过程中，父组件的生命周期方法会优先于子组件的生命周期方法执行，而当父组件的生命周期方法返回时，子组件的生命周期方法才会执行。当父组件被销毁时，子组件也会随之被销毁。需要注意的是，子组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mounted()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法在父组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mounted()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法之后执行，但在父组件的</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>updated()</code></span><span style=\"background-color: rgb(255, 255, 255);\">方法之前执行。这是因为子组件的渲染必须在父组件之后才能进行，但是子组件的数据更新需要在父组件之前进行。</span></p><p><br></p><h3>mixins有几个生命周期阶段？</h3><p><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: rgb(255, 255, 255);\">在Vue.js中，</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255);\">混入的选项和组件的选项合并后，都会按照特定的生命周期顺序调用。</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255);\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255);\">有以下生命周期阶段：</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeCreate</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在实例初始化之后、数据观测 (data observation) 和 event/watcher 事件配置之前被调用。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>created</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例已经创建完成之后被调用。在这里可以进行一些数据的处理，如异步请求数据等。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeMount</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在挂载开始之前被调用。相关的 </span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>render</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\"> 函数首次被调用。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mounted</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例挂载之后调用，可以访问到 </span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>DOM</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\"> 元素，并进行相应的操作。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeUpdate</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>updated</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>beforeDestroy</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：在实例销毁之前调用。在这里可以进行一些清理工作，比如清除计时器、解绑全局事件等等。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>destroyed</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">：实例销毁之后调用，此时所有的事件监听器都已经被移除，子实例也被销毁。<br>需要注意的是，</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">会按照数组顺序依次执行对应的生命周期函数，而组件的生命周期函数会在</span><span style=\"color: var(--tw-prose-code); background-color: rgb(255, 255, 255); font-size: 16px;\"><code>mixins</code></span><span style=\"background-color: rgb(255, 255, 255); font-size: 16px;\">的生命周期函数之后执行。</span></p><p><br></p><h3>弹性布局，一行两列，一列固定宽，如何实现？</h3><p><span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">可以使用弹性布局中的</span>flex<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">属性来实现一行两列的布局，其中一列固定宽可以通过设置该列的</span>flex-basis<span style=\"color: rgb(55, 65, 81); background-color: rgb(247, 247, 248); font-size: 14px;\">属性来实现。具体实现如下：</span></p><p><br></p><pre><code class=\"language-html\">&lt;div class=\"container\"&gt;\n  &lt;div class=\"left\"&gt;固定宽度&lt;/div&gt;\n  &lt;div class=\"right\"&gt;自适应宽度&lt;/div&gt;\n&lt;/div&gt;</code></pre><pre><code class=\"language-css\">.container {\n  display: flex;\n  flex-direction: row;\n}\n.left {\n  width: 100px; /* 固定宽度 */\n  flex-basis: 100px; /* 列宽度 */\n}\n.right {\n  flex: 1; /* 自适应宽度 */\n}</code></pre><h3></h3><h3>Flex包含哪三种属性</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">在 CSS 中，\"flex\" 是一个重要的属性，是实现弹性布局 (Flexible Box Layout) 的基础。而 \"flex\" 属性包含以下三个子属性：</p><p style=\"text-align: start; line-height: 2;\">1.flex-grow：定义项目在剩余空间中放大的比例，默认为 0，即如果存在剩余空间，也不会放大。</p><p style=\"text-align: start; line-height: 2;\">2.flex-shrink：定义项目在空间不足时缩小的比例，默认为 1，即如果空间不足，也会自动缩小。</p><p style=\"text-align: start; line-height: 2;\">3.flex-basis：定义项目在分配多余空间之前，应该占据的主轴空间（即项目的原始大小），默认值为 auto，也可以设置为具体的长度或百分比。</p><p style=\"text-align: start; line-height: 2;\">这三个属性一般结合使用，例如 \"flex: 1 1 auto;\"，就表示项目既可以在剩余空间中放大，也可以在空间不足时缩小，并且占据的主轴空间为其本身的大小。</p><p style=\"text-align: start; line-height: 2;\">总之，\"flex\" 属性是很常用的 CSS 属性，它可以帮助开发者更好地实现弹性布局，提高网页设计的灵活性和可适应性。</p><p><br></p><h3>简单描述一下同步和异步</h3><p><br></p><p>1.同步任务</p><p> &nbsp;在主线程上排队执行的任务,在最前面的任务执行完成之后,才执行后面的任务.</p><p><br></p><p>2.异步任务</p><p>指不进入主线程,而是进入了“任务队列”的任务,只有“任务队列”通知主线程,某个异步任务可执行了,该任务才会进入主线程执行.</p><p><br></p><p>异步任务: 分为宏任务 和 微任务</p><p><br></p><p>宏任务: 包含整体代码script、setTimeout、setInterval</p><p><br></p><p>微任务: Promise.then(非 new Promise)、process.nextTick(node中)</p><h3></h3><h3>router.push和router.replace的区别</h3><p><br></p><p><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.push</code></span><span style=\"font-size: 16px;\"> 方法会在浏览历史中新增一个记录，即可通过浏览器的“后退”按钮返回到之前的页面；而 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.replace</code></span><span style=\"font-size: 16px;\"> 方法不会新增历史记录，所以无法通过“后退”按钮返回之前的页面。</span></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">举个例子，如果我们有一个 URL 为 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 的页面（假设这是我们当前的页面），使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.push(\'/about\')</code></span><span style=\"font-size: 16px;\"> 会导航到一个新的页面，并且浏览器的 URL 地址会从 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 变成 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/about</code></span><span style=\"font-size: 16px;\">，因此用户可以通过“后退”按钮回到刚才的 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>/home</code></span><span style=\"font-size: 16px;\"> 页面。而使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>router.replace(\'/about\')</code></span><span style=\"font-size: 16px;\"> 也会导航到新的页面，但浏览器 URL 不会改变，因此无法通过“后退”按钮返回到之前的页面。</span></p><p style=\"text-align: start;\"><br></p><h3>Grid布局</h3><p><br></p><p style=\"line-height: 2;\">grid布局虽然强大，但学习起来不如flex方便，需多加使用</p><p> <a href=\"https://juejin.cn/post/7189877500212674616\" target=\"_blank\">稀土掘金</a> </p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/20/1681974396589618.png', '前端面试（六）', '前端面试基础题', '', '前端,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-08 23:56:14', 'D', 1);
INSERT INTO `blog_essay` VALUES (31, '<h3>1.Webpack是什么？</h3><p><br></p><p style=\"line-height: 2;\">webpack 是一个静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。</p><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\">webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。</p><p style=\"line-height: 2;\">插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。</p><p><br></p><p><br></p><h3 style=\"text-align: start;\">2.Webpack的打包过程/打包原理/构建流程？</h3><p><br></p><p><img src=\"http://127.0.0.1:7001/public/uploads/2023/04/27/1682594499999232.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p><p style=\"line-height: 2;\">命令行执行npx webpack打包命令开始</p><p style=\"line-height: 2;\">1.初始化编译参数:从配置文件和shell命令中读取与合并参数</p><p style=\"line-height: 2;\">2.开始编译:根据上一步得到的参数初始化Compiler对象，加载所有配置的Plugin，执行对象的 run 方法开始执行编译。</p><p style=\"line-height: 2;\">3.确定入口:根据配置中的 entry 找出所有的入口文件</p><p style=\"line-height: 2;\">4.编译模块:从入口文件触发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，然后递归本步骤直到所有入口依赖的文件都进行翻译。</p><p style=\"line-height: 2;\">5.完成模块编译:在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系图。</p><p style=\"line-height: 2;\">6.输出资源：根据依赖关系图，组装成一个个包含多个模块的Chunk，再把每个Chunk转化成一个单独的文件加入到输出列表，根据配置确定输出的路径和文件名，输出。</p><p><br></p><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。</p><p><br></p><p> <a href=\"https://blog.csdn.net/zsj21438/article/details/128799440\" target=\"_blank\">详细打包流程</a> </p><p><br></p><h3 style=\"text-align: start;\">3.Webpack中loader的作用/ loader是什么？</h3><p><br></p><p style=\"line-height: 2;\">Loader 是webpack中提供了一种处理多种文件格式的机制，因为webpack只认识JS和JSON，所以Loader相当于翻译官，将其他类型资源进行预处理。</p><p style=\"line-height: 2;\">用于对模块的\"源代码\"进行转换。</p><p style=\"line-height: 2;\">loader支持链式调用,**调用的顺序是从右往左。**链中的每个loader会处理之前已处理过的资源，最终变为js代码。</p><p style=\"line-height: 2;\">可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。</p><p><br></p><p><br></p><h3 style=\"text-align: start;\">4.常见的loader有哪些？</h3><p><br></p><p>less-loader:将less文件编译成css文件</p><p>开发中，我们常常会使用less预处理器编写css样式，使开发效率提高</p><p><br></p><p>css-loader:将css文件变成commonjs模块加载到js中，模块内容是样式字符串</p><p>style-loader: 创建style标签，将js中的样式资源插入标签内，并将标签添加到head中生效</p><p>ts-loader: 打包编译Typescript文件</p><p><br></p><h3>5.Plugin有什么作用？/Plugin是什么</h3><p><br></p><p>Plugin功能更强大，主要目的就是解决loader 无法实现的事情，比如打包优化和代码压缩等。</p><p style=\"line-height: 2;\">Plugin加载后，在webpack构建的某个时间节点就会触发plugin定义的功能，帮助webpack做一些事情。实现对webpack的功能扩展。</p><p><br></p><h3>6.常见的Plugin有哪些</h3><p><br></p><p>html-webpack-plugin 处理html资源，默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css）</p><p style=\"line-height: 2;\">mini-css-extract-plugin 打包过后的css在js文件里，该插件可以把css单独抽出来</p><p>clean-webpack-plugin 每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除</p><p><br></p><h3>7.Webpack 做过哪些优化手段？有哪些优化手段？</h3><p><br></p><p>tree-shaking 删除没有使用的代码 优化前端性能/提高构建速度</p><p style=\"line-height: 2;\">tree-shaking是一种基于 ES Module 规范的 Dead Code Elimination 技术打包，在打包过程中检测工程中没有引用过的模块并进行标记，删除没有引用过的模块，提高构建速度，较少程序运行时间。</p><p><br></p><h3>8.使用tree-shaking需要注意什么？</h3><p><br></p><p>1.默认mode = production ，生产环境默认开启tree-shaking功能。</p><p>2.需要是使用 ES6 规范编写模块代码,ES6的模块依赖关系是确定的，和运行时状态无关</p><p style=\"line-height: 2;\">3.尽量不写带有副作用的代码。如编写了立即执行函数，在函数里使用了外部变量等。</p><p><br></p><p><br></p><h3>9.如何利用webpack来优化前端性能？</h3><p><br></p><p><br></p><p><strong>代码压缩</strong></p><p><br></p><p><br></p><p><strong>按需加载</strong></p><p><br></p><p><br></p><p><strong>代码分割 splitChunks - 在optimization配置项中配置</strong></p><p><br></p><p style=\"line-height: 2;\">1.可以将node__mudules中代码单独打包成一个chunk输出（比如使用了jqury？）</p><p>2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包</p><p><br></p><p><br></p><p><strong>使用Dll进行分包</strong></p><p><br></p><p>正常情况下node_module会被打包成一个文件</p><p style=\"line-height: 2;\">使用dll技术，对可以将那些不常更新的框架和库进行单独打包，生成一个chunk</p><p><br></p><p><br></p><p><strong>使用路由懒加载</strong></p><p><br></p><p style=\"line-height: 2;\">在代码中所有被 import()函数引用的模块，都将打成一个单独的包，放在 chunk 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/04/27/1682594919650391.png', 'webpack面试题', '了解webpack打包，基础面试题', '以webpack的定义，打包过程，流程，原理以及如何优化前端代码来帮助你了解webpack', 'webpack,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-08 20:10:13', 'U', 1);
INSERT INTO `blog_essay` VALUES (32, '<h1>一、前端基础</h1><p><br></p><h3>1.javascript的typeof返回那些数据类型?</h3><p><br></p><p>string、number、 bool、 undefined、 function、 object</p><p><br></p><p><br></p><h3>2.列举三种强制类型转换和两种隐式类型转换</h3><p><br></p><p><br></p><p>强制: . parseInt，parseFloat, number</p><p>隐式: number+string ，if 条件语句</p><p><br></p><h3>3. split()和join()的区别</h3><p><br></p><p><br></p><p>split字符串转数组</p><p>join数组转字符串</p><p><br></p><h3>4.数组方法pop () , push ()，unshift () , shift()</h3><p><br></p><p><br></p><p>pop()尾部删除，push() 尾部添加，unshift() 头部添加，shift() 头部删除</p><p><br></p><h3>5.Ajax get和post的区别</h3><p><br></p><p>get拼在url里，post放在虚拟载体里，get大小有限制，</p><p>get 请求数据，post提交数据</p><p><br></p><p><br></p><h3>6. ajax解析json字符串</h3><p><br></p><pre><code class=\"language-javascript\">json.parse()</code></pre><p><br></p><h3>7.事件委托是什么</h3><p><br></p><p>利用事件冒泡让作用在自身触发的事件由父元素代替执行</p><p><br></p><p><br></p><h3>8.闭包是什么</h3><p><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-size: 16px;\">闭包（Closure）是指在一个函数内部创建另一个函数，这个内部函数能够访问外部函数的变量和参数，并且即使外部函数运行结束后，它仍然可以访问这些变量和参数。通俗来说，闭包就是能够读取其他函数内部变量的函数。使得函数不被gc回收,闭包过多容易</span></p><p><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-size: 16px;\">导致内存泄漏</span></p><p><br></p><p><br></p><h3>9.如何阻止事件冒泡</h3><p><br></p><p><br></p><p>ie: ev.cancelBubble = true;</p><p>非ie: ev.stopPropagation()</p><h3></h3><h3></h3><p><br></p><h3>10.如何阻止默认事件</h3><p><br></p><p><br></p><pre><code class=\"language-javascript\">@click.prevent()\nevent.preventDefault()\n</code></pre><p><br></p><h3>11. JS延迟加载的方式</h3><p><br></p><p>defer和async ;</p><p>动态创建dom,按需异步引入</p><p><br></p><p><br></p><h3>12.写一个获取非行间样式的函数</h3><p style=\"text-align: start;\"><br></p><pre style=\"text-align: start;\"><code class=\"language-javascript\">function getStyle(element, style) {\n  // Get the computed/best style of the element\n  var computedStyle = window.getComputedStyle(element);\n  \n  // Return the value of the specified style property\n  return computedStyle.getPropertyValue(style);\n}\n</code></pre><p style=\"text-align: start;\">这个函数接受两个参数：一个表示元素的对象和一个表示要获取的样式属性值（例如 <span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>color</code></span><span style=\"font-size: 16px;\">、</span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>font-size</code></span> 等）。它首先使用浏览器提供的 <span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>getComputedStyle()</code></span> 方法来获取元素的计算样式（即最终呈现给用户的样式），然后通过指定的样式属性名称获取它的属性值。如果要在特定的元素上获取特定的非行间样式属性，可以将该元素对象和样式属性名称作为参数传递给该函数。</p><p style=\"text-align: start;\"><br></p><pre><code class=\"language-javascript\">function getStyle (obj,attr) {\n    if (obj.currentStyle) {\n    return obj.currentStyle[attr];\n    }else{\n    getComputedStyle(obj, false)[attr]\n}</code></pre><h3></h3><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">这个函数用于获取某个元素的非行间样式。它的第一个参数 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>obj</code></span><span style=\"font-size: 16px;\"> 表示要获取样式的元素对象，第二个参数 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>attr</code></span><span style=\"font-size: 16px;\"> 是一个字符串类型的表示要获取的样式属性名。</span></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">该函数首先检查该元素对象上是否有 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>currentStyle</code></span><span style=\"font-size: 16px;\"> 属性（只在IE浏览器中存在）。如果该属性存在，则使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>obj.currentStyle[attr]</code></span><span style=\"font-size: 16px;\"> 语法来返回元素的指定样式属性的值。</span></p><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">如果当前浏览器不是IE浏览器，那么就说明这个元素的最终样式应该通过 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>getComputedStyle</code></span><span style=\"font-size: 16px;\"> 方法来获取。所以它调用了 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>getComputedStyle(obj, false)</code></span><span style=\"font-size: 16px;\"> 函数来获取该元素的计算非行间样式对象，再将属性名称传递给它进行获取，并且返回对应的样式属性值。</span></p><h3></h3><h3>13.获取页面所有的checkbox</h3><p><br></p><pre><code class=\"language-javascript\">var check=[]\nfor(const obj in arr) {\n    if(obj.type =\'checkbox\') {\n    check.push(obj)\n    }\n}</code></pre><p><br></p><p><br></p><p><br></p><h3>14. cookie在客户机上如何存储</h3><p><br></p><p>cookies就是服务器暂时存放在电脑里的文本文件,好让服务器用来辨认你的计算机。当你在浏览网站的时候，web服务器会先送一份资料放在你的计算机上，cookies会帮你在网站上所打的文字或是一些选择都记录下来，当你下次在访问同一个网站，web 服务器会先看看有没有上次留下的cookies资料，有的话就根据cookie内容判断使用者，送出特定网页。</p><p><br></p><p><br></p><h3>15.获取三个数中的最大值和最小值</h3><p><br></p><p>Math. max() //最大值Math. min() //最小值，</p><p><br></p><p><br></p><h3>16. javaScript是面向对象的，怎么体现javaScript的继承关系</h3><p><br></p><p>使用prototype</p><p><br></p><p><br></p><h3>17. form 中的input可以设置为readonly和disabled,请问两者有什么区别</h3><p><br></p><p>readonly不可编辑，可以选择复制，值可以传到后台。</p><p>disabled不可编辑，不能选择复制，值不能传到后台。</p><p><br></p><p><br></p><h3>18.列举JavaScript的三种主要数据类型, 两种复合数据类型,和两种特殊数据类型</h3><p><br></p><p>主要数据类型: string number boolean</p><p>复合数据类型: function object</p><p>特殊数据类型: undefined null</p><p><br></p><p><br></p><h3>19. ajax原理</h3><p><br></p><p>(1)创建对象; (2)打开请求; (3) 发送请求; (4)接受响应.</p><p><br></p><p><br></p><h3>20.解释什么是json</h3><p><br></p><p>(1)json是一种轻量级数据交换格式</p><p>(2)json独立于语言数据平台，json 解析器和json库支持多种语言</p><p>(3)json语法表示三种类型:值简单值(字符串，数值，布尔值，null);数组;对象</p><p><br></p><h3>21.js中三种弹出消息提醒</h3><p><br></p><p>alert; confirm; &nbsp;prompt</p><p><br></p><p><br></p><h3>22.浏览器的滚动距离</h3><p><br></p><p>可视区域距离页面顶部的距离</p><p><br></p><pre><code class=\"language-javascript\">scrollTop=document.documentElement.scrollTop||document.body.scrollTop</code></pre><p><br></p><p><br></p><h3>23.可视区的大小</h3><p><br></p><p><br></p><pre><code class=\"language-javascript\">window.innerHeight\nwindow.innerWidth</code></pre><p>(不兼容IE)</p><pre><code class=\"language-javascript\">document.documentElement.clientWidth\ndocument.documenElement.clientHeight</code></pre><p>(兼容IE)</p><p><br></p><p><br></p><h3>24.节点的类型有几种，分别是什么</h3><p><br></p><p>(1)元素节点: nodetype == 1</p><p>(2)属性节点: nodetype == 2</p><p>(3) 文本节点: nodetype == 3</p><p><br></p><p><br></p><h3>25. innerHtml和outerHtml的区别</h3><p><br></p><p>innerHtml不包括自身</p><p>outerHtml包括自身</p><p><br></p><p><br></p><h3>26.闭包的好处</h3><p><br></p><p>(1)希望一个变量长期驻扎在内存当中</p><p>(2)避免全局变量的污染.</p><p>(3)私有成员的存在</p><p>(4)安全性的提高</p><p><br></p><h3>27. 冒泡排序</h3><p><br></p><pre><code class=\"language-javascript\">function bubbleSort(arr) {\n let len = arr.length; \n     for (let i = 0; i &lt; len - 1; i++) { \n         for (let j = 0; j &lt; len - 1 - i; j++) { \n             if (arr[j] &gt; arr[j + 1]) { \n             //交换两个元素的位置 \n             [arr[j],arr[j + 1]] = [arr[j + 1], arr[j]]; \n             } \n        } \n     }\n  return arr; \n  }</code></pre><h3></h3><p><br></p><h3>28. js实现-一个函数对JavaScript中的json对象进行克隆</h3><p><br></p><pre><code class=\"language-javascript\">function() {\nvar obj = {id: 123}\nvar new0bj = JSON. parse (JSON. stringify (obj))</code></pre><h3></h3><h3></h3><h3>29. js实现一个函数，获取url参数</h3><p><br></p><pre><code class=\"language-javascript\">function getQueryString (name) {\nvar reg = new RegEXP(\"(^|&)\" + name+ \"=([^ &]*) (&|$)\",\"i\");\nvar r = window. localtion. search. substr (1). match (reg) ;\nif(r!=null) return unescape(r[2]); return null;\n}</code></pre><h3></h3><h3></h3><h3>30.写出三个使用this的典型应用</h3><p><br></p><p>事件: onclick this -&gt;发生事件的对象</p><p>构造函数: this -&gt; new 出来的object</p><p>call/apply改变this指向</p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683092237317515.jpeg', '码上前端基础面试（上）', '码上面试|前端面试题', '', '面试,码上', '其他', '1', '2022-07-04 19:49:39', '2023-05-06 11:34:40', 'U', 1);
INSERT INTO `blog_essay` VALUES (33, '<h3>31.为什么利用多个域名来储存网站资源会更有效</h3><p><br></p><p>确保用户在不同地区能用最快的速度打开网站,其中某个域名崩溃用户也能用其它域名访问</p><p><br></p><p><br></p><h3>32.请说出三种降低页面加载时间的方法</h3><p><br></p><p>(1)压缩js, css</p><p>(2)合并js, css</p><p>(3)外部js,css放在页面底部</p><p>(4)减少dom操作</p><p><br></p><p><br></p><h3>33.文档类型的作用是什么，你知道多少种文档类型</h3><p><br></p><p><br></p><p>影响浏览器对代码的编译渲染</p><p>html2.0 xhtml html5</p><p><br></p><p><br></p><h3>34.标准模式和怪异模式的区别是什么</h3><p><br></p><p><br></p><p>盒模型解释不同</p><p><br></p><h3></h3><p>标准模式（也叫严格模式）：浏览器按照 Web 标准来解析 HTML 和 CSS，保证了页面的正确性和稳定性。在 HTML 文档中使用 &lt;!DOCTYPE&gt; 声明来指定文档类型时，浏览器会以标准模式进行渲染。这种模式一般情况下可以保证浏览器的兼容性。</p><p><br></p><p>怪异模式（也称为混杂模式、Quirks mode）：浏览器以一种比较宽松的方式解析 HTML 和 CSS，会考虑过去老版本的浏览器的渲染行为，以保证老旧网页的正常显示。在 HTML 文档没有使用或使用了错误的 &lt;!DOCTYPE&gt;声明时，浏览器会以怪异模式进行渲染。该模式下，页面的解析存在很大的不确定性，而且可能导致排版混乱、兼容性差、加载速度慢等问题。</p><p><br></p><h3>35.请解释什么是JavaScript的模块模式，并列举出实用案例</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">JavaScript 的模块模式是一种用于实现模块化编程的设计模式。使用这种模式，可以将一个大型应用程序划分为功能相对独立、易于维护和测试的小模块，同时通过封装变量和方法，避免了全局命名空间的污染。</p><p style=\"text-align: start;\">常见的 JavaScript 模块模式包括：</p><p style=\"text-align: start; line-height: 2;\">立即执行函数：将要暴露给外部的变量挂载在立即执行函数中，只能通过返回值或引用其内部方法来访问。该模式的优点是简单易用且用户无法直接访问加密方法和数据。常见案例如下：</p><pre style=\"text-align: start;\"><code class=\"language-hljs code\">(function(){\n    let privateVariable = \'I am private\'; // 私有变量\n    let publicVariable = \'I am public\'; // 公共变量\n    function privateMethod() {...}; // 私有方法\n    function publicMethod() {...}; // 公共方法\n\n    // 将公共变量和方法添加到暴露对象\n    window.myModule = {\n        publicVariable,\n        publicMethod\n    };\n})();\n</code></pre><p style=\"text-align: start; line-height: 2;\">对象字面量：使用对象字面量的方式创建模块，将要公开的方法和属性添加到返回的对象上。该模式简洁易用，适合创建工厂方法和单例模式。常见案例如下：</p><pre style=\"text-align: start;\"><code class=\"language-hljs code\">let myModule = {\n    publicVariable: \'I am public\',\n    publicMethod: function() {...},\n    privateVariable: \'I am private\',\n    privateMethod: function() {...}\n};\n</code></pre><p style=\"text-align: start; line-height: 2;\">暴露模块功能：通过将需要暴露的方法和变量添加到导出对象上，从而实现外部代码可以直接访问暴露内容的效果。这个模式通常在使用 CommonJS 或 ES6 的 export 语法时出现。</p><p style=\"text-align: start; line-height: 2;\">JavaScript 模块模式适用于任何规模的项目，可以有效地组织代码、避免全局命名空间污染，并优化代码结构。</p><p style=\"text-align: start; line-height: 2;\">还经常运用于以下案例：</p><p style=\"line-height: 2;\"> sea.js</p><p style=\"line-height: 2;\"> 命名空间</p><p><br></p><p><br></p><h3>36.你如何优化自己的代码</h3><p><br></p><p><br></p><p>(1)代码重用。</p><p>(2)避免全局变量。</p><p>(3)拆分函数避免函数过于臃肿。</p><p>(4)注释</p><p><br></p><p><br></p><h3>37. javaScript中的继承是如何工作的</h3><p><br></p><p><br></p><p>子函数中执行父构造函数，并用call/apply改变this</p><p>克隆父构造函数原型上的方法</p><p><br></p><p><br></p><h3>38. dom事件委托的原理，有什么缺点</h3><p><br></p><p>事件委托原理:事件冒泡机制</p><p><br></p><p>(1) 可以节省大量内存占用，减少事件注册</p><p>(2)可以实现当新增子对象时，无需再对其进行事件绑定</p><p>缺点:可能会出现事件误判</p><p><br></p><p><br></p><h3>39.dom选择器的优先级以及权重值计算</h3><p><br></p><p>行内样式1000</p><p>id 100</p><p>类选择器，伪类选择器，属性选择器10</p><p>标签选择器伪元素选择器1</p><p>通配符子选择器相邻选择器0</p><p><br></p><h3>40. Vue数据双向绑定的原理</h3><p><br></p><p>采用数据劫持，通过object. definePropety()劫持setter和getter在数据变动时发送消息给订阅者，触发监听回调。</p><p><br></p><h3>41.网页布局有哪几种</h3><p><br></p><p>静态;自适应;流式布局;响应式。</p><p><br></p><p><br></p><h3>42.怎么判断两个对象相等</h3><p><br></p><p>JSON.stringify(obj) = JSON.stringify (obj)</p><p><br></p><p><br></p><h3>43. Vue router 除了router- link实现跳转</h3><p><br></p><p>router. go()</p><p>router. push ()</p><p><br></p><p><br></p><h3>44. Vue router 和location. href有什么区别</h3><p><br></p><p>router是虛拟路由，不刷新页面</p><p>href是页面跳转，刷新页面</p><p><br></p><h3>48. CSS margin 重叠问题</h3><p><br></p><p><br></p><p>外间距均为正数，会选择最大的外边距作为间距</p><p>设置display: inner-block 不会出现重叠</p><p>position: absolute 也不会重叠</p><p><br></p><p><br></p><h3>49.cssx选择器优先级</h3><p><br></p><p>id&gt;类&gt;标签&gt;相邻&gt;子选择器&gt;后代选择器&gt;属性&gt;伪类</p><p><br></p><p><br></p><h3>50.跨域相关</h3><p><br></p><p>协议、域名、端口有一个不同都属于不同的域</p><p>解决方案</p><p>(1)服务器设置响应头</p><p>(2) jsonp</p><p>(3) document.domain + iframe</p><p>(4) window.name + iframe</p><p>(5) window.postMessage</p><p><br></p><p><br></p><h3>51. foreach和map的区别</h3><p><br></p><p>相同点:</p><p>(1)都是循环遍历数组中每一项</p><p>(2)每次执行都支持三个匿名参数(item, index, arr)</p><p>(3) 匿名函数中的this指向都是window .</p><p>(4)只能遍历数组</p><p>(5)都有兼容问题</p><p>不同点</p><p>(1) map速度比foreach快:</p><p>(2) map会返回一个新数组，对原数组无影响，foreach 不会产生新数组</p><p>(3) map返回数组可以链式操作，foreach不能</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683100038258363.png', '码上前端基础面试（下）', '前端面试', '', '前端,码上,面试', 'HTML', '1', '2022-07-04 19:49:39', '2023-05-06 23:31:59', 'I', 1);
INSERT INTO `blog_essay` VALUES (34, '<h3> 1.浏览器中，从输入ur1到页面显示出来，具体的流程是什么?</h3><p><br></p><p><br></p><p>(1) DNS解析</p><p>(2) TCP连接</p><p>(3)发送HTTP请求</p><p>(4)服务器处理请求并返回需要的数据</p><p>(5)浏览器解析渲染页面</p><p>A.解析HTML,生成DOM树，解析CSS，生成CSSOM树</p><p>B.将DOM树和CSSOM树结合，生成渲染树(Render Tree)</p><p>C. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息(位置，大小)</p><p>D. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p><p>E. Display:将像素发送给GPU，展示在页面上</p><p>(6)连接结束</p><p><br></p><p><br></p><h3>2. get post 区别?</h3><p><br></p><p>(1) get在浏览器回退时不会再次发送请求，post会在此提交请求</p><p>(2) get的请求及参数会被保留在浏览器历史记录里，post不会.</p><p>(3) get提交数据有大小限制，根据浏览器来定(一般为1024字节)，post则</p><p>没有，或是根据服务器设置和内存大小来定</p><p>(4) get参数会直接暴露在地址栏里，post相对更安全</p><p>(5) get参数通过url传递，post的参数通过request body</p><p><br></p><h3>3. url最长有多少?</h3><p>根据不同浏览器长度不一致1024、2083...字节</p><p><br></p><h3>4.XsS攻击的了解?</h3><p>(1)跨站脚本攻击</p><p style=\"line-height: 2;\">(2)攻击者提交脚本数据后，网站保存到服务器数据库里，其他人访问读取到该数据浏览器会执行这段脚本。</p><p>(3)常见的xss攻击方式</p><p><br></p><pre><code >A. &lt;script&gt;alert(\' XSS\')&lt;/script&gt;:最普通的xSs\nB. &lt;script&gt;alert (document. cookie) &lt;/script&gt;:获取cookie .\nC. &lt;img src =\" javascript:alert(\' XSS\')\"&gt;:img链接地址xss\nD. &lt;script src=\' ls. js\'&gt;&lt;/script&gt;:外部攻击代码\nE. &lt;script&gt;alert/*注释*/(\' XSS\')&lt;/script&gt;:注释方法防止过滤\nF. &lt;img src = \'’onerror=alert(\'XSS\')&gt;:加载图像失败执行\nG. &lt;iframe onload = alert(\' XSS\')&gt;:框架\nH. &lt;script&gt;location = \' baidu. com\' ;&lt;/script&gt;:跳转某页面\nI. &lt;a href =\" javascript:alert(\' XSS\')\"&gt;&lt;/a&gt;:a链接的xss\nJ. body {bockground- image: url (javascript:alert(\'XSS))}:在css样式中加入</code></pre><p><br></p><p>(4)预防</p><p>A.输入内容长度控制:对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止XSS发生，但可以增加XSS 攻击的难度。</p><p>B.其他安全措施HTTP- -only Cookie: 禁止JavaScript读取某些敏感Cookie, 攻击者完成XSS注入后也无法窃取此Cookie。</p><p>验证码:防止脚本冒充用户提交危险操作。</p><p><br></p><h3>5.图片优化?</h3><p><br></p><p>懒加载;压缩;响应式;图片大小;字体图标;精灵图</p><p><br></p><p><br></p><h3>6.前后端鉴权?</h3><p><br></p><p>HTTP Basic Authentication</p><p>session-cookie</p><p>Token验证</p><p>0Auth(开放授权)</p><p><br></p><p><br></p><h3>7.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</h3><p><br></p><p>Chrome: webkit</p><p>Safari: webkit</p><p>fire fox: Gecko</p><p>Edge: Chromium</p><p>Ie: Trident</p><p><br></p><p><br></p><h3>8. pwa (Progressive Web Apps) ?</h3><p><br></p><p>(1)是Google 提出的用前沿的Web技术为网页提供App般使用体验的一系列方案。</p><p style=\"line-height: 2;\">(2)一个PWA应用首先是一个网页，可以通过Web技术编写出一个网页应用.随后添加_上App Manifest 和Service Worker来实现PWA 的安装和离线等功能。</p><p><br></p><h3>9. https有几次握手?</h3><p><br></p><p>7次握手，TCP 3次、SSL/TLS 4次</p><p>而http只需要建立TCP的三次</p><p>(1) TCP: 三次握手</p><p style=\"line-height: 2;\">A.第一次握手:建立连接。客户端发送连接请求报文段，将SYN位置为1,Sequence Number 为x;然后，客户端进入SYN_ SEND状态，等待服务器的确认;</p><p style=\"line-height: 2;\">B.第二次握手:服务器收到SYN报段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认,设置Acknowl edgmentNumber为x+1 (SequenceNumber+1) ; 同时，自己自己还要发送SYN请求信息，SYN位置为1, SequenceNumber为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_ RECV 状态;</p><p style=\"line-height: 2;\">C.第三次握手:客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number 设置为y+1，向服务器发送ACK报文段这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态。</p><p style=\"line-height: 2;\"><span style=\"color: rgb(225, 60, 57);\">D.为什么要三次握手:为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</span></p><p style=\"line-height: 2;\">简单的说：</p><ol><li style=\"text-align: start;\">发起连接方向被连接方发送一个带有SYN标志的TCP数据包，表示发起连接请求</li><li style=\"text-align: start; line-height: 2;\">被连接方收到连接请求后回复一个带有SYN/ACK标志的TCP数据包，表示可以建立连接</li><li style=\"text-align: start;\">发起连接方收到确认后再发送一个带有ACK标志的TCP数据包，表示连接建立成功</li></ol><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\">(2) SSL/TLS: 四次挥手</p><p style=\"line-height: 2;\">A.第一次挥手:主机1(可以使客户端，也可以是服务器端)，设置SequenceNumber，向主机2发送一个FIN报文段;此时，主机1进入FIN_ WAIT_ 1状态;这表示主机1没有数据要发送给主机2了;</p><p style=\"line-height: 2;\">B.第二次挥手:主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文，Acknowledgment Number 为Sequence Number加1;主机1进入FIN_ _WAIT_ 2状态;主机2告诉主机1，我“同意”你的关闭请求;</p><p style=\"line-height: 2;\">C.第三次挥手:主机2向主机1发送FIN报文段,请求关闭连接，同时主机2进入LAST_ ACK状态;</p><p style=\"line-height: 2;\">D.第四次挥手:主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段,然后主机1进入TIME_ WAIT 状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了</p><p style=\"line-height: 2;\"><span style=\"color: rgb(225, 60, 57);\">E.为什么要四次挥手: TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时,只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了;但是，这个时候主机1还是可以接受来自主机2的数据;当 主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的;当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1,我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</span></p><p>简单的说：</p><ol><li style=\"text-align: start; line-height: 2;\">发送方向接收方发送一个带有结束命令的TCP数据包，表示数据传输完成，但是仍可能存在其它数据需要传输</li><li style=\"text-align: start;\">接收方回复一个带有确认命令的TCP数据包，表示已经收到发送方的结束命令，并确保发送方确实完成了数据传输</li><li style=\"text-align: start; line-height: 2;\">接收方向发送方发送一个带有结束命令的TCP数据包，表示接收方数据传输已经完成，但仍可能存在其它数据需要传输</li><li style=\"text-align: start;\">发送方回复一个带有确认命令的TCP数据包，表示已经收到接收方的结束命令，并确保接收方确实完成了数据传输</li></ol><p style=\"text-align: start; line-height: 2;\">通过这四次挥手，SSL/TLS连接就彻底关闭了。在SSL/TLS连接中，前两次挥手中包含SSL/TLS层级的关闭通知，用于告知对方要结束安全连接。后两次挥手则是TCP连接的正常关闭过程。</p><p><br></p><h3>10.页面刷新不出来，是有哪些问题?</h3><p><br></p><p style=\"line-height: 2;\">(1)域名不存在，或者ip地址错误.</p><p>(2)网络问题，不能建立正常的tcp连接</p><p>(3)服务器找不到正确的资源</p><p><br></p><p><br></p><p><br></p><h3>11.请描述cookies、 sessionStorage 和localStorage 的区别?</h3><p><br></p><p><br></p><p>(1) cookies大小为4kb，sess ionStorage 和localStorage一般为5m</p><p style=\"line-height: 2;\">(2) cookies 可以使用setMaxAge来设置它的失效时间，sessionStorage的失效时间是当会话关闭，localStorage 是永久存储除非用户清空缓存。</p><p>(3) cookies会参与服务器端通信，sessionStorage和localStorage不会参与服务器端通信。</p><p><br></p><p><br></p><h3>12.为什么通常推荐将CSS&lt;link&gt; 放置在&lt;head&gt;&lt;/head&gt; 之间，而</h3><h3>将JS，&lt;script&gt;放置在&lt;/body&gt; 之前?你知道有哪些例外吗?</h3><p><br></p><p style=\"line-height: 2;\">(1) &lt;link&gt; 放置在&lt;head&gt;&lt;/head&gt; 之间可以使页面逐步呈现，防止出现空白页面，放在尾部的话部分浏览器里会阻止渲染，以避免在样式发生变化的时候重绘页面。</p><p style=\"line-height: 2;\">(2)脚本在下载和执行期间会阻止HTML解析，所以JS &lt;script&gt;放置在&lt;/body&gt;之前可以保证HTML首先解析完成，尽早将页面呈现给用户。</p><p style=\"line-height: 2;\">(3)例外:在JS里使用window. onload, 这时候把js放在&lt;head&gt;&lt;/head&gt;之间也可以保证在HTML解析完成后执行脚本。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/07/10/1688962658708256.png', '浏览器面试题', '了解浏览器||浏览器面试基础题||前端', '', '浏览器,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-06 14:36:44', 'U', 1);
INSERT INTO `blog_essay` VALUES (35, '<h3> 1. Vue mvvm? </h3><p>(1)解析</p><p>A.m: model 数据层(存储数据)</p><p>B.v: view视图层(UI用户界面)</p><p>C. vm: ViewModel 业务逻辑层(一切js可视为业务逻辑)</p><p>(2) MVVM将数据双向绑定(data-binding)作为核心思想，View和Model 之间没有联系，它们通过ViewModel 这个桥梁进行交互。</p><p>(3) Model和ViewModel 之间的交互是双向的，因此View的变化会自动同步到Model，而Model 的变化也会立即反映到View. 上 显示。</p><p>(4)当用户操作View， ViewModel 感知到变化，然后通知Model 发生相应改变;反之当Model发生改变，ViewModel也能感知到变化，使View 作出相应更新。</p><p>(5) 相比于mvc， mvvm少了c (Controller) 解析数据这一步骤</p><p><br></p><p><br></p><h3>2.Vue的双向绑定的原理是什么?</h3><p><br></p><p>(1) Vue双向绑定主要通过数据监听器、指令解析器、订阅者来进行一个双向绑定的整个流程</p><p>A.数据监听器Observer, 能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p><p>B.指令解析器Compile,对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p><p>C.订阅者Watcher, 作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p><p>(2) Vue2</p><p>A.通过Object. defineProperty属性劫持来实现双向绑定</p><p>B.缺点</p><p>object.defineProperty无法监听对象属性的删除和添加，所以类似直接通过修改数组元素，双向绑定就不会生效.</p><p>object.defineProperty只能遍历对象属性直接修改(需要深拷贝进行修改)</p><p>C. Vue3</p><p>通过Proxy来劫持</p><p><br></p><p><br></p><h3>3.Vue生命周期钩子函数有哪些?</h3><p><br></p><p>(1) beforeCreate:数据初始化之前</p><p>(2) created: 数据初始化之后，但未生成dom</p><p>(3) beforeMount: 准备生成dom</p><p>(4) mounted: 生成dom之后</p><p>(5) beforeUpdate: 准备修改dom</p><p>(6) updated: 修改dom之后</p><p>(7) beforeDestroy: 组件销毁之前</p><p>(8) destroyed: 组件销毁之后</p><p><br></p><p><br></p><h3>4.请问v-if和v-show有什么区别?</h3><p><br></p><p>(1) v-if 是控制是否删除dom。</p><p>(2) v-show 是使用css display: none 来控制是否显示隐藏。</p><p><br></p><p><br></p><h3>5. Vue常用的修饰符?</h3><p>(1) number 将用户的输入值转为数值类型</p><p>(2) trim 自动过滤用户输入的首尾空白字符</p><p>(3)事件修饰符</p><p>A.stop阻止单击事件继续传播</p><p>B. capture添加事件监听器时使用事件捕获模式</p><p>C.self 只当在event. target 是当前元素自身时触发处理函数</p><p>D. prevent阻止默认行为</p><p>E. sync &nbsp; 通常用于控制组件的显示隐藏</p><p><br></p><p><br></p><h3>6. nextTick?</h3><p><br></p><p><br></p><p>每次Vue编译后更新dom过后会触发this. $nextTick()方法，参数是回调函数</p><p><br></p><h3>7.什么是Vue生命周期?</h3><p><br></p><p>组件在初始化、生成dom、修改dom、销毁组件的整个过程</p><p><br></p><h3>8. virtual dom 原理实现?</h3><p><br></p><p>是由js来描述dom的对象，也叫虛拟dom。这个对象里面由描述这个dom节点的属性，最后需要渲染到真是dom上的时候，只需要调用render函数，也就是用虚拟dom.上的标签名、dom属性这些转换成真是的dom,最后再渲染到dom上</p><p><br></p><h3>9.Vue中key值的作用?</h3><p><br></p><p>修改dom或删除dom的时候，有了key 的化，diff 算法就可以更高效的识别到这个节点，然后进行修改、删除、新增操作。</p><p><br></p><h3>10. Vue组件中data 为什么必须是函数? </h3><p><br></p><p>如果不使用函数的话，每次创建组件data都指向的是同一个对象，使用函数的话每次创建组件都会在内存开辟一个新的空间去存放data。</p><p><br></p><h3>11. v- for与v-if的优先级?</h3><p><br></p><p>(1) v-for比v-if的优先级高。</p><p>(2)不推荐同时使用，如果需要过滤用计算属性去计算返回数组。因此哪怕我们只渲染出一小部分数组的元素,也得在每次重渲染的时候遍历整个列表。</p><p><br></p><p><br></p><h3>12.说出至少4种Vue当中的指令和它的用法?</h3><p><br></p><p>(1) v-text: 渲染当前dom节点的纯文本内容</p><p>(2) v-html: 渲染当前dom节点的html内容</p><p>(3) v-pre: 用来跳过这个元素和它的子元素编译过程</p><p>(4) v-if、 v-else-if、v-else:控制dom的展示隐藏，如果是隐藏则不会生成该dom节点</p><p>(5) v-show: 通过css的display属性来控制dom的显示隐藏</p><p>(6) v-for: 遍历dom节点</p><p>(7) v-once: 只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视为静态内容跳过，这可以用于优化更新性能</p><p>(8) v-bind: 用来动态绑定属性，简写为:</p><p>(9) v-model: 用于在表单上创建双向数据绑定，他会忽略表单元素的value、checked、selected 的初始值</p><p>(10) v-on:</p><p>用来监听dom的事件</p><p><br></p><h3>13. Vue跟react的区别是什么?</h3><p><br></p><p>(1)数据流</p><p>A. Vue是双向，表单双向数据绑定</p><p>B. react是单向，表单使用onChange事件监听数据的变化</p><p>(2)模板</p><p>A. Vue是通过一种拓展的HTML语法进行渲染</p><p>B. react更倾向于原生js</p><p><br></p><h3>14. diff算法?</h3><p><br></p><p>(1)比较同层级虚拟dom .</p><p>(2)如果虛拟dom的key存在，并且选择器没有发生变化则不会重新生成虚拟dom，而是进行深层次比较</p><p>(3)在更新子节点的时候，会使用新节点和旧节点的头尾开始向中间开始比较。</p><p><br></p><p><br></p><h3>15. slot插槽、slot- -scope?</h3><p><br></p><p><br></p><pre><code class=\"language-html\">&lt;body&gt;\n&lt;div id=\" app\"&gt;\n    &lt;Test&gt;\n    &lt;div slot= ”default\" slot-scope=\" scope\"&gt;//作用域插槽的用法\n    (slot-scope)\n    {{ scope. msg }}\n    &lt;/div&gt;\n    &lt;!-- Vue2. 6.0取代了slot slot-scope的写法，但是v-slot只能写在template里--&gt;\n    &lt;template v-slot: header= \" scope\"&gt;//v-slot定义作用域插槽\n        &lt;div&gt;\n            &lt;h3&gt;slot&lt;/h3&gt;\n            &lt;p&gt; {{scope. msg}} &lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/Test&gt;\n&lt;/div&gt;\n    &lt;template id=\"test\"&gt;\n        &lt;div&gt;\n            &lt;slot name=\"default\" :msg=\"msg\"&gt;&lt;/slot&gt;\n            &lt;p&gt;这里是test组件&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/body&gt;\n</code></pre><p><br></p><p><br></p><h3>16. v-model实现方法?</h3><p><br></p><p>(1)向组件里面传一个value的参数</p><p>(2) 组件改变值的时候使用this. $emit(\'input\', 参数)去修改值</p><p><br></p><p><br></p><h3>17. mixin?</h3><p><br></p><p>(1)两个类似的组件，大部分逻辑相同，可以使用mixin混入的方法抽取公共的代码逻辑</p><p>(2) mixin 的生命周期钩子函数执行顺序要大于组件</p><p><br></p><p><br></p><h3>18.动态路由注册?</h3><p><br></p><p>(1)事先配置好路由、动态配置组件导航菜单</p><p><br></p><p>(2)动态获取指定文件夹下的路由文件</p><p><br></p><pre><code class=\"language-javascript\">const files = require. context (\n//其组件目录的相对路径\n\'.. /views\'\n//是否查询其子目录\ntrue,\n// 匹配基 础组件文件名的正则表达式\n/\\. Vue/\nfiles.keys().forEach(item =&gt; {\nlet name = item. split(\'/\')[2]. replace(\'.Vue\', \");\nitems. push({\npath:`/$ {name}`,\ncomponent: files(item).default\n})\n})\n</code></pre><p><br></p><p>(3)动态添加路由:addRoutes</p><p><br></p><h3>19. Vue为什么不建议使用索引作为key?</h3><p>对数组进行删除或新增的话，周围的数据渲染可能会出现问题且效率低下</p><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/07/16/1689514254540125.png\" alt=\"\" data-href=\"\" style=\"width: 328.00px;height: 217.51px;\"/></p><p><br></p><p>新增数据后：</p><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/07/16/1689514290057154.png\" alt=\"\" data-href=\"\" style=\"width: 334.00px;height: 285.14px;\"/></p><p>总结：</p><p>1.若对数据进行:逆序添加、逆序删除等破坏顺序操作:</p><p>会产生没有必要的真实DOM更新==&gt;界面效果没问题，但效率低。</p><p>2.如果结构中还包含输入类的DOM:</p><p>会产生错误DOM更新==&gt;界面有问题。</p><p><br></p><p><br></p><h3>20. Vue- router的钩子函数?</h3><p><br></p><p>(1)全局的路由钩子函数</p><p>A. beforeEach全局前置守卫</p><p>①每次每一个路由改变的时候都得执行一遍</p><p>②可进行一些页面跳转前处理，例如判断需要登录的页面进行拦截，做登录跳转!!</p><p>③参数</p><p>to: (Route 路由对象)即将要进入的目标路由对象to 对象下面的属性:</p><p>path params query hash fullPath matched name meta (在matched下，但是本例可以直接用)</p><p>from: (Route 路由对象)当前导航正要 离开的路由</p><p>next: (Function函数)一 定要调用该方法来resolve 这个钩子。调用方法:next(跳转地址或者空) ***必须 调用</p><p>B. afterEach:页 面加载之后</p><p>C.单个路由钩子函数: beforeEnter</p><p><br></p><pre><code class=\"language-javascript\">const router = new VueRouter({\nroutes:[\npath: \' /foo\',\ncomponent: Foo,\nbeforeEnter: (to， from， next) =&gt; {\n// ...\n}\n})</code></pre><p><br></p><p>D.组件内的路由钩子函数</p><p>①beforeRouteEnter</p><p>②beforeRouteLeave</p><p>③beforeRouteUpdate</p><pre><code class=\"language-javascript\">const Foo = {\ntemplate:\nbeforeRouteEnter (to, from, next) {\n// 在渲染该组 件的对应路由被confirm前调用\n//不!能!获取组件实例、 this\'\n//因为当钩子执行前，组件实例还没被创建\nbeforeRouteUpdate (to， from， next) {\n//在当前路由改变，但是该组件被复用时调用\n//举例来说，对于一个带有动态参数的路径/foo/:id, 在/foo/1 和\n/foo/2之间跳转的时候，\n//由于会渲染同样的Foo组件，因此组件实例会被复用。而这个钩子就\n会在这个情况下被调用。\n//可以访问组件实例、this\n},\nbeforeRouteLeave (to， from， next){\n//导航离开该组件的对应路由时调用\n. //可以访问组件实例`this`</code></pre><p><br></p><p><br></p><h3>21.如何需要动态给组件添加属性?</h3><p><br></p><pre><code class=\"language-javascript\">&lt;template&gt;\n&lt;!-- 这样就可以动态给a-button. 上添加type何shape属性了--&gt;\n&lt;a-button v-bind=\" options \"&gt;&lt;/a -button&gt;\n&lt;/ template&gt;\n&lt;script&gt;\nexport default {\ndata() {\nreturn {\noptions:\ntype:\' primary\',\nshape:\' circle\'\n}\n}\n&lt;/script&gt;</code></pre><h3>22.讲述一下:is的作用</h3><p style=\"text-align: start;\"><span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>:is</code></span> 是 Vue 提供的一个指令，用于动态地指定组件的标签名。</p><p style=\"text-align: start;\">通常情况下，在使用 Vue 组件时，需要使用该组件的标签名。例如，对于 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>my-component</code></span> 组件，可以在模板中直接使用 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>&lt;my-component&gt;&lt;/my-component&gt;</code></span> 来进行渲染。但是在某些情况下，我们希望可以根据不同的条件来动态地指定要渲染的组件标签名，这就可以使用 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>:is</code></span> 指令。</p><p style=\"text-align: start;\">使用方法如下：</p><ol><li style=\"text-align: start;\">在动态指定组件标签名的位置使用 is 属性和 :is 指令。例如：</li></ol><pre><code >&lt;component :is=\"componentName\"&gt;&lt;/component&gt; </code></pre><p style=\"text-align: start;\">这里的 componentName 可以是一个包含组件名称的变量或表达式。</p><ol><li style=\"text-align: start;\">在注册组件时，指定 name 选项。例如：</li></ol><pre><code >Vue.component(\'my-component\', { name: \'my-component\', // 其他选项 });</code></pre><p style=\"text-align: start;\"> name 选项即为该组件的名称，它将被用于表示该组件的标签名。</p><p style=\"text-align: start;\">使用 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>:is</code></span> 表达式时，还有一些需要注意的地方：</p><ul><li style=\"text-align: start;\"><span style=\"font-size: 16px;\">如果提供的 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>componentName</code></span><span style=\"font-size: 16px;\"> 为字符串，则应该使用双引号包裹。例如：</span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>:is=\"\'my-component\'\"</code></span><span style=\"font-size: 16px;\">；</span></li><li style=\"text-align: start;\"><span style=\"font-size: 16px;\">如果提供的 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>componentName</code></span><span style=\"font-size: 16px;\"> 为变量或表达式，则无需使用双引号包裹。例如：</span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>:is=\"currentComponentName\"</code></span><span style=\"font-size: 16px;\">；</span></li><li style=\"text-align: start;\"><span style=\"font-size: 16px;\">如果提供的 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>componentName</code></span><span style=\"font-size: 16px;\"> 为一个异步组件（通过 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>import()</code></span><span style=\"font-size: 16px;\"> 或 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>Vue.component()</code></span><span style=\"font-size: 16px;\"> 异步注册的组件），则必须使用 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>v-bind:is</code></span><span style=\"font-size: 16px;\"> 或缩写形式 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>:is</code></span><span style=\"font-size: 16px;\"> 来将其作为动态组件而不是静态字符串传递给 </span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>&lt;component&gt;</code></span><span style=\"font-size: 16px;\">。</span></li></ul><p style=\"text-align: start;\"><span style=\"font-size: 16px;\">总之，</span><span style=\"background-color: var(--color-neutral-muted); font-size: 16px;\"><code>:is</code></span><span style=\"font-size: 16px;\"> 的作用就是让你可以在某些情况下动态地指定组件标签名，从而实现更加灵活和自由的组件渲染方式。</span></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683101897799218.png', '码上VUE面试题', '码上vue面试题', '', 'vue,面试', 'VUE', '1', '2022-07-04 19:49:39', '2023-05-10 14:40:34', 'U', 1);
INSERT INTO `blog_essay` VALUES (36, '<h3> 1.你对HTML语义化的理解?</h3><p><br></p><p style=\"line-height: 2;\">语义化是指使用恰当语义的html标签，让页面具有良好的结构与含义，比如&lt;p&gt;标签就代表段落，&lt;article&gt; 代表正文内容等等。语义化的好处主要有两点:开发者友好:使用语义类标签增强了可读性，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。机器友好:带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，语义类还可以支持读屏软件，根据文章可以自动生成目录，这对于简书、知乎这种富文本类的应用很重要，语义化对于其网站的内容传播有很大的帮助。</p><p><br></p><p><br></p><h3>2.你对媒体查询的理解?</h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">媒体查询是CSS3的一项功能，可以根据设备的屏幕尺寸、宽度、高度、方向等条件来匹配样式。它可以使网站在不同大小的屏幕、不同分辨率的屏幕上呈现不同的布局和样式，从而提高响应式设计的体验和效果。通过媒体查询，我们可以设置不同的样式规则，让网页在不同情况下显示不同的样式，从而实现网页的响应式布局。常见的媒体查询规则包括@media、min-width、max-width等。</span></p><p><br></p><h3>3.盒模型的理解</h3><p><br></p><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">标准盒模型中，盒子的宽度只包含内容的宽度，不包括任何边框（border）、内边距（padding）或外边距（margin），这意味着如果我们设置一个元素的宽度为200px，那么该元素的内容区域宽度将为200px，而实际在网页中该元素的宽度将大于200px（因为还要加上边框、内边距和外边距）。</p><p style=\"text-align: start; line-height: 2;\">怪异盒模型中，元素的宽度包括内容宽度、内边距和边框宽度，但不包括外边距。这意味着如果我们设置一个元素的宽度为200px，那么在怪异盒模型中，该元素的宽度将是200px加上边框和内边距的宽度，而不是内容的宽度。这种盒模型在早期的浏览器中被广泛采用，但是现在已经很少使用了。</p><p style=\"text-align: start; line-height: 2;\">总的来说，标准盒模型更加符合直觉，也更容易计算和管理，而怪异盒模型因为历史原因而存在，使用起来需要特别小心。为了保证浏览器兼容性，我们可以使用box-sizing属性来控制盒子的模型，并建议使用标准盒模型（content-box）。</p><p><br></p><p><br></p><h3>4.解释下变量提升</h3><p><br></p><p style=\"line-height: 2;\">JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升(hoisting)。</p><p><br></p><p><br></p><h3>5.理解闭包吗?</h3><p><br></p><p>(1)闭包是什么</p><p style=\"line-height: 2;\">MDN的解释:闭包是函数和声明该函数的词法环境的组合。按照我的理 解就是:闭包=[函数」和「函数体内可访问的变量总和」举个简单的例子:</p><p><br></p><pre><code class=\"language-javascript\">(function() {\nvar a = 1; function add() {\nvarb=2\nvar sun = b + a console. log(sum); // 3\nadd ()\n})()\nvar sum =b + a console. log(sum); // 3\nadd ()\n})()</code></pre><p><br></p><p style=\"line-height: 2;\">add函数本身，以及其内部可访问的变量，即a=1，这两个组合在一起就被称为闭包，仅此而已。</p><p>(2)闭包的作用</p><p>闭包最大的作用就是隐藏变量，闭包的一大特性就是内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回(寿命终结)了之后。</p><p style=\"line-height: 2;\">基于此特性，JavaScript 可以实现私有变量、特权变量、储存变量等我们就以私有变量举例，私有变量的实现方法很多，有靠约定的(变量名前加_) ,有靠Proxy代理的，也有靠Symbol这种新数据类型的。但是真正广泛流行的其实是使用闭包。</p><h3>6.变量提升</h3><p style=\"line-height: 2;\">JavaScript属于静态作用域，即声明的作用域是根据程序正文在编译时就确定的，有时也称为词法作用域。</p><p style=\"line-height: 2;\">其本质是JavaScript在执行过程中会创造可执行上下文，可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了作用域链。</p><p><br></p><p><br></p><h3>7. ES6 Module和CommonJS模块的区别</h3><p><br></p><p>ES6 Module 和CommonJS模块的区别:</p><p style=\"line-height: 2;\">CommonJS是对模块的浅拷贝，ES6 Module 是对模块的引用,即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似constimport的接口是read-only (只读状态)，不能修改其变量值。即不能修改其变量的指针指向，但可以改变变量内部指针指向,可以对commonJS对重新赋值(改变指针指向)，但是对ES6 Module赋值会编译报错。</p><p>ES6 Module 和CommonJS模块的共同点:</p><p style=\"line-height: 2;\">CommonJS和ES6 Module 都可以对引入的对象进行赋值，即对对象内部属性的值进行改变。</p><p><br></p><p><br></p><h3>8.谈一谈你对this的了解</h3><p><br></p><p style=\"line-height: 2;\">this的指向不是在编写时确定的，而是在执行时确定的，同时，this不同的指向在于遵循了一定的规则。</p><p style=\"line-height: 2;\">首先，在默认情况下，this 是指向全局对象的，比如在浏览器就是指向wi ndow。箭头函数的this指向哪里。.</p><p><br></p><p><br></p><h3>9. async/await是什么?</h3><p><br></p><p>async</p><p style=\"line-height: 2;\">函数，就是Generator函数的语法糖，它是建立在Promises上，并且与所有现有的基于Promise的API兼容。</p><p>(1) Async- 声明一个异步函数(async function someName() {...})</p><p>(2)自动将常规函数转换成Promise, 返回值也是一-个Promise对象</p><p style=\"line-height: 2;\">(3)只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</p><p>异步函数内部可以使用await</p><p>(1) Await- 暂停异步的功能执行(var result = await someAsyncCall);) </p><p>(2)放置在Promise调用之前，await强制其他代码等待，直到Promise完成并返回结果</p><p>(3)只能与Promise- 起使用，不适用与回调</p><p>(4)只能在async函数内部使用</p><p><br></p><p><br></p><h3>10. async/await相比于Promise的优势?</h3><p><br></p><p style=\"line-height: 2;\">代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担Promise 传递中间值非常麻烦,而async/ await几乎是同步的写法,非常优雅错误处理友好,async/await可以用成熟的try/catch,Promise的错误捕获非常冗余调试友好，Promise的调试很差,由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个. then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的. then代码块，因为调试器只能跟踪同步代码的「每一步」。</p><p><br></p><p><br></p><h3>11. HTTP有哪些方法?</h3><p><br></p><p style=\"line-height: 2;\">HTTP1.0定义了三种请求方法: GET, POST 和HEAD方法; HTTP1.1新增了五种请求方法: OPTIONS，PUT，DELETE, TRACE 和ONNECT</p><p>(1) GET:通常用于请求服务器发送某些资源</p><p style=\"line-height: 2;\">(2) HEAD:请求资源的头部信息，并且这些头部与HTTPGET 方法请求时返回的一致;该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载,以此可以节约带宽资源</p><p>(3) OPTIONS:用于 获取目的资源所支持的通信选项</p><p>(4) POST: 发送数据给服务器</p><p style=\"line-height: 2;\">(5) PUT:用于新增资源或者使用请求中的有效负载替换目标资源的表现形式</p><p>(6) DELETE:用于删除指定的资源</p><p style=\"line-height: 2;\">(7) PATCH:用于对资源进行部分修改</p><p style=\"line-height: 2;\">(8) CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p><p style=\"line-height: 2;\">(9) TRACE:回显服务器收到的请求，主要用于测试或诊断</p><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">12. HTTP的状态码有哪些?</h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\">2XX成功</p><p style=\"line-height: 2;\">(1) 200 0K，表示从客户端发来的请求在服务器端被正确处理.</p><p style=\"line-height: 2;\">(2) 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立</p><p style=\"line-height: 2;\">(3) 202 Accepted 请求已接受，但是还没执行，不保证完成请求</p><p style=\"line-height: 2;\">(4) 204 No content, 表示请求成功，但响应报文不含实体的主体部分</p><p style=\"line-height: 2;\">(5) 206Partial Content， 进行范围请求</p><p style=\"line-height: 2;\">3XX重定向</p><p style=\"line-height: 2;\">(1) 301 moved permanently,永久性重定向，表示资源已被分配了新的URL</p><p style=\"line-height: 2;\">(2) 302 found, 临时性重定向，表示资源临时被分配了新的URL</p><p style=\"line-height: 2;\">(3) 303 see other,表示资源存在着另一个URL， 应使用GET方法丁香获取资源</p><p style=\"line-height: 2;\">(4) 304 notmodified, 表示服务器允许访问资源，但因发送请求未满足条件的情况</p><p style=\"line-height: 2;\">(5) 307 temporary redirect,临时重定向，和302含义相同</p><p style=\"line-height: 2;\">4XX客户端错误</p><p style=\"line-height: 2;\">(1) 400 bad request， 请求报文存在语法错误</p><p style=\"line-height: 2;\">(2) 401 unauthorized, 表示发送的请求需要有通过HTTP 认证的认证信息</p><p style=\"line-height: 2;\">(3) 403 forbidden， 表示对请求资源的访问被服务器拒绝</p><p style=\"line-height: 2;\">(4) 404 not found, 表示在服务器.上没有找到请求的资源</p><p style=\"line-height: 2;\">(5) 408 Request timeout, 客户端请求超时</p><p style=\"line-height: 2;\">(6) 409 Confict， 请求的资源可能引起冲突</p><p style=\"line-height: 2;\">5XX服务器错误</p><p style=\"line-height: 2;\">(1) 500 internal sever error， 表示服务器端在执行请求时发生了错误</p><p style=\"line-height: 2;\">(2) 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法</p><p style=\"line-height: 2;\">(2) 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p><p style=\"line-height: 2;\">(3) 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的HTTP版本</p><p><br></p><p><br></p><h3>13.为什么有了HTTP为什么还要HTTPS?</h3><p><br></p><p style=\"line-height: 2;\">https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS 就是为了解决HTTP的不安全而生的。</p><h3 style=\"line-height: 2;\">14.Vue生命周期的理解.</h3><p><br></p><p style=\"line-height: 2;\">Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt;渲染、更新-&gt;渲染、卸载等一系列过程，我们称这是Vue的生命周期。</p><p style=\"line-height: 2;\"><br></p><h3>15.http和https的区别？</h3><p><br></p><p style=\"text-align: start;\">HTTP和HTTPS都是传输协议，它们的主要区别在于安全性和加密机制不同。</p><p style=\"text-align: start;\">HTTP (超文本传输协议)是一种非加密的协议，它在传输数据时不做任何加密处理，容易被黑客截获并窃取数据。HTTP连接是无状态的，无法对请求进行持久化，每个请求和响应之间都是独立的。</p><p style=\"text-align: start;\">HTTPS (超文本传输安全协议)是HTTP的加密版，它利用SSL (安全套接字层)或TLS (传输层安全)协议对数据进行加密，保证了连接的安全性。HTTPS连接也是有状态的，可以对请求进行持久化，提高了传输效率，因此，现在许多网站都采用HTTPS协议。</p><p style=\"text-align: start;\">总的来说，HTTPS比HTTP更加安全可靠，能够保护用户的隐私和安全。建议网站采用HTTPS协议，提高信息传输的安全级别。</p><p style=\"text-align: start;\"><br></p><h3>16.函数的上下文？</h3><p><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">在JavaScript中，函数的上下文（也称作执行上下文）指的是函数执行时的环境。它包括了函数被调用时创建的一组数据结构，这个数据结构包含了函数内部的变量、参数、函数声明等信息。一个执行上下文会在函数被调用时创建，并保持存在直到函数执行完毕。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">在执行上下文中，包含了三种不同类型的执行上下文：</span></p><ol><li style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">全局执行上下文：在程序启动时创建，当程序退出时销毁。</span></li><li style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">函数执行上下文：在函数被调用时创建，函数执行完毕时销毁。</span></li><li style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">Eval函数执行上下文：由</span><span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px;\"><code>eval()</code></span><span style=\"font-size: 16px;\">函数创建，在</span><span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px;\"><code>eval()</code></span><span style=\"font-size: 16px;\">函数执行完毕时销毁。</span></li></ol><p style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">执行上下文包含了一个作用域链，作用域链是一个列表结构，包含了函数内部和外部的变量、参数和函数声明。当函数从内部获取变量时，它会首先查找自己的执行上下文中的作用域链，如果找不到，则会继续查找外部执行上下文中的作用域链，直到找到为止。</span></p><p style=\"text-align: start; line-height: 2;\"><span style=\"font-size: 16px;\">在函数闭包中，函数的上下文不会被销毁。这意味着，闭包内的变量、参数和函数声明在函数执行完毕后仍然存在，并且可以被调用。</span></p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">17.谈谈iframe？</h3><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\"><span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>iframe</code></span>（即内联框架）是 HTML 标签之一，可以在一个页面中展示另一个单独的 HTML 网页。通俗的理解，<span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>iframe</code></span> 就是把一个网页嵌套到另一个网页里面的容器。</p><p style=\"text-align: start;\"><span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>iframe</code></span> 的主要作用包括以下两个方面：</p><ol><li style=\"text-align: start;\">实现页面内容的嵌入：网站中广告常常采用 iframe 技术实现不同场景下的灵活呈现。</li><li style=\"text-align: start; line-height: 2;\">解决浏览器兼容性问题：随着 HTML5 技术的普及，浏览器对标签的支持越来越统一和完善，但如果需要兼顾老版本的浏览，还是需要使用 iframe 对不支持标签的浏览器进行兼容处理。</li></ol><p style=\"text-align: start;\">以下是一个简单的 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>iframe</code></span> 使用示例：</p><pre style=\"text-align: start;\"><code class=\"language-hljs code\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Example&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;h1&gt;父页面（Parent Page）&lt;/h1&gt;\n  &lt;iframe src=\"child.html\" frameborder=\"0\"&gt;&lt;/iframe&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre><p style=\"text-align: start; line-height: 2;\">上述代码定义了一个父页面，在其中使用 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>&lt;iframe&gt;</code></span> 标签将子页面 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>child.html</code></span> 嵌入进来。通过设置 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>src</code></span> 属性指定要嵌入的目标页面地址，通过 <span style=\"background-color: var(--color-neutral-muted); font-size: 12px;\"><code>frameborder</code></span> 属性可以设置内嵌页面的边框是否显示。</p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">18<span style=\"font-size: 16px;\">.</span><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-size: 19px;\">attribute 和 property 的区别是什么?</span></h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">在 HTML 中，attribute 和 property 都用于描述 HTML 元素。其中，attribute 是指 HTML 标签上的属性，而 property 则是指 JavaScript 对象上的属性。</p><p style=\"text-align: start; line-height: 2;\">其主要区别在于，attribute 描述的是 HTML 元素在文档树上呈现的初始值，而 property 描述的则是当前 DOM 节点所代表的元素的状态。</p><p style=\"text-align: start; line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">19、vue和jQuery的区别</h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\">jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(\"lable\").val();,它还是依赖DOM元素的值。</p><p style=\"line-height: 2;\">Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\"><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255);\">20、delete和Vue.delete删除数组的区别</span></h3><p><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete 直接删除了数组 改变了数组的键值。</span></p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\"><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255);\">21、</span><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">原型链可以具体运用在哪些地方上</span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><br></span></h3><p style=\"text-align: start; line-height: 2;\">原型链是JavaScript语言的一项核心特性，它允许对象继承属性和方法，也可以通过修改原型实现对特定对象类型的扩展。下面是一些原型链具体应用的例子：</p><p style=\"text-align: start; line-height: 2;\">类型扩展：可以通过修改内置对象的原型来添加自定义属性和方法，比如给数组添加一个自定义方法。</p><p style=\"text-align: start; line-height: 2;\">继承实现：可以使用原型链来实现继承，创建一个对象作为另一个对象的原型，从而使它们之间共享属性和方法。</p><p style=\"text-align: start; line-height: 2;\">模块封装：可以使用原型链来实现模块封装，将需要封装的元素封装在一个对象中，通过访问该对象上的属性和方法来使用它们。</p><p style=\"text-align: start; line-height: 2;\">原型式编程：可以使用原型链来进行原型式编程，即创建一个对象作为另一个对象的原型（通常是一个空对象），并通过给它添加属性和方法来创建新的对象。</p><p style=\"text-align: start; line-height: 2;\">总之，原型链是JavaScript中很重要的一部分，可以应用在许多领域，包括设计模式和框架，以提高代码的可重用性和可扩展性。</p><p><br></p><p><br></p><h3>node.js面试题</h3><p><br></p><p> <a href=\"https://blog.csdn.net/pengxian00007/article/details/118731719?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168337312616800227494188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168337312616800227494188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118731719-null-null.142^v86^koosearch_v1,239^v2^insert_chatgpt&utm_term=node%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187\" target=\"_blank\">基础面试题</a> </p><p><br></p><h3>express面试题</h3><p><br></p><p> <a href=\"https://blog.csdn.net/qq_45272615/article/details/120937958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168499287816800213035540%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168499287816800213035540&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120937958-null-null.142^v87^insert_down28v1,239^v2^insert_chatgpt&utm_term=express%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187\" target=\"_blank\">csdn</a> </p><h3></h3><h3>jQuery面试题</h3><p><br></p><p><a href=\"https://blog.csdn.net/z321616764/article/details/106674243?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168595050716800182761180%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168595050716800182761180&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106674243-null-null.142^v88^koosearch_v1,239^v2^insert_chatgpt&utm_term=jquery%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187\" target=\"_blank\">jquery面试题</a> </p><h3></h3><h3>微信小程序面试题</h3><p><br></p><p><a href=\"https://blog.csdn.net/m0_67390963/article/details/125402336?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168595065516800188510121%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168595065516800188510121&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125402336-null-null.142^v88^koosearch_v1,239^v2^insert_chatgpt&utm_term=%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187\" target=\"_blank\">微信小程序面试</a> </p><p><br></p><p><br></p><h3>全面复习</h3><p><br></p><p> <a href=\"https://blog.csdn.net/sun_qqq/article/details/128944976?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168500383516800217225197%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168500383516800217225197&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128944976-null-null.142^v88^koosearch_v1,239^v2^insert_chatgpt&utm_term=%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187\" target=\"_blank\">csdn前端面试</a> </p><p><br></p><h3>手写代码面试题</h3><p><br></p><p><a href=\"https://blog.csdn.net/qq_38140936/article/details/126866599?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-126866599.nonecase&spm=1018.2226.3001.4187\" target=\"_blank\">手写代码实现一些函数</a> </p><p><br></p><p><br></p>', '/public/uploads/2023/05/03/1683101897832917.png', '码上前端面试（其他）', '码上前端前面||一些其他需要了解的面试知识', '', '其他,面试', '其他', '1', '2022-07-04 19:49:39', '2023-05-06 19:41:33', 'U', 1);
INSERT INTO `blog_essay` VALUES (37, '<p style=\"line-height: 2;\"><br></p><p><br></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">题目：如何走好中国式现代化道路</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">学院：计算机与网络空间安全学院</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">专业：软件工程</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">学号：116052020052</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">姓名：谢林昌</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">摘要：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">本文以现代化到中国式现代化的理解进行阐述，层层递进，讲述为什么要走中国式现代化这条路，以及现在的青少年身处于中国式现代化的路线中如何理解这条道路并走好，续写激荡人心的东方传奇。</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">关键词：青少年，中国式现代化，实践，可持续发展，</span></p><p><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">正文：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">现代化是一个包括经济、政治、文化、社会、科技等在内的综合发展进程，是人类文明发展与进步的显著标志。在现代化中，重点关注的是对经济、文化和社会变革推进的综合推动策略。现代化极大地提高了人们的生活质量、减轻了人们的工作负担，具有极其重要的实践意义。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">中国式现代化具体来讲，包括经济、政治、文化等各个领域的现代化，相互联系及相互输入。但基础在于发展实体经济，不断扩大中产阶层，推进城市化与工业化，形成完整的中等收入群体，增加消费需求。1840 年鸦片战争以后，中国逐步成为半殖民地半封建社会，国家蒙辱、人民蒙难、文明蒙尘，中华民族遭受了前所未有的劫难。从那时起，实现中华民族伟大复兴,就成为中国人民和中华民族最伟大的梦想。为了拯救民族危亡,中国人民奋起反抗,仁人志士奔走呐喊，太平天国运动、戊戌变法、义和团运动、辛亥革命接连而起，各种救国方案轮番出合,但都以败而告终。而中国产生了共产党，则开天辟地的大事变, 100 多年来,中国共产党团结带领中国人民进行的- -切奋斗、- -切辆牲、- -切创造，就是为了把我国建设成为现代化强国，实现中华民族伟大复兴。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">首先产生了人口规模巨大的现代化,现代化的本质是人的现代化。实现“人口规模巨大的现代化\"，必须坚特人民至.上的价值理念，让现代化建设成果更多更公平惠及全体人民。新时代这10 年，更好的教育改变着无数人的命运，更稳定的工作托举起更多精彩的人生,更满意的收人充实了普通家庭的物质基础，可靠的社会保障为亿万人民的生活兜底,更高水平的医疗卫生服务护佑着人们身体健康...一个个突破性进展，-项项标志性成果,始终把实现好、维护好、发展好最广大人民根不利益作为- -切工作的出发点和落脚点。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">其次也实现了物质文明和精神文明相协调的现代化,物质富足、精神富有是社会主义现代化的根本要求。在现代化进程中，“两个文明”犹如车之两轮、鸟之两翼，只有二者相辅相成、协同发力,才能推动社会整体跃升、行稳致远。改革开放以来,我们完在推动经济快速发展的同时，大力加强社会主义精神文明建设,促进社会主义先进文化繁荣发展,使社会文明程度提高、人民精神力量不断增强。浩渺行无极，扬帆但信风。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">可以说，建设中国特色社会主义、实现中华民族伟大复兴的历史任务，就是要持续推进中国式现代化的进程。并非仅仅是快速地经济增长，而是从全方位、系统性、战略性、总体性方面对我国的先进性进行加强，以及回应世界现代文明发展趋势所要求的改革进程。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">中国式现代化具有自己独特的内涵和路径，因此，青少年需要掌握相关的知识和理论。从学校教育开始，我们应该对中国的历史和文化有更深入的了解，深化对中国式现代化的认识和理解。同时，在日常生活中积极关注国家政策和发展方向，掌握时事动态和国内外新闻信息。这不仅可以提高我们的思想觉悟，更有助于积极参与中国式现代化进程中去。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">理论知识只是中国式现代化的一部分，更重要的是将其转化为实际行动。青少年应该积极参与到社会实践和公益活动中去，提升个人素质和能力。例如，发挥自己的特长和优势，加入创新团队或者志愿服务组织，尝试解决社会问题和满足人民需求。通过实践，不仅能够推动中国式现代化的进程，还可以锤炼我们的责任心、创新能力和领导才能。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">在中国式现代化的过程中，环境保护和生态文明建设同样重要。作为青少年，我们应该具有绿色发展、低碳经济和生态文明建设等理念，为可持续发展贡献自己的力量。例如，我们可以从日常生活中入手，节约资源、减少浪费，同时促进环保产业发展，支持传统产业的绿色转型。在城市化和工业化的进程中，我们也可以通过科技创新、发展智能制造等方式，推动中国式现代化的进一步发展。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">作为青少年，我们应该从自己做起，通过多种形式积极投身于中国式现代化的实践当中。首先，我们应该树立远大的理想和抱负，在追求个人成功的同时，也要为国家和社会的发展做出自己的贡献。其次，我们应该注重提高自身素质和能力，不断学习新知识、掌握新技能，并积极参与各种实践活动和社会公益事业。特别是在科技创新领域，青少年可以结合自己的兴趣和优势，参与到各类创新竞赛和项目当中。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">此外，青少年还应该倡导可持续发展的理念，积极参与环境保护和生态文明建设。中国式现代化不能以牺牲环境和生态为代价，我们必须坚持绿色发展、低碳经济和可持续发展的道路，并为此奋斗终身。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">最后，作为青少年，我们还应该增强家国情怀，锤炼爱国精神。爱国主义是中华民族的传统美德，也是中国式现代化进程中不可缺少的因素。我们应该热爱祖国，尊崇国家法律和制度，勇于维护国家利益和民族尊严。</span></p><p><span style=\"color: rgb(38, 38, 38); font-family: 宋体;\">在中国式现代化的征程中，青少年扮演着至关重要的角色。我们应该坚定信念、勇于担当，为实现中国式现代化梦想而努力奋斗，成为当之无愧的时代新人。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">今天，我们比历史上任何时期都更按近、更有信心和能力实现中华民族伟大复兴的目标,同时必须准备付出更为艰巨、更为艰苦的努力。新时代新征程,全国人民在党的旗帜下团结成“-块坚硬的钢铁”，心往一处想、 劲往一处使，矢志不渝沿着中国式现代化这条光明大道走下去,必将续写激荡人心的东方传奇,赢得令人惊叹的大国荣光。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">注释：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">本文所使用的相关材料和观点来源于以下参考文献。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">参考文献：</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">《时事报告大学生版》2021-2022学年度下学期，中共中央宣传部时事报告杂志社</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">王宏志、陈洁：《关于中国式现代化的理论思考》，人文社科出版社，2019年。</span></p><p style=\"text-indent: 21pt;\"><span style=\"color: rgb(38, 38, 38); background-color: rgb(255, 255, 255); font-family: 宋体;\">刘建军：《中国特色社会主义形成与中国式现代化的探索历程》，江苏人民出版社，2020年。</span></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/05/04/1683185517288513.jpg', '形势与政策小论文', '期末大作业', '', '形势与政策', '其他', '1', '2022-07-04 19:49:39', '2023-05-04 19:42:15', 'I', 2);
INSERT INTO `blog_essay` VALUES (39, '<p><br></p><p style=\"text-align: start;\">Vue 是一个流行的前端 JavaScript 框架，通过提供组件化开发、响应式数据绑定等特性使得构建单页应用变得更加容易。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">而 uni-app 是一款基于 Vue.js 的多端应用开发框架，它能够以同一份代码创建同时运行在多个平台（包含 H5、小程序、App 等）的应用程序。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">下面是 Vue 和 uni-app 在使用上的区别：</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">语言支持 Vue 支持在浏览器端、Node.js 环境、Weex 运行环境等各种场景下使用。uni-app 则主要面向移动端和 Web 端多端应用需求，适用范围相对较狭窄。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">UI 组件库 Vue 没有自带的 UI 组件库，需要开发者根据需要选择使用第三方的 UI 库，并结合 Vue 进行开发。uni-app 集成了常见的 UI 组件库，如 uniui、uview 等，能够快速开发出精美的界面。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">生命周期 Vue 和 uni-app 的生命周期是不完全一致的，uni-app 多了一些 App 生命钩子，例如 onLaunch、onShow、onError 等，这些生命周期钩子只有在启动足够早才会触发。在使用 uni-app 时，需要注意这些钩子函数与 Vue 生命周期的差异性。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">文件结构 Vue 将组件、样式、模板分离成不同的文件，它们之间通过 import 引入。而 uni-app 则采用一种类似于在一个文件中同时编写 HTML、JavaScript、CSS 的方式，即 SFC (Single File Component) 模式进行开发。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">因此，虽然 Vue 和 uni-app 均基于 Vue.js，并且都具有很强的跨平台能力，但它们在文件结构、语言支持和生命周期等方面略有差异，开发者需要根据具体需求选择适合自己的框架。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\"><br></p>', '/public/uploads/2023/05/28/1685249894923744.jpeg', 'vue和uni-app的区别', 'vue和uni-app的区别', '', 'uni-app', '其他', '1', '2023-05-28 12:58:15', '2023-05-28 12:58:15', 'I', 1);
INSERT INTO `blog_essay` VALUES (48, '<h2>一、单项选择题</h2><p>1. 最早提出ERP概念的咨询公司在（ C ）。</p><p>A.英国 B.中国 C.美国ff</p><p><br></p><p>2.时段MRP是在（B ）学说的基础上形成的。</p><p>A.物料需求 一天今天第一B.物料独立需求和相关需求</p><p>C.物料独立需求 D.物料相关需求</p><p><br></p><p>3. MRPⅡ与MRP的主要区别就是它运用了（ C ）的概念。</p><p>A.会计 B.成本会计 C.管理会计 D.财务管理</p><p><br></p><p>4.业务流程重组是以作业流程为一天回家一趟中心、打破传统的金字塔形组织结构向平板形发展，即所谓的（ B ）结构管理。</p><p>A.垂直化 B.扁平化 C.职能化 D.流程化</p><p><br></p><p>5. 闭环MRP在时段MRP基础上添加了（D ）。</p><p>A.库存需求计划 B.生产计划</p><p>C.采购需求计划 太阳花一天 D.能力需求计划</p><p><br></p><p>6.下列选项中不属于ERP系统基本组成部分的是（ A ）。</p><p>A.工作流 B.财务管理</p><p>C.生产计划 D.物流管理</p><p><br></p><p>7. ERP思想的倡导者是( C ) 。</p><p>A.Oracle公司 B.BAAN公司 C.SAP公司 D.用友公司</p><p><br></p><p>8.一般来说，在生产型制造企一体化业的各项支出对利润的影响中，影响最大的是（ B ）。</p><p>A.销售成本 B.采购成本</p><p>C.存货成本 D.生产成本</p><p><br></p><p>9.ERP系统中的主业务流程包括（ D ）模块。</p><p>I.物流管理 II.财务管理 后天然后他III.生产管理 IV.库存管理 V.采购管理</p><p>A.II、III、IV B.I、II如果还让他好过、IV</p><p>C.I、II、V D.I、II、III</p><p><br></p><p>10.在易飞ERP系统中，记录企业向供应商询价结果的单据是（ B ）。</p><p>A.报价单 B.询价单 C.请购单 D.采购单</p><p><br></p><p>11. ERP系统的四个全景分别对应（ C ）四种管理。</p><p>A.供应链管理、库存管理、生产管理、财务管理</p><p>B.库存管理、销售管理、采购管理、生产管理</p><p>C.供应链管理、客户关系管理、产品生命周期管理和知识管理</p><p>D.客户关系管理、供应商关系管理、内部人员管理、财务管理</p><p><br></p><p>12.在易飞ERP系统中，属于售前服务阶段信息，记录了对客户的报价信息的是（B ）模块。</p><p>A.录入销货单 B.录入报价单 C.录入销售预测 D.录入客户订单</p><p><br></p><p>13.供应商在接到询价单后提供给企业的包含物料供应价格、技术性能特点等信息的单据是（ B ）。</p><p>A.采购订单 B.报价单</p><p>C.请购单 D.询价单</p><p><br></p><p>14.定量库存控制模型要确定的量是（ A）。</p><p>A.订货点和订货批量 B.订货点和订货周期</p><p>C.订货周期和订货批量 D.以上都不对</p><p><br></p><p>15. ERP系统中的采购可以实现（ C ）采购。</p><p>A.订货点采购 B.电子商务采购</p><p>C.MRP采购 D.供应链采购</p><p><br></p><p>16.在易飞ERP系统的存货管理子系统中，生产完工时，生产入库单记录产成品入仓库的信息，同时存货管理子系统的产品库存（B ）。</p><p>A.减少 B.增加 C.不变化 D.条件不足，不能判断。</p><p><br></p><p>17.按照订货点法管理的物料的采购需求经常是通过（C ）的形式表现出来。</p><p>A.MRP B.报价单</p><p>C.请购单 D.采购订单</p><p><br></p><p>18.企业最基本的生产特征是（C ）。</p><p>A.按库存生产和按订单装配 B.按订单装配和按订单设计</p><p>C.按库存生产和按订单生产 D.按订单生产和按订单设计</p><p><br></p><p>19. 在ERP系统中，供应商管理模块一般包括（ D ）内容。</p><p>A.供应商评价 B.供应商信息</p><p>C.供应商选择 D.以上选项都包括</p><p><br></p><p>20.下列选项中既是企业的总体目标又是制定各层计划依据的是（A ）。</p><p>A.战略规划 B.经营计划 C.主生产计划 D.能力需求计划</p><p><br></p><p>21. 易飞ERP系统中若启用“出货通知管理”，则销货流程是（ C ）。</p><p>A.客户订单→出货通知单→销货单</p><p>B.订单预计出货表→客户订单→销货单</p><p>C.订单预计出货表→出货通知单→销货单</p><p>D.销货单→出货通知单→订单预计出货表</p><p><br></p><p>22.在展开MPS进行物料需求计算时，计算的顺序是（ C ）进行的。</p><p>A.从左到右 B.从右到左 C.从上而下 D.从下往上</p><p><br></p><p>23. 在易飞ERP系统中，询价后，企业决定从其中一家或几家供应商订货，需要录入（ A ）。</p><p>A.请购单 B.询价单 C.报价单 D.采购单</p><p><br></p><p>24.直接材料和直接人工的成本总和被称成为（ D ）。</p><p>A.标准成本 B.直接成本</p><p>C.基本成本 D.主要成本</p><p><br></p><p>25. 定时库存控制模型中的每次订货批量是 （ A）变化。</p><p>A.随着自上次订货以来物品的使用率的变化而 B.随着订货周期发生</p><p>C.随着订货点发生 D.保持固定不变</p><p><br></p><p>26. 易飞ERP系统的会计总账子系统中，整批过账的会计凭证是从（ A ）子系统抛转过来的。</p><p>A.自动分录子系统 B.成本核算子系统</p><p>C.票据资金子系统 D.应收/付子系统</p><p><br></p><p>27.定量库存控制模型和定时库存控制模型最大的差别是 （ C）的变化。</p><p>A.订货点 B.订货成本</p><p>C.订货批量 D.订货周期</p><p><br></p><p>28.易飞系统中，成本核算模块是在（ C ）系统中的，而不是在财务模块中，这是区别以制造为中心的ERP软件还是以财务为中心的ERP软件的标准。</p><p>A.主生产排程 B.销售管理</p><p>C.生产管理 D.库存管理</p><p><br></p><p>29.定期盘点是固定（ B ）系统，其安全库存是用来防止在检查期和提前期内需求量的波动。</p><p>A.周期 B.批量 C.订货点 D.采购成本</p><p><br></p><p>30. BPR中简化流程的理论基础是（B ）。</p><p>A.系统集成类规则 B.可靠性类规则</p><p>C.并行性类规则 D.组织再造类规则</p><p><br></p><p>31. 在易飞ERP系统的存货管理子系统中，录入的领料单记录从存货管理子系统的领料情况，同时存货管理子系统的原材料库存（A ）。</p><p>A.减少 B.增加 C.变化 D.条件不足，不能判断。</p><p><br></p><p>32. 在易飞ERP系统的主生产排程子系统中，（ D ）模块是决定MPS的运行依据。</p><p>A.生成采购计划模块 B.录入每日资源信息模块</p><p>C.生成排程计划模块 D.录入排程来源模块</p><p><br></p><p>33. 产品结构子系统通过（ D ）与采购管理子系统实现信息关联。</p><p>A.采购单 B.询价单 C.订单 D.请购单</p><p><br></p><p>34. 与需求计划子系统相关联的信息中不属于生产管理系统的是（A ）。</p><p>A.采购单/请购单 B.工单信息</p><p>C.BOM用量 D.产品工艺路线</p><p><br></p><p>35.产品结构说明了每个物料在产品层次中相互之间的（ C ）关系。</p><p>A.从属 B.数量</p><p>C.从属关系和数量 D.结构</p><p><br></p><p>36.在现货生产的方式中，MPS计划对象是产品结构中的（ C ）。</p><p>A.1层 B.2层 C.顶层 D.最低层</p><p><br></p><p>37. ERP系统的计划真正运行是从（ B ）开始的。</p><p>A.经营计划 B.车间作业控制</p><p>C.物料需求计划 D.主生产计划</p><p><br></p><p>38．会计核算的核心部分是（ B ）。</p><p>A. 票据管理 B. 总账管理</p><p>C. 应收/付管理 D. 固定资产管理</p><p><br></p><p>39. ERP中财务会计的基础是（A ）。</p><p>A.管理会计 B.财务会计</p><p>C.应收/付管理 D.总帐管理</p><p><br></p><p>40.各部门折旧费用数据从（D ）子系统获取。</p><p>A.生产管理 B.自动分录</p><p>C.成本计算 D.设备资产</p><p><br></p><p>41. 各部门折旧费用数据是从（ C ）子系统获取。</p><p>A.生产管理 B.成本计算</p><p>C.设备资产 D.自动分录</p><p><br></p><p>42．ERP系统中的损益表主要用以显示（ B ）。</p><p>A.企业经营情况 B.企业营运获利能力</p><p>C.企业盈余变动 D.资金流动情况</p><p><br></p><p>43. 结账单是会计子系统中（D ）模块的单据。</p><p>A.采购管理 B.销售管理</p><p>C.应付管理 D.应收管理</p><p><br></p><p>44. 面向模块的实施战略适用于（ A ）。</p><p>A.各部门较独立的大企业 B.部门界限不太清晰的小型企业</p><p>C.业务流程不是特别复杂的中小企业 D.有一定计算机技术运行基础的企业</p><p><br></p><p>45. ERP系统实施战略中最常使用的方法是（ B ）。</p><p>A.面向流程的实施战略 B.面向模块的实施战略</p><p>C.Big Bang实施战略 D.面向对象的实施战略</p><p><br></p><h2>二、填空题</h2><p><br></p><p>1. ERP的实质是在1.<span style=\"color: rgb(225, 60, 57);\"> MRPII</span> 基础上进一步发展而成的、面向<span style=\"color: rgb(225, 60, 57);\">供应链</span>的管理思想。</p><p>2. ERP的基本思想是2.<span style=\"color: rgb(225, 60, 57); background-color: rgb(255, 255, 255);\"> 计划与控制</span> 。</p><p>3. ERP是建立在3. &nbsp;<span style=\"color: rgb(225, 60, 57);\">信息技术</span> 基础上的，整合了企业管理理念、业务流程、基础数据、人力物力、计算机硬件和软件于一体的企业资源管理系统，以实现对3.<span style=\"color: rgb(225, 60, 57);\">企业物流、资金流、信息流</span>的一体化管理。</p><p>4. PDM是 4.<span style=\"color: rgb(207, 19, 34);\"> 产品数据管理</span> 的英文缩写。</p><p>5. 为了避免缺货和积压货物问题的发生而提出的一种控制库存的方法是5.<span style=\"color: rgb(207, 19, 34);\">订货点法</span>。</p><p>6. 在ERP系统中，供应商管理模块一般包括三方面内容：供应商信息、6.<span style=\"color: rgb(207, 19, 34);\">供应商评价</span> 和供应商选择。</p><p>7. ERP从本质上讲就是对企业资源的 7.<span style=\"color: rgb(207, 19, 34);\"> 计划和优化</span> 过程。</p><p>8. 易飞ERP系统中若启用“出货通知管理”则销货流程是：订单预计出货表→出货通知单→8.<span style=\"color: rgb(225, 60, 57);\"> 销货单</span>。</p><p>9. ERP中采购管理业务流程的物流传递是 9.<span style=\"color: rgb(207, 19, 34);\"> 原材料</span> 从供应商流向仓库。</p><p>10. 物料需求计划系统最后输出MRP采购单和 10.<span style=\"color: rgb(207, 19, 34);\"> MRP工单</span> 。</p><p>11. 采购计划中的物料有两个不同的来源，MRP和 11.<span style=\"color: rgb(207, 19, 34);\"> 请购单</span> 。</p><p>12. 产品结构子系统的 12.<span style=\"color: rgb(207, 19, 34);\"> 产品工艺路线信息</span> 是从产品工艺自动生成工单工艺模块的基础数据。</p><p>13. 采购管理是由 13. <span style=\"color: rgb(207, 19, 34);\">采购计划</span> 、采购业务流程和采购业务统一构成的。</p><p>14. 工作中心作为平衡 14.<span style=\"color: rgb(207, 19, 34);\"> 负荷 </span>与能力的基本单元，是运行能力计划时的计算对象。</p><p>15．易飞ERP系统中若启用“出货通知管理”，销货单的前置单据是出货通知单；若不启用“出货通知管理”，销货单的前置单据是 15.<span style=\"color: rgb(207, 19, 34);\"> 客户订单</span> 。</p><p>16. 会计核算的核心部分是 16. <span style=\"color: rgb(207, 19, 34);\">总账管理</span> 。</p><p>17. 易飞ERP系统中， 17. <span style=\"color: rgb(207, 19, 34);\">录入销货单</span> 模块记录企业销货情况，并将销货单提交存货管理子系统，作为组织交货的依据，同时作为编制销售发票的依据。</p><p>18．财务系统与业务系统的信息共享使得公司对业务的管理从 18<span style=\"color: rgb(207, 19, 34);\">. 事后反映</span> 变成了事前控制。</p><p>19. 产品结构子系统是生产管理的基础，是运行MPS、MRP、 19.<span style=\"color: rgb(207, 19, 34);\"> LRP 的基础</span>。</p><p>20. 风险管理的基本内容包括风险因素识别、 20．<span style=\"color: rgb(207, 19, 34);\">评估</span> 、管理。</p><p>21. 在易飞ERP系统中，录入产品工艺路线是在 21.<span style=\"color: rgb(207, 19, 34);\"> 产品结构</span> 子系统中进行。</p><p>22. 22.<span style=\"color: rgb(207, 19, 34);\"> 关键资源能力需求计划</span> 用来检查MPS计划的可行性，将MPS转换成对完成主生产计划所需关键资源的需求。</p><p>23. 在物料需求计划子系统中，生成物料需求计划模块产生相应的物料需求计划，包括生产计划和 23.<span style=\"color: rgb(207, 19, 34);\"> 采购计划</span> 。</p><p>24．财务会计是向 24. <span style=\"color: rgb(207, 19, 34);\">企业外部</span> 提供财务信息的会计事务。</p><p>25. 库存管理子系统中的生产领料单是成本核算的 25.<span style=\"color: rgb(207, 19, 34);\"> 材料费用</span> 数据来源。</p><p>26. 记账凭证分为收款凭证、付款凭证和 26. <span style=\"color: rgb(207, 19, 34);\">转账凭证</span> 。</p><p>27. 成本管理与控制被分为成本中心会计管理、订单及项目会计、27<span style=\"color: rgb(207, 19, 34);\">. 产品成本核算</span> 和利润中心会计 四个模块。</p><p>28. 易飞ERP系统的总账管理提供的特定功能是 28.<span style=\"color: rgb(207, 19, 34);\"> 合并报表</span> 。</p><p>29. ASAP实施方法的内容主要包括ASAP路线图、SAP工具包、 29. <span style=\"color: rgb(207, 19, 34);\">SAP技术支持和服务</span> 、SAP培训、SAP参考模型。</p><p>30. 选型误区主要包括：品牌误区、 30．<span style=\"color: rgb(207, 19, 34);\">产品误区</span> 、需求误区、承诺误区、演示误区。</p><p><br></p><h2>三、简答题</h2><p><br></p><p>1．什么是供应链管理？</p><p style=\"line-height: 2;\">答：供应链管理式围绕核心企业主要通过信息手段对供应各个环节中的各种物料、资金、信息等资源进行计划、调度、调配、控制与利用形成用户、零售商、分销商、制造商、采购供应商的全部供应过程的功能整体。</p><p>2. ERP的核心管理思想体现在哪些方面</p><p>答：（1）支持供应链资源管理（SCM）；</p><p>（2）体现精益生产、敏捷制造和并行工程的思想；</p><p>（3）以信息技术为基础</p><p>（4）ERP同企业业务流程重组（BPR）密切相关；</p><p>（5）以物流和信息流为核心。</p><p>3. 简述产品数据管理的概念</p><p>PDM技术是一项用来管理所有与产品相关的信息和所有与产品相关的过程的技术。</p><p>“所有与产品相关的信息”包括：零部件信息、产品结构、结构配置、文件、CAD文档、扫描图像、审批信息等；</p><p>“所有与产品相关的过程”包括生命周期、工作流程、审批/发放、工程更改等过程的定义与监控。</p><p>4. 简述ERP中采购管理的业务内容有哪些？</p><p>答：（1）供应商管理。一般包括三方面内容：供应商信息、供应商评价和供应商选择。</p><p>（2）生成采购计划。</p><p>（3）询价和洽谈。询价和洽谈的过程可以通过询价单和报价单的方式完成。</p><p>（4）订单跟踪。订单跟踪指通过ERP系统可以随时查看己下达的采购订单到达的位置和被供应商处理的状态。</p><p>（5）到货验收。所采购的物料到达送交地点时采取的验收作业和对验收结果的处理措施。</p><p>5．简述ERP中库存管理业务的一般流程。</p><p>答：（1） 物料进出管理和各个仓库的交易作业处理。</p><p>其中包括调拨单，收料单，收料退回单，收料检验单，验收单，验退单，领料单，退料单，入库单，退制单，借用／归还单，报废单。</p><p>（2） 各仓库存货作业处理。</p><p>其中包括调整单，盘点作业，存货金额计算（月加权平均）。</p><p>（3） 管理信息提供。其中包括库存状况查询表，料品交易明细表，库存流水账，进销存明细账，库存月报表，料品采购建议表，呆滞料品明细表。</p><p>（4） 多仓库管理。其中包括库存管理系统可处理数个不同仓库的库存，即在各仓库料品的进、出、存等作业。任何一项料品（原物料、半成品或成品），可同时存放于不同的仓库。</p><p>6. 描述生产管理的流程有哪些环节？</p><p>答： （1）录入产品结构子系统的基础信息，完成产品结构的设置，主要是BOM表的信息。</p><p>（2）根据销售预测或者客户订单安排生产，在MPS的基础数据之上产生MPS计划，维护MPS计划。</p><p>（3）根据MPS计划的信息，运行MRP计划，MRP计划也可以直接根据订单进行计算，生成MRP采购计划和MRP生产计划。这些计划不必再根据能力需求计划来检验，它们计算的本身就是在信息集成的基础上进行的。</p><p>（4）MRP生产计划发放成工单，成为车间作业计划，车间据此开展生产。</p><p>（5）车间生产包括开始领料，投产，在制品在工序之间的转移，生产完工入库。</p><p>（6）ERP中各系统直接是信息集成的，因此完工入库后，各相关子系统的信息得到更新，如库存的品号信息，生产成本信息等。</p><p>7. 某企业要新增一些办公椅，如果你是企业的采购人员，那么该项采购业务包含哪些内容？</p><p>答：（1）接受经理的采购指示。确定基本的采购需求 -</p><p>（2）收集办公椅供应商的信息，并对供应商进行综合比较，选择合适的供应商。</p><p>（3）向办公椅供应商下达订单，包含办公椅的质量要求、数量要求及交货时间等信息。</p><p>（4）对采购订单进行跟踪检查，控制采购进度。</p><p>（5）采购部门协助库存与检验部门对交货的办公椅进行验收。</p><p>8．什么是物料需求计划？</p><p>答：物料需求计划其主要作用是将主生产计划排产的产品分解成原材料采购件的采购计划、外协件的外协计划和各种自制件的加工装配计划。</p><p>它与主生产计划、车间作业管理、能力需求计划、物流管理等系统集成，反映企业需要生产什么、什么时候生产、生产多少的动态闭环控制计划系统。</p><p>9．某企业销售人员接到客户的订货咨询电话，请描述他即将开展的业务处理内容</p><p>答：（1）提供给客户产品目录和报价情况，如客户对此满意，与客户建立初步的购买订单。</p><p>（2）根据已建立的客户档案资料，对客户的信用状况进行审核，核定其信用额度。当该客户的应收账款加上本次交易金额之和大于其信用额度时，一般不予进行交易。</p><p>（3）如果客户的信用审核被通过，接下来需要进行产品库存的查询，以便决定库存的分配发货的选择，以及发货给客户的策略。</p><p>（4）当报价，信用，库存各方面信息均已得到之后，就可以与客户进行交易，签订正式订单。</p><p>（5）有了订单之后，也可以根据需要对订单进行修改和撤消以及跟踪。</p><p>（6）产品完工之后，可以开出发票和发货单，并进行货物的发运。</p><p>10. 简述传统财务会计中存在的问题。</p><p>答：在财务会计活动中以下几个环节容易出现问题：生成财务报告、信息相关性、信息共享、企业信用管理等方面。</p><p>（1）生成财务报告困难，信息披露不完整</p><p>传统财务报表提供的信息主要是面向过去的历史信息，统一运用货币计量，缺少对使用者未来决策有重要参考价值的信息。</p><p>（2）信息相关性差，不易提供有用预测</p><p>传统财务报表模式是立足于企业已发生的确定性交易和事项，这些事项的分类对使用者决策所需信息相关性较低。同时，传统的财务管理也无法将大量的信息进行快速处理，提供用于计划和经营控制的有用预测，以及实时的信息流供管理者进行实时决策。</p><p>（3）信息无法实现实时共享，滞后性严重</p><p>很多企业可能已经拥有了独立职能部门的信息系统，这些未集成的信息系统主要为了处理部门内部的业务，其次才是提供数据信息给会计系统。很多情况下，数据共享不能及时实现，会计部门的数据也不能及时更新。</p><p>11. 简述ERP中库存管理的业务内容。</p><p>答：库存管理业务主要有以下几种。</p><p>（1） 物料出入库、移动管理：对日常的生产领料、销售提货、采购入库、生产入库和物料库位移动等工作进行管理，产生出、入和移动单据，改变仓库、货位的库存数量，登记物品数量账。</p><p>（2） 库存物料定期盘点，调整物料存量做到账物相符：根据物料的盘点周期对每一种库存物料做盘点，并按照实盘数量调整物料库存数量。盘点方法一般有冻结盘点法和循环盘点法两种。使用冻结盘点法的物料需停止进行出/入库操作，而使用循环盘点法时则可以同时进行出/入库处理。盘点结果产生盘点报表，经过财务审核确认产生库存数量账进行调整。</p><p>（3） 库存物料管理信息分析：从各种角度对库存物料信息做分析。如物料库存数量分析 (是否超储或短缺，、物料占用资金分析、物料来源和去向分析和物料分类构成分析等</p><p>12．ERP中的总账模块与传统的总账管理之间的区别。</p><p>答：（1） 自定义数据表格。 -</p><p>（2）做会计期间期初准备，进行前期结算的开户作业。此时，各资产、负债及所有者权益的会计总账科目都有期初余额，各收益及费用等会计总账科目的期初余额都归零。</p><p>（3） 会计期间的交易按照先后顺序将会计科目记录在总账科目及明细分类账科目下。</p><p>（4） 编制财务报表时，随时编制调整分录及过账，调整在实际运作中产生的折旧费用等一系列费用，再编制及时而准确的报表。</p><p>（5） 会计期间终了时，调整已发生的费用以反应真实状况，将各项收入、费用科目结清，并将资产、负债及所有者权益等科目的本期期末余额结转为下期的期初余额。</p><p>每一会计期间的期末结算后，即进入下一会计期间的期初开户阶段。</p><p>13. 简述ERP系统中自动分录的作用。</p><p>答：（1）一般财务软件存在的缺陷</p><p>从工作机理来看，一般的财务软件只是单纯的针对企业的业务进行财务核算和管理。财务人员仍然要面对繁琐的财务凭证录入工作而无法将时间用在财务管理上。</p><p>（2）ERP中自动分录的功能</p><p>ERP中自动分录功能将财务流程紧密集成在一起，针对不同的业务类型自动触发会计事件，会计事件对应的凭证已经预先定义会计科目。</p><p>当业务类型发生时，系统自动产生会计凭证，更新到分类账和总账。</p><p>（3）自动分录带来的好处</p><p>财务人员的工作内容就是对这些凭证进行审核或由系统自动审核，大量的减轻了财务人员单笔记账的繁重任务，自动分录与过账实现对收入与费用的配比，将时间集中在财务管理的工作内容中，为公司提供更多决策依据</p><p>14.实施ERP的最关键因素是什么？并说明理由。</p><p>答：人是实施ERP的最关键</p><p>企业各级人员必须对ERP有充分理解，是实施ERP系统获得成功的关键所在</p><p>高层管理人员的参与程度、中级管理人员的积极性以及企业员工的态度，是实施ERP系统获得成功的最重要的因素。</p><p>有些企业实施ERP系统未能获成功或未能充分发挥ERP系统的作用，是企业把ERP作为一个计算机系统而不是作为一个人的系统来对待。花了许多时间和精力去选择软件系统，然而，成功的ERP用户和不成功的ERP用户之间的差别不是由软件系统的差别造成的。</p><p>15. 请画出ASAP路线图，并进行简要描述</p><p>答：项目准备→企业蓝图→实现过程→最终准备→实现运行和支持项目准备</p><p>主要是建立项目组织。这一阶段，确定系统实施目的和目标、准备策略和项目拟草方案、确定项目的基本构造、执行正式安装的规模和指标，初始化SAP系统。</p><p>（2）企业蓝图</p><p>主要处理需求的归档和最终确定。小组成员和顾问在不同活动领域内进行讨论，以获得各业务流程的确切要求。最后输出结果为企业蓝图文档，详细说明设计后的流程，包括公司结构和业务流程的说明文件。</p><p>（3） 实现过程</p><p>实现的目标是使用IMG并给予企业蓝图文档来配置基准线（baseline）系统。为了实现这个目标，业务流程被划分为几个阶段的相关的业务流程。运行系统就是在基线系统的基础上进一步发展起来的。最后交付使用的是一个配置完全、测试过的SAP系统，可以满足公司的需求。</p><p>（4） 最终准备</p><p>最终准备阶段目的实施系统和公司实施SAP做好准备。这个阶段强化了前面阶段的所有活动，发现并解决所有异常情况和配置错误。SAP小组成员管理的超级用户负责进行最终用户的培训。此外，还需要检查所有的程序切换和交互界面、进行容量测试和压力测试，并测试用户的接受程度。然后就是向新系统中导入数据。</p><p>（5） 实际运行和支持（Go Live and Support）</p><p>实际运行和支持阶段处理SAP系统投入运行的一些事务。这涉及到解决每日操作问题，包括最终用户提出的一些问题和安全相关的事务。SAP要求进行实时监控，以尽可能达到最优化。</p><p><br></p><h2>四、应用题</h2><p><br></p><p>1．ERP中采购管理与其它管理部门都有着密切的关系，如下图所示，请填写空缺的信息。再根据此要描述采购管理同其它管理如成本管理、质量管理等的关系。</p><p><br></p><p>答：○1MRP ○2 财务管理 ○3库存管理</p><p>与其他管理部门的联系：</p><p>（1）与制造部门的联系</p><p>采购需满足生产需求，通过MRP计算提出物料需求计划</p><p>（2）与质量管理部门的联系</p><p>处理采购到货和委外到货存货的检验。检验完成后，对于合格接受数量或让步接受数量，可自动参照生成入库单；对于不合格数量，参照生成来料不良品处理单。质管部门须提供给采购部门最新信息以协助其掌握现有供应商的供应质量。</p><p>（3）与财务部门的联系</p><p>其联系通常以电子方式进行的，如采购向供应商下订单后，系统会自动将采购单相关数据传到财务部门，进行后续账单产生的处理；而采购部门对某对象采购的评估，部分也靠财务部门提供数据以计算其成本。</p><p>（4）与库存部门的联系</p><p>一方面是对采购进来的原材料进行收货和储存，另一方面通过安全库存、补货政策等库存计算方式对库存量进行计算，提供给采购部门准确库存需求信息，以期能够在最低的成本进行生产经营活动，是库存积压造成的浪费达到最低。</p><p>（5）与成本管理部门的联系</p><p>通过对原材料、产品成本精确计算，提出科学合理的采购计划，避免资金的浪费。</p><p>2．库存管理与其他管理的关联如下图所示，请填写空缺的信息，简述它们之间的关联。</p><p><br></p><p>答：○1MRP ○2采购管理 ○3车间管理</p><p>库存管理与其他管理的联系：</p><p>（1）为物料需求计划提供库存的信息</p><p>（2）为财务管理系统提供库存的财务资料</p><p>（3）采购系统要从库存管理中了解采购需求，同时将采购来的物料转移到库存管理系统</p><p>（4）质量管理系统需要对库存物料的质量进行检验</p><p>（5）向车间管理以及在制品管理系统发料、物料入库以及进行在制品库存管理等。</p><p>3． 画出销售订单处理业务部分的流程图，简要描述该部分业务流程。</p><p>答：销售订单处理业务部分的流程：</p><p><br></p><p>销售订单处理流程有:</p><p>（1）根据产品目录及报价，企业与客户初步建立了购买订单．（2）企业要根据已建立的客户档案资料，对客户的信用状况进行审核，核定其信用额度。当该客户的应收账款加上本次交易金额之和大于其信用额度时，一般不予进行交易。</p><p>（3）如果客户的信用审核被通过，查询产品库存，以便决定库存能否发货给客户。</p><p>（4）当报价，信用，库存各方面信息均已得到之后，就可以与客户进行交易，签订正式订单。</p><p>（5）有了订单之后，也可以根据需要对订单进行修改和撤消以及跟踪</p><p>（6）产品完工之后，可以开出发票和发货单，并进行货物的发运。</p><p>4．实验资料：2007-2-21 计划购买休闲椅，向“佳佳工业”和“标致家具”进行询价；询价结果：“佳佳工业”的分量计价要求：数量100以上且200以下单价为90，200以上单价80；“标致家具”休闲椅单价为130，无分量计价。同一天采购人员向上级主管部门汇报，主管人员进行审核，决定从“佳佳工业”购买休闲椅50支，含税单价120；由采购人员录入请购单。</p><p>问题：如何利用易飞ERP系统软件进行相应的业务处理？请分析并给出其操作步骤。</p><p>4．答：（1）需要实现的业务内容有：</p><p>1）向“佳佳工业”和“标致家具”进行询购休闲椅价格，需要录入“询价单”；</p><p>2）上级主管部门决定从“佳佳工业”购买休闲椅，需要录入“请购单”。</p><p>（2）由此设计操作步骤有：</p><p>第1步：进入系统。登录易飞ERP系统，在系统主界面中选择“进销存管理”→“采购管理子系统”模块，进入“采购管理子系统”界面。</p><p>第2步：录入询价单。在“采购管理子系统”中单击“录入询价单”模块，进入“录入询价单”界面，单击“新增”按钮，录入询价单，需要录入询价的品号、供应商的价格信息等。录入完毕，保存并结束录入。</p><p>第3步：录入请购单。在“采购管理子系统”中单击“录入请购单”模块，进入“录入请购单”界面，录入休闲椅的请购数量，参考采购供应商信息，录入完毕，保存单据，结束录入。</p><p>5. 实验资料：2007-2-19，某企业领“中支”原材料100个，到原材料仓，准备投入生产。</p><p>问题：如何利用易飞ERP系统软件进行相应的业务处理？请分析并给出其操作步骤。</p><p>5．答：需处理的业务内容</p><p>在ERP系统中实现如下：在系统中将信息到“录入库存交易单”中，并选取“单别”为“零星领料”即可完成此项业务的日常处理。具体操作步骤如下：</p><p>第1步：登录系统。在系统主界面中选择“进销存管理”→“存货管理子系统”， 进入“存货管理子系统”界面。</p><p>第 2 步：录入库存交易单。在“存货管理子系统”中单击“录入库存交易单”模块，进入“录入库存交易单”界面，录入领料的品号、数量、日期、仓库等信息。单击“保存”按钮结束录入。</p><p>6.实验资料：2007-2-27销售人员蔡春查看“订单预计出货表”，销售订单“DD-20070205001”在预计出货，于是通知仓库人员备好该订单150台办公椅准备出货。2007-2-28仓库人员刘争正式办理销售出库，办公椅库存减少150台。</p><p>问题：如何利用易飞ERP系统软件进行相应的业务处理？请分析并给出其操作步骤。</p><p>6．答：（1）需要实现的业务内容有：</p><p>1）蔡春欲了解订单预计出货状况，查看“订单预计出货表”；</p><p>2）蔡春通知仓管人员刘争备货，需“录入出货通知单”；</p><p>3）仓管人员刘争办理销售出库，需“录入销货单”；</p><p>(2) 由此设计操作步骤：订单预计出货表、录入出货通知单、录入销货单</p><p>第1步：进入销售管理子系统。登录易飞ERP系统。在系统主界面中选择“进销存管理”→“销售管理子系统”，进入“销售管理子系统”界面。</p><p>第2步：查询“订单预计出货表”。 蔡春登录系统后，在“销售管理子系统” 中单击“订单预计出货表”模块，进入“订单预计出货表”界面，查看“订单已交数量”和“未交数量”信息。</p><p>第3步：录入出货通知单。从系统主界面左边树状结构处，选择“进销存管理”→“销售管理子系统”→“销货管理”，在该树状结构中，双击“录入出货通知单”模块，进入“录入出货通知单”界面，进行新增操作，录入客户信息，出货品号、出货日期、出货数量等信息。完毕后保存，关闭界面。</p><p>第4步：录入销货单。</p><p>（1）更换用户。以库管员刘争的身份重新登录系统。</p><p>（2）录入销货单。在“销售管理子系统” 中单击“录入销货单”模块，进入“录入销货单”界面，进行新增，录入客户信息后，通过复制“出货通知单”内容完成“销货单”的录入。完毕后保存关闭界面。</p><p>1、精艺生产的定义：以丰田汽车公司为代表的新的资本主义生产方式。其主要特征是对市场变化的快速反应能力、同一条流水线可以生产不同的产品、适时供应、多技能和具有团队精神的劳动力、对生产过程不断改进的动力与能力。精益生产(Lean Manufacturing)，简称“精益”，利用杜绝浪费和无间断的作业流程──而非分批和排队等候──的一种生产方式。 精益生产是衍生自丰田生产方式的的管理哲学。</p><p>精益生产（Lean Production，简称LP）是美国麻省理工学院数位国际汽车计划组织（IMVP）的专家对日本“丰田JIT（Just In Time）生产方式”的赞誉之称，精，即少而精，不投入多余的生产要素，只是在适当的时间生产必要数量的市场急需产品（或下道工序急需的产品）；益，即所有经营活动都要有益有效，具有经济性。精益生产是当前工业界最佳的一种生产组织体系和方式。</p><p>2、ERP是英文Enterprise Resourse Planning的缩写，中文意思是企业资源规划。它是一个以管理会计为核心的信息系统，识别和规划企业资源，从而获取客户订单，完成加工和交付，最后得到客户付款。</p><p>换言之，ERP将企业内部所有资源整合在一起，对采购、生产、成本、库存、分销、运输、财务、人力资源进行规划，从而达到最佳资源组合，取得最佳效益。</p><p>ERP——Enterprise Resource Planning 企业资源计划系统，是指建立在信息技术基础上，以系统化的管理思想，为企业决策层及员工提供决策运行手段的管理平台。</p><p>3、BPR （Business Process Reengineering）是对企业的业务流程作根本性的思考和彻底重建，其目的是在成本、质量、服务和速度等方面取得显著的改善，使得企业能最大限度地适应以顾客(Customer)、竞争(Competition)、变化(Change)为特征的现代企业经营环境”。</p><p>4、MRP2是资源制造计划，它是一个由原料供应信息，产品需求信息，产品制造信息，产品销售信息，消费者反馈信息，构成的一个封闭的信息环，这样可以更快的适应市场的变化，及时调整产品结构以适应市场的变化。特点：2把企业中个子系统有机地结合起来，组成一个全面生产管理的集成优化规律系统。 MRP是物料需求计划，它的目的是使产品所需的原料能得到及时的补充，以免由于原料的时间价值占用大量的企业资金。使企业的资金周转周期大大缩短，给企业创造更大的利润。</p><p>5、分析说明生产过程的组织原则。</p><p>合理组织生产过程的基本要求</p><p>　　（1）生产过程的连续性　　生产过程的连续性是指产品和它的零部件在生产过程中各个环节上的运动，自始至终处于连续状态，不产生或少产生不必要的中断、停顿和等待现象。</p><p>　　（2）生产过程的平行性　　所谓生产过程的平行性是指加工对象在生产过程的各工艺阶段和各工序上的生产应平行交叉地进行。</p><p>　 （3）生产过程的比例性　　生产过程的比例性是指生产过程中基本生产过程和辅助生产过程之间，基本生产过程中各车间、各工段、各工序之间以及各种设备之间，在生产能力上保持适合产品制造数量和质量要求的比例关系。</p><p>　　(4）生产过程的节奏性　　生产过程的节奏性是指产品在生产过程各个阶段，从投料到最后完工入库，都能保持按计划有节奏地进行，要求在相同的时间间隔内生产大致相同数量或递增数量的产品，避免前松后紧，月初完不成任务，月末加班加点突击完成任务那种不正常现象的产生。　</p><p>　(5)生产过程的适应性　　所谓的生产过程的适应性，就是指当企业产品改型换代或品种发生变化时，生产过程应具有较强的应变能力。也就是生产过程应具备在较短的时间内，可以由一种产品的生产，迅速转换为另一种产品生产的能力。</p><p>6、1．什么是 ERP？请结合教材及相关网站的评论，阐述对你对 ERP 的理解。</p><p>答：</p><p>ERP定义： ERP是一种企业内部所有业务部门之间、以及企业同外部合作伙伴之间交换和分享信息的系统；是集成供应链管理的工具、技术和流程，是管理决策和供应链流程优化不可缺少的手段，它有助于实现现代企业的竞争优势。</p><p>对ERP的理解：</p><p>（1）ERP 是一整套企业管理系统体系标准，实质是在MRPII 基础上进一步发展而成的，</p><p>面向供应链的管理思想。</p><p>（2）ERP 是一个企业管理系统，建立在信息技术基础上的，整合了企业管理理念、业</p><p>务流程、基础数据、人力物力、计算机硬件和软件的企业资源管理系统，以实现对企业物流、</p><p>资金流、信息流的一体化管理。</p><p>（3）ERP 是一个解决方案。企业面对竞争，必须不断获得新的企业管理需求和提出新</p><p>的管理思想和方法，以提升企业竞争力；借助 ERP 管理思想以及现代信息技术，开发出满足企业需求的 ERP 软件产品，并逐步构建以此为核心的数字企业，进一步增强企业的竞争能力。</p><p>7、3．ERP 与 MRP、MRPII 有什么不同？</p><p>答：</p><p>ERP 是在 MRP 和 MRPⅡ的基础上发展起来的。</p><p>MRP 是建立两个假设的基础上：一是生产计划是可行的；二是假设采购计划是可行的。</p><p>但在实际生产中，能力资源和物料资源总是有限的，因而往往会出现生产计划无法完成的情</p><p>况。</p><p>MRPⅡ仅仅改变企业内部资源的信息流，但随着全球经济一体化的加速，企业与其外</p><p>部环境的关系越来越密切，MRPⅡ已经不能满足需要。</p><p>ERP 打破了 MRP 和 MRPⅡ只局限于传统制造业的旧的观念和格局，把触角伸向各个</p><p>行业，大大扩展了应用范围。</p><p>计划体系差别：</p><p>MRPⅡ的核心主要集中在资源计划，有 4 个计划层次，即经营与运作规划（生产规划）、</p><p>主生产计划、物料需求计划、车间作业控制（或采购作业控制）。</p><p>ERP 系统中的计划体系主要包括：主生产计划、物料需求计划、能力计划、采购计划、</p><p>销售执行计划、利润计划、财务预算和人力资源计划等，而且这些计划功能与价值控制功能</p><p>已完全集成到整个供应链系统中。</p><p>5．简述 ERP 的发展趋势。</p><p>答：</p><p>（1）注重对整个供应链的管理支持。</p><p>（2）注重人力资源开发和知识管理。</p><p>（3）决策支持功能不断得到加强。</p><p>（4）更加开放的集成系统。</p><p>8．解释 BPR、JIT 和 LP 的含义。</p><p>答： BPR</p><p>业务流程重组就是对企业的业务流程 (Process) 进行根本性再思考和彻底性再设计，从</p><p>而获得在成本、质量、服务和速度等方面业绩的戏剧性的改善”。</p><p>业务流程重组以作业流程为中心、打破传统的金字塔形组织结构向平板形发展，即扁平</p><p>化结构管理；强调以业务流程为改造对象，以关心客户满意度为目标。</p><p>“根本性”、“彻底性”、“戏剧性”和“流程”是业务流程重组的 4 个核心内容，也说明</p><p>了业务流程重组的原则。</p><p>JIT</p><p>JIT（Just In Time，及时生产）是使制造业达到卓越的一种哲理，其基本点是有计划地</p><p>消除所有的浪费，持续不断地提高生产率。这贯穿于成功地执行为生产最终产品所要求的</p><p>所有活动之中。</p><p>丰田公司关于 JIT 系统的定义是“只在必要的时间以必要的数量生产必要的物料”。丰</p><p>田的这个生产系统通常被称作“看板管理”。</p><p>LP</p><p>精益生产 (lean production，LP) 思想源于日本丰田汽车公司，是美国麻省理工学院研</p><p>究小组的专家组通过对以 JIT 生产方式为代表的日本汽车生产管理方式，特别是对丰田汽车</p><p>公司的生产管理方式的研究而提出的生产经营管理思想，总结提出了“精益生产”的生产管</p><p>理模式。该模式综合了单件小批与大批大量的生产优点，汇集了准时制生产和供应链经营管</p><p>理思想，保证制造的各种流(销售、供应、加工)的畅通，杜绝浪费、合理利用企业资源，最</p><p>大限度地消除一切无增值的劳动，追求尽善尽美。</p><p><br></p><p>————————————————</p><p>版权声明：本文为CSDN博主「厦门德仔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：https://blog.csdn.net/david_520042/article/details/51836238</p>', '/public/uploads/2023/05/31/168554827775244.jpg', 'erp原理与运用', 'erp原理与运用期末考试题', 'erp原理与运用期末考例题，提供复习。', 'erp', '其他', '2', '2023-05-31 23:51:19', '2023-05-31 23:51:19', 'U', 2);
INSERT INTO `blog_essay` VALUES (49, '<h3>三种模式</h3><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/02/1685679446796955.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"/></p><h3>六大原则</h3><p><br></p><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/02/1685679488453717.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"/></p><p><br></p><h3>意图</h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式让类的实例化延迟到子类中进行。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">抽象工厂模式：提供一个接口用于创建一系列的相关的或者相互依赖的对象，而无需指定它们的具体类。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">单例模式：保证一个类仅有一个实例，并提供一个全局访问点。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">原型模式：通过复制现有的实例来创建新的实例。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start; line-height: 2;\">适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">桥接模式：用于将抽象部分与它的实现部分分离，以便它们可以独立地变化。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">组合模式：将对象组合成树形结构以表示\"部分-整体\"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">装饰器模式：动态地给一个对象添加一些额外的职责，就增加功能而言，装饰器模式比生成子类更为灵活。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">外观模式：为了提供一致的接口，而将一群具有类似功能的类封装起来。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">享元模式：运用共享技术以支持大量细粒度对象的复用。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的访问。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以在不改变算法结构的情况下重定义算法的某些特定步骤。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">命令模式：将一个请求封装成一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销操作。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">职责链模式：将请求的发送者和接收者解耦，使得多个对象都有机会处理这个请求。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">观察者模式：定义对象间的一种一对多的依赖关系，以便当一个对象状态改变时，所有依赖于它的对象都得到通知并自动刷新。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">备忘录模式：在不违反封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样可以将对象恢复到之前的某个状态。</p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><p style=\"text-align: start;\"><br></p><h3 style=\"text-align: start;\">UML图</h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"> <a href=\"https://blog.csdn.net/qq_40274514/article/details/124047443\" target=\"_blank\">UML图</a> </p><p style=\"text-align: start;\"><br></p><h3>单选题汇总</h3><p><br></p><p>第一章 软件设计模式体系结构概述</p><p>1、以下对开闭原则的描述错误的是（A）。</p><p><br></p><p>A.开闭原则与“对可变形的封装原则”没有相似性 &nbsp;</p><p><br></p><p>B.找到一个系统的可变元素，将它封装起来，叫开闭原则 &nbsp;</p><p><br></p><p>C.对修改关闭，是其原则之一 &nbsp;</p><p><br></p><p>D.从抽象层导出一个或多个新的具体类可以改变系统的行为，是其原则之一 &nbsp;</p><p><br></p><p> </p><p><br></p><p>2、常用的基本设计模式可分为（A）。</p><p><br></p><p>A.创建型、结构型和行为型 &nbsp; &nbsp; &nbsp; &nbsp;B.对象型、结构型和行为型 &nbsp;</p><p><br></p><p>C.过程型、结构型和行为型 &nbsp; &nbsp; &nbsp; &nbsp;D.抽象型、接口型和实现型 &nbsp;</p><p><br></p><p> </p><p><br></p><p>3、对违反里氏替换原则的两个类，可以采用的候选解决方案正确的是（D）。</p><p><br></p><p>A.创建一个新的抽象类C，作为两个具体类的超类，将A和B共同的行为移动到C中，从而解决A和B行为不完全一致的问题。</p><p><br></p><p>B.将B到A的继承关系改成组合关系。</p><p><br></p><p>C.区分是“is-a”还是“has-a”。如果是“is-a”，可以使用继承关系，如果是“has-a”应该改成组合关系。</p><p><br></p><p>D.尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程。</p><p><br></p><p> </p><p><br></p><p>4、下列属于面向对象基本原则的是（C）。</p><p><br></p><p>A.继承 &nbsp; &nbsp; &nbsp; &nbsp;B.封装 &nbsp; &nbsp; &nbsp; &nbsp;C.里氏替换 &nbsp; &nbsp; &nbsp; &nbsp;D.子类复用</p><p><br></p><p> </p><p><br></p><p>5、要依赖于抽象，不要依赖于具体，即针对接口编程，不要针对实现编程，是（D）的表述。</p><p><br></p><p>A.开-闭原则 &nbsp; &nbsp; &nbsp; &nbsp;B.接口隔离原则 &nbsp; &nbsp; &nbsp; &nbsp;C.里氏代换原则 &nbsp; &nbsp; &nbsp; &nbsp;D.依赖倒转原则</p><p><br></p><p> </p><p><br></p><p>6、“不要和陌生人说话”是（D）原则的通俗表述。</p><p><br></p><p>A.接口隔离 &nbsp; &nbsp; &nbsp; &nbsp;B.里氏代换 &nbsp; &nbsp; &nbsp; &nbsp;C.依赖倒转 &nbsp; &nbsp; &nbsp; &nbsp;D.迪米特</p><p><br></p><p> </p><p><br></p><p>7、Open-Close原则的含义是一个软件实体(A)</p><p><br></p><p>A.应当对扩展开放，对修改关闭 &nbsp; &nbsp; &nbsp; &nbsp;B.应当对修改开放，对扩展关闭</p><p><br></p><p>C.应当对继承开放，对修改关闭 &nbsp; &nbsp; &nbsp; &nbsp;D.以上都不对</p><p><br></p><p>第二章 创建型_简单工厂、工厂方法、抽象工厂</p><p>8、以下关于创建型模式说法正确的是（A）。</p><p><br></p><p>A:创建型模式关注的是对象的创建 &nbsp; &nbsp; &nbsp; &nbsp;B:创建型模式关注的是功能的实现</p><p><br></p><p>C:创建型模式关注的是组织类和对象的常用方法 &nbsp; &nbsp; &nbsp; &nbsp;D:创建型模式关注的是对象间的协作 &nbsp;</p><p><br></p><p> </p><p><br></p><p>9、当创建一个具体的对象而不希望制定具体的类时，可以使用（B）模式。</p><p><br></p><p>A:结构型 &nbsp; &nbsp; &nbsp; &nbsp;B:创建型 &nbsp; &nbsp; &nbsp; &nbsp;C:行为型 &nbsp; &nbsp; &nbsp; &nbsp;D:复用型</p><p><br></p><p> </p><p><br></p><p>10、当需要在项目中定制自己的元素时，可使用（B）模式来定制。</p><p><br></p><p>A:结构型 &nbsp; &nbsp; &nbsp; &nbsp;B:创建型 &nbsp; &nbsp; &nbsp; &nbsp;C:行为型 &nbsp; &nbsp; &nbsp; &nbsp;D:复用型</p><p><br></p><p> </p><p><br></p><p>11、下列关于静态工厂和工厂方法表述错误的是（D）</p><p><br></p><p>A.在工厂方法模式中，对于存在继承等级结构的产品树，产品的创建是通过相应等级结构的工厂创建的</p><p><br></p><p>B.不能形成静态工厂的继承结构</p><p><br></p><p>C.静态工厂对具体产品的创建类别和创建时机的判断是混和在一起的，这点在工厂方法中</p><p><br></p><p>D.二者都满足开闭原则：静态工厂以if else方式创建对象，增加需求的时候会修改源代码</p><p><br></p><p> </p><p><br></p><p>12、关于模式适用性，在以下情况不适合使用FACTORY METHOD模式？（C）</p><p><br></p><p>A. 当一个类不知道它所必须创建的对象的类的时候</p><p><br></p><p>B. 当一个类希望由它的子类来指定它所创建的对象的时候</p><p><br></p><p>C. 当你提供一个产品类库，而只想显示它们的接口而不是实现时</p><p><br></p><p>D. 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候</p><p><br></p><p> </p><p><br></p><p>13、以下意图哪个是用来描述FACTORY METHOD（工厂方法）？（）</p><p><br></p><p>A. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p><p><br></p><p>B. 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p><p><br></p><p>C. 定义一个用于创建对象的接口，让子类决定实例化哪一个类。该模式使一个类的实例化延迟到其子类</p><p><br></p><p>D. 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化</p><p><br></p><p> </p><p><br></p><p>14、以下意图哪个是用来描述ABSTRACT FACTORY（抽象工厂）？（A）</p><p><br></p><p>A. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p><p><br></p><p>B. 定义一个用于创建对象的接口，让子类决定实例化哪一个类</p><p><br></p><p>C. 将一个类的接口转换成客户希望的另外一个接口</p><p><br></p><p>D. 表示一个作用于某对象结构中的各元素的操作</p><p><br></p><p> </p><p><br></p><p>第三章 创建型_单/多例、建造者、原型</p><p>15、（D）可用来描述原型（Prototype）。</p><p><br></p><p>A:允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p><br></p><p>B:表示一个作用于某对象结构中的各元素的操作。它是你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p><br></p><p>C:定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><br></p><p>D:用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><p><br></p><p> </p><p><br></p><p>16、在（C）适合使用单例（Singleton）模式。</p><p><br></p><p>A:当一个类不知道它所必须创建的对象的类的时候 &nbsp;</p><p><br></p><p>B:当一个类的实例只能有几个不同的状态组合中的一种时 &nbsp;</p><p><br></p><p>C:当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时 &nbsp;</p><p><br></p><p>D:当一个类希望由它的子类来指定它所创建的对象的时候</p><p><br></p><p> </p><p><br></p><p>17、在（B）不适合使用原型（Prototype）模式。</p><p><br></p><p>A:当要实例化的类是在运行时刻指定是，例如通过动态装载 &nbsp;</p><p><br></p><p>B:当要强调一系列相关的产品对象的设计以便进行联合使用时 &nbsp;</p><p><br></p><p>C:为了避免创建一个与产品类层次平行的工厂类层次时 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </p><p><br></p><p>D:当一个类的实例只能有几个不同状态组合中的一种时</p><p><br></p><p> </p><p><br></p><p>18、以下意图哪个是用来描述SINGLETON（单例）？（B）</p><p><br></p><p>A. 将一个类的接口转换成客户希望的另外一个接口该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><p><br></p><p>B. 保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p><br></p><p>C. 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化</p><p><br></p><p>D. 用一个中介对象来封装一系列的对象交互</p><p><br></p><p> </p><p><br></p><p>19、以下意图哪个是用来描述BUILDER（生成器）？（B）</p><p><br></p><p>A. 定义一个用于创建对象的接口，让子类决定实例化哪一个类</p><p><br></p><p>B. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p><br></p><p>C. 保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p><br></p><p>D. 运用共享技术有效地支持大量细粒度的对象</p><p><br></p><p>第四章 结构型_适配器</p><p>20、用来描述适配器( Adapter)的意图是（A）。</p><p><br></p><p>A:将一个类的接口转换成客户希望的另外一个接口，本模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><p><br></p><p>B:定义一个用于创建对象的接口，让子类决定实例化哪一个类</p><p><br></p><p>C:表示一个作用于某对象结构中的各元素的操作，它使用户可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p><p><br></p><p>D:将一个请求封装为一个对象，从而使用户可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作</p><p><br></p><p> </p><p><br></p><p>21、关于模式适用性，不适合使用适配器( Adapter )模式的是（D）。</p><p><br></p><p>A:用户想使用一个已经存在的类，而它的接口不符合用户的需求</p><p><br></p><p>B:用户想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作</p><p><br></p><p>C:用户想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口</p><p><br></p><p>D:如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</p><p><br></p><p>第五章 结构型_合成、装饰模式</p><p>22、以下哪一项可用来描述装饰(Decorator)（D）。</p><p><br></p><p>A:运用共享技术有效地支持大量细粒度的对象</p><p><br></p><p>B:用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p><p><br></p><p>C:将抽象部分与它的实现部分分离，使它们都可以独立变化</p><p><br></p><p>D:动态地给一个对象添加一些额外的职责</p><p><br></p><p> </p><p><br></p><p>23、装饰（Decorator)模式不能用于下列那个选项（C）。 </p><p><br></p><p>A:在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</p><p><br></p><p>B:处理那些可以撒销的职责</p><p><br></p><p>C:客户程序与抽象类的实现部分之间存在着很大的依赖性</p><p><br></p><p>D:当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，每种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是类的定义被隐藏，或类定义不能用于生成子类</p><p><br></p><p> </p><p><br></p><p>24、关于模式适用性，以下（B）不适合使用 Composite(组合)模式。</p><p><br></p><p>A:用户想使用一个已经存在的类，而它的接口不符合用户的需求</p><p><br></p><p>B:用户想表示对象的部分-整体层次结构</p><p><br></p><p>C:当一个类的实例只能有几个不同状态组合中的一种时</p><p><br></p><p>D:一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</p><p><br></p><p> </p><p><br></p><p>25、以下意图（C）是用来描述组合（Composite )。</p><p><br></p><p>A:为其他对象提供一种代理以控制对这个对象的访问</p><p><br></p><p>B:运用共享技术有效地支持大量细粒度的对象</p><p><br></p><p>C:将对象组合成树形结构以表示“部分-整体”的层次结构</p><p><br></p><p>D:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p><br></p><p>第六章 结构型_代理、享元模式</p><p>26、关于模式适用性，以下情况不适合使用代理(Proxy)模式的是（A）。</p><p><br></p><p>A:用户想使用一个已经存在的类，而它的接口不符合用户的需求</p><p><br></p><p>B:根据需要创建开销很大的对象</p><p><br></p><p>C:在需要用比较通用和复杂的对象指针代替简单的指针的时候</p><p><br></p><p>D:取代了简单的指针，它在访向对象时执行一些附加操作 </p><p><br></p><p> </p><p><br></p><p>27、以下意图用来描述代理(Proxy)的是（C）。</p><p><br></p><p>A:用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p><p><br></p><p>B:运用共享技术有效地支持大量细粒度的对象</p><p><br></p><p>C:为其他对象提供一种代理以控制对这个对象的访问</p><p><br></p><p>D:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p><br></p><p> </p><p><br></p><p>28、代理模式的扩展是（A）。</p><p><br></p><p>A:动态代理模式 &nbsp; &nbsp; &nbsp; &nbsp; B:静态代理模式 &nbsp; &nbsp; &nbsp; &nbsp; C:多态代理模式 &nbsp; &nbsp; &nbsp; &nbsp; D:单态代理模式</p><p><br></p><p> </p><p><br></p><p>29、如果有一个2MB的文本（英文字母)，为了对其中的字母进行分类和计数，若为文本中的每个字母都定义一个对象显然不合实际，对与该问题最好可使用的模式是（B）。</p><p><br></p><p>A:装饰(Decorator) 模式 &nbsp; &nbsp; &nbsp; &nbsp; B:享元(Flyweight) 模式 &nbsp; &nbsp; &nbsp; &nbsp; C:合成(Composite)模式 &nbsp; &nbsp; &nbsp; &nbsp; D:命令(Command)模式</p><p><br></p><p> </p><p><br></p><p>30、关于模式活用性，以下（D）不适合使用Flyweight(享元)模式。</p><p><br></p><p>A:一个应用程序使用了大量的对象 &nbsp; &nbsp; &nbsp; &nbsp; B:完全由于使用大量的对象，造成很大的存储开销</p><p><br></p><p>C:对象的大多数状态都可变为外部状态 &nbsp; &nbsp; &nbsp; &nbsp; D:用户想使用一个已经存在的类，而它的接口不符合用户的需求</p><p><br></p><p> </p><p><br></p><p>31、以下意图哪个是用来描述FLYWEIGHT（享元）?（B）</p><p><br></p><p>A.将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p><br></p><p>B.运用共享技术有效地支持大量细粒度的对象。</p><p><br></p><p>C.动态地给一个对象添加一些额外的职责。</p><p><br></p><p>D.用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p><p><br></p><p>第七章 结构型_外观、桥梁、过滤模式</p><p>32、桥接(Bridge)模式不能用在下列哪个场合（D）。</p><p><br></p><p>A:类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充，这时Bridge模式使用户可以对不同的抽象接口和实现部分进行组合，井分别对它们进行扩充</p><p><br></p><p>B:用户不希望在抽像和它的实现部分之间有一个固定的绑定关系，例如，这种情况可能是因为在程序运行时刻实现部分应可以被选择或者切换</p><p><br></p><p>C:对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译</p><p><br></p><p>D:客户程序与抽象类的实现部分之间存在着很大的依赖性</p><p><br></p><p> </p><p><br></p><p>33、以下用来描述桥接( Bridge )的意图是（B）。</p><p><br></p><p>A:提供一个创建一系列相关或相互依赖对象的接口，面无须指定它们具体的类</p><p><br></p><p>B:将抽象部分与它的实现部分分离，使它们都可以独立变化</p><p><br></p><p>C:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p><br></p><p>D:动态地给一个对象添加一些额外的职责</p><p><br></p><p> </p><p><br></p><p>34、以下可用来描述外观(Facade)的是（A）。</p><p><br></p><p>A:为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p><p><br></p><p>B:定义一个用于创建对象的接口，让子类决定实例化哪一个类</p><p><br></p><p>C:保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p><br></p><p>D:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p><p><br></p><p>第八章 行为型_责任链、命令、解释器模式</p><p>35、关于模式适用性，（B）不适合使用职责链（Chain of Responsibility）模式。</p><p><br></p><p>A:有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定</p><p><br></p><p>B:在需要用比较通用和复杂的对象指针代替简单的指针的时候</p><p><br></p><p>C:用户想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</p><p><br></p><p>D:可以处理一个请求的对象集合应被动态指定 </p><p><br></p><p> </p><p><br></p><p>36、Java的异常处理机制可理解为（C）行为模式。</p><p><br></p><p>A:观察者（Observer）模式 &nbsp; &nbsp; &nbsp; &nbsp; B:迭代器（Iterator）模式</p><p><br></p><p>C:职责链（Chain of Responsibility）模式 &nbsp; &nbsp; &nbsp; &nbsp; D:策略（Strategy）模式</p><p><br></p><p> </p><p><br></p><p>37、以下意图那个是用来描述COMMAND（命令）?（A）</p><p><br></p><p>A.将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</p><p><br></p><p>B.定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换，本模式使得算法可独立于使用它的客户而变化。</p><p><br></p><p>C.为其他对象提供一种代理以控制对这个对象的访问。</p><p><br></p><p>D.保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><br></p><p> </p><p><br></p><p>38、以下意图（B）可用来描述解释器（Interpreter）。</p><p><br></p><p>A:将抽象部分与它的现实部分分离，使它们都可以独立变化</p><p><br></p><p>B:给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</p><p><br></p><p>C:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不用的表示</p><p><br></p><p>D:为其它对象提供一种代理以控制对这个对象的访问</p><p><br></p><p>第九章 行为型_迭代器、备忘录、观察者模式</p><p>39、以下选项可用来描述观察者（Observer）的是（B）。</p><p><br></p><p>A:将抽象部分与它的现实部分分离，使它们都可以独立变化。</p><p><br></p><p>B:定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><p><br></p><p>C:用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p><p><br></p><p>D:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</p><p><br></p><p> </p><p><br></p><p>40、以下哪一种说法可用来描述备忘录（Memento）（C）。</p><p><br></p><p>A:保证一个类只有一个实例，并提供一个访问它的全局访问点</p><p><br></p><p>B:将一个请求封装为一个对象，从而使用户可用不同的请求对客户进行参数化；对请求进行排队或记录请求日志，以及支持可撤销的操作</p><p><br></p><p>C:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态</p><p><br></p><p>D:提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</p><p><br></p><p> </p><p><br></p><p>41、以下意图哪个是用来描述ITERATOR（迭代器）？（C）</p><p><br></p><p>A. 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</p><p><br></p><p>B. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p><p><br></p><p>C. 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示</p><p><br></p><p>D. 运用共享技术有效地支持大量细粒度的对象</p><p><br></p><p>第十章 行为型_状态、策略、访问者模式</p><p>42、关于模式适用性，以下（A）不适合使用策略（Strategy）模式。</p><p><br></p><p>A:当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密结合的</p><p><br></p><p>B:许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法</p><p><br></p><p>C:需要使用一个算法的不同变体。例如，用户可能会定义一些反应不同的空间/时间权衡的算法。当这些变体实现为一个算法的类的层次时，可以使用策略模式</p><p><br></p><p>D:算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构</p><p><br></p><p> </p><p><br></p><p>43、以下意图（B）可用来描述访问者（Visitor）。</p><p><br></p><p>A:定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><p><br></p><p>B:表示一个作用于某对象结构中的各个元素的操作</p><p><br></p><p>C:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态</p><p><br></p><p>D:用原型实例指定对象的种类，并且通过复制这些原型创建新的对象</p><p><br></p><p> </p><p><br></p><p>44、以下意图哪个是用来描述STATE（状态）？（C）</p><p><br></p><p>A. 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</p><p><br></p><p>B. 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示</p><p><br></p><p>C. 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</p><p><br></p><p>D. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p><p><br></p><p>第十一章 行为型_中介者、空对象、模板模式</p><p>45、关于模式适用性，以下（B）不适合使用模板方法（Template Method）模式。</p><p><br></p><p>A:一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</p><p><br></p><p>B:当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变</p><p><br></p><p>C:各子类中公共的行为应该被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码</p><p><br></p><p>D:控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展 </p><p><br></p><p> </p><p><br></p><p>46、以下哪一项（D）可用来描述中介者（Mediator）。</p><p><br></p><p>A:提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象</p><p><br></p><p>B:将抽象部分与它的现实部分分离，使它们都可以独立变化</p><p><br></p><p>C:定义一个用于创建对象的接口，让子类决定实例化哪一个类</p><p><br></p><p>D:用一个中介对象来封装一系列的对象交互</p><p><br></p><p> </p><p><br></p><p>47、以下意图哪个是用来描述TEMPLATE METHOD（模板方法）？（A）</p><p><br></p><p>A. 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中</p><p><br></p><p>B. 为其他对象提供一种代理以控制对这个对象的访问</p><p><br></p><p>C. 将抽象部分与它的实现部分分离，使它们都可以独立地变化</p><p><br></p><p>D. 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</p><p><br></p><p><br></p><h3>判断题汇总</h3><p><br></p><p>第一章 软件设计模式体系结构概述</p><p>1、“不要和陌生人说话”是迪米特原则的通俗表述。（✓） </p><p><br></p><p>2、依据设计模式思想，程序开发中应优先使用的是创建。 （✗）</p><p><br></p><p>3、设计模式一般用来解决同一问题的不同表相。(✓) </p><p><br></p><p>4、学习设计模式可以缩短软件的开发周期。(✓) </p><p><br></p><p>第二章 创建型_简单工厂、工厂方法、抽象工厂</p><p>5、简单工厂模式可以根据参数的不同返回不同的实例。（✓）</p><p><br></p><p>6、工厂方法模式的主要角色有:抽象工厂(Abstract Factory)、具体工厂(Concrete Factory)、抽象产品(Product)和具体产品（Concrete Product）。（✓）</p><p><br></p><p>7、抽象工厂模式是简单工厂模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。（✗）</p><p><br></p><p>8、创建型模式把实例化的责任与使用实例的责任分割开来。（✓）</p><p><br></p><p>9、由于Abstract &nbsp;Factory类和具体工厂方法可以分离，因此在实现时会产生更多的类。（✗）</p><p><br></p><p>第三章 创建型_单/多例、建造者、原型</p><p>10、单例模式分为懒汉式单例和饿汉式单例两种。（✓）</p><p><br></p><p>11、原型（Prototype）模式包含：抽象原型类、具体原型类和访问者类等3个部分。（✓）</p><p><br></p><p>12、建造者的退化模式是通过省略使用者角色完成退化的。（✗）</p><p><br></p><p>13、懒汉式单例类在第一次被引用时将自己实例化。（✓）</p><p><br></p><p>第四章 结构型_适配器</p><p>14、类适配器模式和对象适配器模式可用Java实现。 （✓）</p><p><br></p><p>15、类结构型模式之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。（✓）</p><p><br></p><p>16、适配器模式不可以模拟新能源汽车的发动机。（✗）</p><p><br></p><p>17、一个类的结构模式的典型例子就是类的适配器模式。（✓）</p><p><br></p><p>18、对象的结构模式描述怎样把各种不同类型的对象组合在一起，以实现新的功能，其是动态的。（✓）</p><p><br></p><p>19、作为适配器模式的一个特例，缺省适配器模式在Java语言中有着特殊的应用。（✓）</p><p><br></p><p>第五章 结构型_合成、装饰模式</p><p>20、使用装饰模式会产生比使用继承关系更多的对象，更多的对象会使得查错变得困难，特别是这些对象看上去都很像。（✓）</p><p><br></p><p>21、需要增加由一个基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实，此时可以使用装饰器模式。（✓）</p><p><br></p><p>22、需要扩展一个类的功能，或给一个类增加附加责任时可以使用装饰器模式。（✓）</p><p><br></p><p>第六章 结构型_代理、享元模式</p><p>23、代理模式在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。（✓）</p><p><br></p><p>24、代理模式降低了系统的复杂度。（✗）</p><p><span style=\"color: rgb(225, 60, 57); background-color: rgb(255, 255, 255); font-size: 14px;\">代理模式可以在一定程度上提高系统的可维护性和可拓展性，但并不能直接降低系统的复杂度。</span></p><p><br></p><p>25、系统中有大量对象时可以使用享元模式。（✓）</p><p><br></p><p>第七章 结构型_外观、桥梁、过滤模式</p><p>26、外观(Facade)模式能很好地限制客户使用子系统类。（✗）</p><p><br></p><p>27、桥梁（桥接Bridge）模式中，抽象类依赖实现类。（✓）</p><p><br></p><p>28、JAVA 的三层开发模式可用门面（外观Facade）模式。（✓）</p><p><br></p><p>第八章 行为型_责任链、命令、解释器模式</p><p>29、使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系可用来描述职责链（Chain of Responsibility）。（✓）</p><p><br></p><p>30、命令模式中，请求以命令的形式包裹在对象中，并传给调用对象。（✓）</p><p><br></p><p>31、责任链模式可动态指定一组对象处理请求。（✓）</p><p><br></p><p>32、解释器模式可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。（✓）</p><p><br></p><p>33、职责链模式中纯的职责链模式比不纯的职责链模式优先级高。（✗）</p><p><br></p><p>第九章 行为型_迭代器、备忘录、观察者模式</p><p>34、观察者可以改变被观察者的状态，再由被观察者通知所有观察者依据被观察者的状态进行。（✗）</p><p><br></p><p>35、被观察者可以通知观察者进行更新。（✓）</p><p><br></p><p>36、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价，可以用观察者模式。（✓）</p><p><br></p><p>第十章 行为型_状态、策略、访问者模式</p><p>37、访问者模式使得易于增加新的操作。（✓）</p><p><br></p><p>38、访问者集中相关的操作而分离无关的操作。（✓）</p><p><br></p><p>39、策略对象改变 context 对象的执行算法。（✓）</p><p><br></p><p>40、策略模式关键在于实现不同的接口。（✗）</p><p><br></p><p>41、策略模式会使策略类会增多。（✓）</p><p><br></p><p>42、在对象的数据类型很少改变，但是需要经常的改变操作或者增加新操作的情况下可以使用访问者模式。（✓）</p><p><br></p><p>第十一章 行为型_中介者、空对象、模板模式</p><p>43、模板方法对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 （✓）</p><p><br></p><p>44、模板方法父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。（✓）</p><p><br></p><p>45、在实际开发中，通常采用不定义中介者接口，把具体中介者对象实现成为单例的方法来简化中介者模式。（✓）</p><p><br></p><p>46、中介者模式用来降低多个对象和类之间的通信复杂性。（✓）</p><p><br></p><p>47、模板模式的关键在于在抽象类实现，其他步骤在子类实现。（✓）</p><p><br></p><p>第十二章 软件体系结构</p><p>48、面向对象系统必须修改所有显式调用它的其它对象，并消除由此带来的一些副作用。（✓）</p><p><br></p><p>49、ATAM：Architecture Tradeoff Analysis Method（体系结构权衡分析方法）不可调整步骤顺序。（✗）</p><p><br></p><p>50、单态类只可有一个实例。（✓）</p><p><br></p><p>51、适配器模式属于创建型模式结构型。（✗）</p><p><br></p><p>52、在设计模式中，“效果”只是指“原因和结果”。（✓）</p><p><br></p><p>53、设计模式使代码编制不能真正工程化。（✓）</p><p><br></p><p>54、面向对象语言编程中的异常处理，可以理解为责任链模式。（✓）</p><p><br></p><p>55、反模式就是反对在软件开发过程中使用设计模式分析：反模式用来解决问题的带有共性的不良方法。（✗）</p><p><br></p><p>56、单一职责原则表现在面向对象的程序中就是“高内聚、低耦合”。（✓）</p><p><br></p><p>57、设计模式只能遵从使用，不能也无需创新。（✗）</p><p><br></p><p>58、在面向对象编程时，无论何时何地都要使用GoF所给出的设计模式，这样编写的代码才比较好。（✗）</p><p><br></p><p>59、工厂方法能够提高内聚性，松散耦合，并且有助于测试。（✗）</p><p><br></p><p>60、对象要么构造其它对象，要么使用其它对象，绝不要两者兼顾。（✓）</p><p><br></p><h3>填空题汇总</h3><p><br></p><p style=\"line-height: 2;\">1. 当存在一个抽象有不同实现时Bridge模式最为有用，它可以使抽象和（ &nbsp; &nbsp;<span style=\"color: rgb(255, 0, 0);\">实现部分</span> &nbsp; &nbsp;）相互独立地进行变化。</p><p style=\"line-height: 2;\">2. 在进行设计以应对变化的过程中，应该遵循两条基本策略：找出变化并封装变化点；优先使用对象组合 ，而不是类（ &nbsp; &nbsp;<span style=\"color: rgb(255, 0, 0);\">继承 </span> &nbsp; &nbsp; ）。</p><p style=\"line-height: 2;\">3. ( &nbsp; <span style=\"color: rgb(255, 0, 0);\"> 备忘录</span> &nbsp; )模式捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可以将该对象恢复到原先保存的状态。</p><p style=\"line-height: 2;\">4. 对观察者模式中，Subject类将实现一个（ &nbsp; <span style=\"color: rgb(255, 0, 0);\"> notifyObservers</span> &nbsp; ）方法来遍历其Observer对象列表，并调用每个Observer对象的update方法。</p><p style=\"line-height: 2;\">5. Template Method模式准备一个抽象类，将部分逻辑以（ &nbsp;<span style=\"color: rgb(255, 0, 0);\">钩子函数</span> &nbsp;）以及具体构造子类的形式 实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。</p><p><br></p><h3>简答题汇总</h3><p><br></p><p>1、什么是设计模式？设计模式目标是什么？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码可靠性。</p><p><br></p><p> </p><p><br></p><p>2、设计模式中一般都遵循的原则有什么？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;开闭原则、根据场景进行设计原则、优先组合原则、包容变化原则</p><p><br></p><p> </p><p><br></p><p>3、“Gang of Four”针对“创建优秀面向对象设计”建议了哪些策略？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;针对接口编程、优先使用对象组合而不是类继承，找到并封装变化点。</p><p><br></p><p>4、面向对象系统中功能复用的两种最常用技术是什么？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;类继承和对象组合，类继承允许你根据其他类的实现来定义一个类的实现。父类的内部细节对子类可见。类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变被复用的实现。对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。</p><p><br></p><p>5、只根据抽象类中定义的接口来操纵对象有什么好处？ &nbsp;</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;1) 客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;2) 客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。</p><p><br></p><p>6、在MVC模型中M、V、C分别指什么？简述它们之间的关系？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;M：模型(Model)，V：视图(View)，C：控制Controller)。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;MVC模式的目的就是实现Web系统的职能分工。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;Model层实现系统中的业务逻辑，通常可以用JavaBean或EJB来实现。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;View层用于与用户的交互，通常用JSP来实现。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;Controller层是Model与View之间沟通的桥梁，它可以分派用户的请求并选择恰当的视图以用于显示，同时它也可以解释用户的输入并将它们映射为模型层可执行的操作。</p><p><br></p><p>7、什么是开闭原则？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;软件实体应当对扩展开放，对修改关闭，软件系统中包含的各种组件，例如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的，即不应该修改原有的代码。</p><p><br></p><p> </p><p><br></p><p>8、设计数据库的系统日志，要考虑使用哪些设计模式？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;命令模式，备忘录模式，外观模式</p><p><br></p><p>9、使用工厂模式的主要原因是什么？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;工厂模式定义：提供创建对象的接口。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p><p><br></p><p>10、在面向对象设计中，《编译原理》的有限状态机可以什么样解决方案完成？猫大叫一声，所有的老鼠都开始逃跑，主人被惊醒问：（1）设计可能用到什么设计模式？（2）画出其类图。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;观察者模式分析：要有联动性，老鼠和主人的行为是被动的；考虑可扩展性，猫的叫声可能引起其他联动效应。</p><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/02/168567962161015.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"/></p><p>11、单例模式的两种实现方法，并说明优缺点？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;懒汉式，在类被加载时，唯一的实例已经被创建。这个模式在java中很容易实现，在其他语言中很难。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;饿汉式，在类加载的时候不创建单例实体。只有在第一次请求实例的时候创建，并且只在第一次创建后不再创佳该类的实例。 </p><p><br></p><p> </p><p><br></p><p>12、什么是对象粒度？ &nbsp;</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;所谓的对象粒度就是对象从抽象到具体的描述的程度。同样一个系统，同样的需求。两个设计师给出两种设计。两个设计代码行数差不多，但是类的数目不同。例如有一个对象，我可以用10行代码去构造它，我也可以用20行代码，后者比前者更为精确。</p><p><br></p><p>13、MVC模式是个复合模式，请写出你两种你所知道的MVC中使用的模式。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p><p><br></p><p>14、举例说明，适配器模式和装配器在Java IO中的应用。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;装饰者模式：在由InputStream，OutputStream，Reader和Writer代表的等级结构内部，有一些流处理器可以对另一些流处理器起到装饰作用，形成新的，具有改善了的功能的流处理器。装饰者模式是Java I/O库的整体设计模式。这样的一个原则是符合装饰者模式的。</p><p><br></p><p> &nbsp; &nbsp; &nbsp; &nbsp;适配器模式：在由InputStream，OutputStream，Reader和Writer代表的等级结构内部，有一些流处理器是对其它类型的流源的适配。这就是适配器模式的应用，适配器模式应用到了原始流处理器的设计上面，构成了I/O库所有流处理器的起点。</p><p><br></p><p>15、在面向对象程序设计中，常常需要避免过多case语句或者if语句，请给出一种设计模式避免过多的条件分支语句，同时指出这种设计模式如何帮助避免过多的Case语句？</p><p><br></p><p> &nbsp; &nbsp; &nbsp; 访问者模式。例如 switch(pt){ case A: &nbsp; break; case B: break; ..... } &nbsp;</p><p><br></p><p> &nbsp; &nbsp; &nbsp; 把每个条件作成一个类，比如 A条件 &nbsp;class A { &nbsp;public void accept() {//处理逻辑 } }</p><p><br></p><p> &nbsp; &nbsp; &nbsp; 然后把每个条件的处理方法都用一个类来管理. &nbsp;public class CommonVisit</p>', '/public/uploads/2023/06/02/1685683516499433.jpg', '设计模式与软件体系解构', '期末考试题型汇总', '复习备用！！！', '设计模式', '其他', '2', '2023-06-02 12:26:18', '2023-06-02 12:26:18', 'U', 2);
INSERT INTO `blog_essay` VALUES (50, '<h3>1.请谈谈微信小程序主要目录和文件的作用？</h3><p>project.config.json：项目配置文件，用的最多的就是配置是否开启https校验</p><p>App.js：设置一些全局的基础数据等</p><p>App.json：底部tab，标题栏和路由等设置</p><p>App.wxss：公共样式，引入iconfont等</p><p>pages：里面包含一个个具体的页面</p><p>index.json：配置当前页面标题和引入组件</p><p>index.wxml：页面结构</p><p>index.wxss：页面样式表</p><p>index.js：页面的逻辑，请求和数据处理</p><h3>2.请谈谈wxml与标准的html的异同？</h3><p>都是用来描述页面的结构</p><p>都由标签，属性等构成</p><p>标签名字不一样，且小程序标签更少，单一标签更多</p><p>多了一些 wx:if 这样的属性以及{{}} 这样的表达式</p><p>WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览</p><p>组件封装不同，WXML对组件进行了重新封装</p><p>小程序运行在JS Core内，没有DOM树和windiw对象，小程序中无法使用window对象和document对象。</p><h3>3.请谈谈WXSS和CSS的异同？</h3><p>都是用来描述页面的样子</p><p>WXSS具有CSS大部分的特性，也做了一些扩充和修改</p><p>WXSS新增了尺寸单位，WXSS在底层支持新的尺寸单位rpx</p><p>WXSS仅支持部分CSS选择器</p><p>WXSS提供全局样式与局部样式</p><h3>4.你是怎么封装微信小程序的数据请求的？</h3><p>在根目录下创建util目录及api.js文件和apiConfig.js文件</p><p>在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等</p><p>在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出</p><p>在具体的页面中导入</p><p>或</p><p>将所有的接口放在统一的js文件中并导出</p><p>在app.js中创建封装请求数据的方法</p><p>在子页面中调用封装的请求数据</p><h3>5.小程序页面之间有哪些（传值）传递数据的方法？</h3><p>使用全局遍历实现数据传递</p><p>页面跳转或重定向时，使用url带参数传递数据</p><p>使用组件模板 template传递参数</p><p>使用缓存传递参数</p><p>使用数据库传递参数</p><p>或</p><p>给html元素添加data-*属性来传递值，然后通过e.currentTarget.dataset或onload的param参数获取（data- 名称不能有大写字母，不可以存放对象）</p><p>设置id 的方法标识来传值，通过e.currentTarget.id获取设置的id值，然后通过设置全局对象的方式来传递数据</p><p>在navigator中添加参数数值</p><h3>6.请谈谈小程序的双向绑定和vue的异同？</h3><p>大体相同，但小程序之间this.data的属性是不可以同步到视图的，必须调用this.setData()方法</p><p><br></p><h3>7.请谈谈小程序的生命周期函数</h3><p>onLoad()页面加载时触发，只会调用一次，可获取当前页面路径中的参数</p><p>onShow()页面显示/切入前台时候触发，一般用来发送数据请求</p><p>onReady()页面初次渲染完成时触发，只会调用一次，代表页面已可和视图层进行交互</p><p>onHide()页面隐藏/切入后台时触发，如底部tab切换到其他页面或小程序切入后台等</p><p>onUnload()页面卸载时触发，如redirectTO或navigateBack到其他页面时</p><h3>8.简述微信小程序原理</h3><p>小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；</p><p>它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现；</p><p>它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发；</p><p>功能可分为webview和APPService两个部分，webview主要用来展示UI，appservice用来处理业务逻辑，数据及接口调用，它们在两个进程中进行，通过系统层JSBridge实现通信，实现UI的渲染，事件处理；</p><p>webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；</p><p>两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。</p><p>javaScript的代码是运行在微信App中的，因此一些h5技术的应用需要微信APP提供对应的API支持</p><p>wxml 微信自己基于xml语法开发的，因此在开发时只能使用微信提供的现有标签，html的标签是无法使用的</p><p>wxss具有css的大部分特性，但并不是所有都支持，没有详细文档（wxss的图片引入需要使用外链地址，没有body，样式可以使用import导入）</p><h3>9.请谈谈原生开发小程序，wepy，mpvue的对比？</h3><p>个人认为，如果是新项目，且没有旧的 h5 项目迁移，则考虑用小程序原生开发，好处是相比于第三方框架，坑少。</p><p>而如果有 老的 h5 项目是 vue 开发 或者 也有 h5 项目也需要小程序开发，则比较适合 wepy 或者 mpvue 来做迁移或者开发，近期看wepy几乎不更新了，所以推荐美团的mpvue。</p><p>而如果如果团队前端强大，自己做一套框架也没问题。</p><h3>10.简单描述下微信小程序的 相关文件类型</h3><p>wxml 模板文件，是框架设计的一套标签预言，结合基础组件，事件系统，可以构建出页面的结构</p><p>wxss 样式文件，是一套样式语言，用于描述WXML的组件样式</p><p>js脚本逻辑文件。逻辑处理网络请求</p><p>json配置文件，小程序设置，如页面注册，页面标题及tabBar</p><p>app.json 整个小程序的全局配置，包括：</p><p><br></p><p>pages:[所有页面路径]</p><p><br></p><p>网络设置（网络超时事件）</p><p><br></p><p>页面表现（页面注册）</p><p><br></p><p>window：（背景色，导航样式，默认标题）</p><p><br></p><p>底部tab等</p><p><br></p><p>app.js 监听并处理小程序的生命周期函数，声明全局变量</p><p><br></p><p>app.wxss 全局配置的样式文件</p><p><br></p><h3>11.那些方法来提高微信小程序的应用速度？</h3><p><br></p><p>提高页面的加载速度</p><p>用户行为预测</p><p>减少默认的data的大小</p><p>组件化方案</p><p><br></p><h3>12.分析微信小程序的优劣势？</h3><p><br></p><p>优势：</p><p><br></p><p>容易上手，基础组件库比较全，基本不需要考虑兼容问题</p><p>开发文档比较完善，开发社区比较活跃，支持插件式开发</p><p>良好的用户体验，无需下载，通过搜索和扫一扫就可以打开，打开速度快，安卓上可以添加到桌面，与原生APP差不多</p><p>开发成本比APP要低</p><p>为用户提供良好的保障（小程序发布，严格是审查流程）</p><p>劣势：</p><p><br></p><p>限制较多，页面大小不能超过1M，不能打开超过5个层级的页面</p><p>样式单一，部分组件已经是成型的，样式不可修改，例如：幻灯片，导航</p><p>推广面窄，不能分享朋友圈，只能通过分享给朋友，附加小程序推广</p><p>依托与微信，无法开发后台管理功能</p><p>后台调试麻烦，因为api接口必须https请求且公网地址</p><p>真机测试，个别安卓和苹果表现迥异，例如安卓的定位功能加载很慢</p><p><br></p><h3>13.微信小程序和H5的区别？</h3><p><br></p><p>运行环境不同（小程序在微信运行，h5在浏览器运行）</p><p>开发成本不同（h5需要兼容不同的浏览器）</p><p>获取系统权限不同（系统级权限可以和小程序无缝衔接）</p><p>应用在生成环境的运行速度流程（h5需不断对项目优化来提高用户体验）</p><p><br></p><h3 style=\"text-align: start;\">14.怎么解决微信小程序的异步请求问题？</h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">在回调函数中调用下一个组件的函数</p><p style=\"text-align: start;\"><br></p><pre><code >app.js\n\nsuccess:function(info){\n   that.apirtnCallback(info)\n}\n\nindex.js\n\nonLoad:function(){\n   app.apirtnCallback = res =&gt;{\n    console.log(res)\n    }\n\n}</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><br></p>', '/public/uploads/2023/06/05/1685967167041797.png', '微信小程序面试（上）', '微信小程序', '小程序面试题目', '微信小程序,面试', '其他', '2', '2023-06-05 20:12:47', '2023-06-05 20:12:47', 'I', 1);
INSERT INTO `blog_essay` VALUES (51, '<h3>15.小程序关联微信公众号如何确定用户的唯一性？</h3><p><br></p><p>使用wx.getUserlnfo方法 withCredentials为true时，可获取encryptedData，里面有union_id，后端需要进行对称解密</p><p><br></p><h3>16.使用webview直接加载要注意那些事项？</h3><p><br></p><p>必须要在小程序后台使用管理员添加业务域名</p><p>h5页面跳转至小程序的脚步必须是1.3.1以上</p><p>微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上</p><p>h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的</p><p><br></p><h3>17.小程序调用后台接口遇到那些问题？</h3><p><br></p><p>数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序</p><p>小程序不可以直接渲染文章内容这类型的html文本，显示需要借助插件</p><p>注：插件渲染会导致页面加载变慢，建议在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签，然后其他的标签让插件来做</p><p><br></p><h3>18.微信小程序如何实现下拉刷新？</h3><p><br></p><p>用view代替scroll-view，设置onPullDownRefresh函数实现</p><p><br></p><h3>19.webview中的页面怎么跳转回小程序</h3><p><br></p><pre><code class=\"language-javascript\">wx.miniProgram.navigateTo({\n    url:\'pages/login/login\'+\'$params\'\n})\n//跳转到小程序导航页面\nwx.miniProgram.switchTab({\n    url:\'/pages/index/index\'\n})</code></pre><h3>20.bindtap和catchtap的区别？</h3><p>bind事件绑定不会阻止冒泡事件向上冒泡</p><p>catch事件绑定可以阻止冒泡事件向上冒泡</p><p>21.简述wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？</p><p>在wxml页面中：跳转新页面，在当前页打开，切换到首页Tab</p><p>在js页面中：分为应用内的页面，和tabBar页面</p><p>如果上述跳转遇到跳转失败或者无效的问题，请访问：wx.navigateTo/wx.redirectTo无效</p><p><br></p><h3>22.小程序和Vue写法的区别？</h3><p><br></p><p>遍历的时候：小程序wx:for=“list”,而Vue是v-for=“item in list”</p><p>调用data模型（赋值）的时候：</p><p><br></p><p>小程序：this.data.item // 调用，this.setDate({item:1})//赋值</p><p><br></p><p>Vue：this.item //调用，this.item=1 //赋值</p><p><br></p><h3>23.小程序的发布流程（开发流程）</h3><p>参考：https://www.cnblogs.com/ssrstm/p/6855572.html</p><p>注册微信小程序账号</p><p>获取微信小程序的AppID</p><p>下载微信小程序开发者工具</p><p>创建demo项目</p><p>去微信公众号配置域名</p><p>手机浏览</p><p>代码上传</p><p>提交审核</p><p>小程序发布</p><p><br></p><h3>24.webview中的页面怎么跳回小程序中？</h3><p><br></p><p>首先，需要在你的html页面中引用一个js文件</p><p><br></p><pre><code class=\"language-javascript\">&lt;script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.0.js\"&gt;&lt;/script&gt;\n//然后为你的按钮标签注册一个点击事件\n$(\".kaiqi\").click(function(){\n        wx.miniProgram.redirectTo({url: \'/pages/indexTwo/indexTwo\'})\n});\n// 这里的redirectTo跟小程序的wx.redirectTo()跳转页面是一样的，\n会关闭当前跳转到页面，换成navigateTo，跳转页面就不会关闭当前页面</code></pre><h3>25.小程序授权登录流程</h3><p><br></p><p>（授权，微信登录获取code，微信登录，获取iv , encryptedData 传到服务器后台，如果没有注册，需要注册。）</p><p><br></p><h3>26.小程序支付如何实现？</h3><p><br></p><p>小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限</p><p>绑定商户号</p><p>在小程序填写合法域</p><p>调用wx.login()获取appid</p><p>调用</p><pre><code >wx.requestPayment(\n{\n    \'timeStamp\': \'\',//时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间\n    \'nonceStr\': \'\',//随机字符串，长度为32个字符以下。\n    \'package\': \'\',//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*\n    \'signType\': \'MD5\',//签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致\n    \'paySign\': \'\',//签名,具体签名方案参见微信公众号支付帮助文档;\n    \'success\':function(res){},//成功回调\n    \'fail\':function(res){},//失败\n    \'complete\':function(res){}//接口调用结束的回调函数（调用成功、失败都会执行）\n})</code></pre><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/05/1685967413037803.png\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p><p><br></p><p>————————————————</p><p>版权声明：本文为CSDN博主「心动的偏执」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：https://blog.csdn.net/m0_67390963/article/details/125402336</p>', '/public/uploads/2023/06/05/1685967500479118.jpg', '微信小程序面试（下）', '微信小程序', '微信小程序面试题', '微信小程序,面试', '其他', '2', '2023-06-05 20:18:20', '2023-06-05 20:18:20', 'I', 1);
INSERT INTO `blog_essay` VALUES (52, '<p><br></p><p style=\"text-align: start;\"><span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px;\"><code>reduce()</code></span><span style=\"font-size: 16px;\">函数是一种非常强大的数组（或列表）归约函数，可以将数组或列表的所有元素累计为单个值。</span><span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px;\"><code>reduce()</code></span><span style=\"font-size: 16px;\">函数需要一个归约函数作为参数，该函数接收两个参数：累加器和当前值。归约函数执行时，它对累加器和当前值进行固定的操作，然后返回结果，该结果再被作为累加器传递给下一个元素。</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05); font-size: 16px;\"><code>reduce()</code></span><span style=\"font-size: 16px;\">函数的语法如下：</span></p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code>array.reduce(callback[, initialValue])</code></pre><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">参数说明：</p><ul><li style=\"text-align: start;\">callback是归约函数，该函数接收四个参数：accumulator：累加器，包含归约过程的当前结果。currentValue：当前值，处理的现在的元素。index：当前元素在数组中的索引。array：调用 reduce() 方法的数组（或列表）。归约函数必须始终 return 一个值。</li><li style=\"text-align: start;\">initialValue是归约的初始值。如果提供了一个初始值，累加器将从初始值开始累加。如果没有提供初始值，reduce()方法将从数组的第一个元素开始执行，略过第一个元素作为初始累加器的值。</li></ul><p style=\"text-align: start;\">下面是一个使用<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>reduce()</code></span>计算数组所有元素之和的例子：</p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code>const arr = [1, 2, 3, 4, 5];\nconst sum = arr.reduce((accumulator, currentValue) =&gt; accumulator + currentValue);\nconsole.log(sum); // 15\n\n</code></pre><p style=\"text-align: start;\">在这个例子中，我们首先定义了一个数组<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>arr</code></span>，然后使用<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>reduce()</code></span>方法将它的所有元素相加起来，得到结果15。</p><p style=\"text-align: start;\">需要注意的是，累加器并不一定是数字类型，结果也不一定是一个值。例如有一个数组中有多个对象，每个对象代表一件商品，使用<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>reduce()</code></span>方法可以计算总共的价格：</p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code>const items = [\n  { name: \'T-shirt\', price: 100 },\n  { name: \'Jeans\', price: 200 },\n  { name: \'Shoes\', price: 300 }\n];\n\nconst total = items.reduce((accumulator, currentValue) =&gt; accumulator + currentValue.price, 0);\n\nconsole.log(total); // 600\n\n</code></pre><p style=\"text-align: start;\">在这个例子中，我们首先定义了一个商品数组<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>items</code></span>，每个元素是一个包含商品名称和价格的对象。我们使用<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>reduce()</code></span>方法计算了所有商品价格的总和，得到结果为600。</p><p><br></p>', '/public/uploads/2023/06/24/1687585787762634.jpeg', 'reduce()', '归约函数', '', 'js', 'JS', '1', '2023-06-24 13:49:47', '2023-06-24 13:49:47', 'I', 1);
INSERT INTO `blog_essay` VALUES (53, '<h2 style=\"text-align: center; line-height: 2;\"><span style=\"color: rgb(60, 112, 198);\">一面</span></h2><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>1、项目问题，深挖细节，说几个做过的项目中，你觉得比较复杂的功能【描述】</strong></h3><p><br></p><p> <a href=\"http://116.62.179.162/#/aboutme\" target=\"_blank\">http://116.62.179.162/#/aboutme</a> </p><p><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>3、打包结果优化，具体做了哪些优化【描述】【举例】</strong></h3><p><br></p><ol><li style=\"line-height: 2;\">代码压缩：使用工具（如UglifyJS、Terser等）对代码进行压缩，去除不必要的字符和空格，减小代码体积。</li><li style=\"line-height: 2;\">摇树优化（Tree Shaking）：使用工具（如Webpack、Rollup等）在打包过程中，自动移除未使用的代码，减少最终打包结果的大小。</li><li style=\"line-height: 2;\">按需加载（Code Splitting）：将代码拆分成多个模块，并根据需要动态地加载这些模块，减少初始加载时的代码量，提高页面加载速度。</li><li style=\"line-height: 2;\">图片优化：对图片进行压缩和优化，如使用适当的图片格式、调整图像质量、大小等，减小图片文件的体积。</li><li style=\"line-height: 2;\">缓存优化：利用浏览器缓存机制，通过设置适当的缓存策略，让已加载的资源可以被长时间复用，减少重复加载的开销。</li><li style=\"line-height: 2;\">懒加载：延迟加载页面上不可见的部分，如图片、内容等，当用户滚动到可见区域时再加载，减少初始加载时需要请求的资源量。</li></ol><p style=\"line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>4、vue 中 beforeCreate 和 created 的区别【描述】</strong></h3><p style=\"text-align: left;\"><br></p><p style=\"text-align: left;\"><span style=\"font-size: 16px;\">beforeCreate:数据初始化之前，</span><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">此时该实例还没有完成初始化，因此也就无法访问到组件中的 data、computed 等属性值和方法。一般情况下，我们可以使用 beforeCreate 进行一些数据初始化、事件的监听等操作。</span></p><p style=\"text-align: left;\"><br></p><p style=\"text-align: left;\"><span style=\"font-size: 16px;\">created:数据初始化之后，</span><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">此时组件已经可以访问到 data、computed 等属性值和方法了，因此也可以在此阶段进行一些组件的数据初始化、接口调用等操作</span></p><p><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>5、vue 中用过哪些修饰器？【举例】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>事件修饰符<br>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive</p><p style=\"text-align: left; line-height: 2;\">按键修饰符<br>.enter<br>.tab<br>.delete (捕获“删除”和“退格”键)<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right</p><p style=\"text-align: left; line-height: 2;\">其他常用的修饰符<br>.trim<br>.number<br>.lazy<br>.sync</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>6、vue 中 computed 和 watch 的区别【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><p style=\"text-align: left;\">computed（计算属性）：</p><p style=\"text-align: left;\">1，监听值未在data中定义，以return返回值形式；</p><p style=\"text-align: left;\">2，计算属性的值会被缓存，只有实例中相关依赖值改变时，才重新计算，性能好但不适合做异步请求；</p><p style=\"text-align: left;\">3，计算属性默认只有get来读取，手动修改计算属性时，会触发手写的set函数。</p><p style=\"text-align: left;\"><br></p><p style=\"text-align: left;\">watch(监听器）：</p><p style=\"text-align: left;\">1，监听值要在data中先定义，可以不写return返回值；</p><p style=\"text-align: left;\">2，不支持缓存，可以做异步操作；</p><p style=\"text-align: left;\">3，监听值改变，回调函数自动调用。</p><p style=\"text-align: left;\"><br></p><p style=\"text-align: left; line-height: 2;\">用官网的一句话来说，所有需要用到计算的都应该使用计算属性。多条数据影响一条数据时使用计算属性，使用场景购物车。</p><p style=\"text-align: left; line-height: 2;\">如果是一条数据更改，影响多条数据时，使用watch，使用场景搜索框。</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>7、vue 中 key 的作用是什么？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>Key 的作用：</p><p style=\"text-align: left; line-height: 2;\"><span style=\"color: rgba(0, 0, 0, 0.75); background-color: rgb(255, 255, 255); font-size: 16px;\">给每个dom元素加上key作为唯一标识 ，diff算法可以正确的识别这个节点，使页面渲染更加迅速。</span></p><p style=\"text-align: left; line-height: 2;\"><br>设置 Key 的好处：<br>（1）数据更新时，可以尽可能的减少DOM操作；<br>（2）列表渲染时，可以提高列表渲染的效率，提高页面的性能；</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>8、比如，在 v-for 时写了 key ，将第二个元素和第三个元素交换了顺序，实际的 diff 算法怎样的【描述】</strong></h3><p style=\"text-align: start; line-height: 2;\">下面是一个示例，展示当交换第二个元素和第三个元素的顺序时，Vue.js 的 diff 算法如何工作：</p><p style=\"text-align: start; line-height: 2;\">假设原始的列表项为：<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>[A, B, C, D, E]</code></span>，并且 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>key</code></span> 的值分别为 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>1, 2, 3, 4, 5</code></span>。</p><ol><li style=\"text-align: start; line-height: 2;\">交换第二个元素和第三个元素的顺序后的列表项为：<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>[A, C, B, D, E]</code></span>。</li><li style=\"text-align: start; line-height: 2;\">Vue.js 遍历新旧列表项，首先比较第一个元素 A，key 值匹配。</li><li style=\"text-align: start; line-height: 2;\">然后，比较第二个元素 C，Vue.js 发现 key 值不匹配，意味着需要移动该元素。</li><li style=\"text-align: start; line-height: 2;\">Vue.js 通过查找旧列表中的相同 key 值，定位到原来的 B 元素，并将其移动到正确的位置。</li><li style=\"text-align: start; line-height: 2;\">比较第三个元素 B，Vue.js 发现 key 值匹配，不需要更新。</li><li style=\"text-align: start; line-height: 2;\">继续比较后续元素 D 和 E，均没有发生变化。</li><li style=\"text-align: start; line-height: 2;\">最后，Vue.js 移除多余的旧节点，也就是原来在新列表中不存在的元素。</li></ol><p style=\"text-align: start;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>9、有没有做过组件的抽离和组件库的开发？具体做了什么工作【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>10、内部组件库，怎么本地开发和调试？怎么上线？本地调试有哪些方式【描述】【举例】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>11、聊一聊浏览器的渲染机制，浏览器是怎么解析和渲染html的？【描述】</strong></h3><p><br></p><ol><li style=\"text-align: start; line-height: 2;\">构建DOM树：浏览器首先将接收到的 HTML 文档解析为树状结构，即DOM（Document Object Model）树。解析器会逐个读取 HTML 标记，并构建一个包含所有标记和其层次结构的树形数据结构。</li><li style=\"text-align: start; line-height: 2;\">解析CSS：浏览器会解析文档中的样式表（内部样式表、外部样式表、内联样式），并计算出每个元素的最终样式。解析的过程包括词法分析、语法分析、构建样式规则和计算样式值等。</li><li style=\"text-align: start; line-height: 2;\">构建渲染树：在构建渲染树（Render Tree）的过程中，浏览器会将 DOM 树中的元素与计算好的样式结合，生成一棵用于渲染的树。渲染树仅包含需要显示的元素，并且每个元素都与其对应的样式信息关联。</li><li style=\"text-align: start; line-height: 2;\">合成和显示：最后，浏览器会将绘制好的位图和其他相关信息交给操作系统和硬件，进行合成（Composition）和显示（Display）操作。这样，页面的最终图像就会显示在用户的屏幕上。</li></ol><p style=\"text-align: start; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>12、js 异步加载的方式？defer 和 async 的区别？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>（1）defer 是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>（2）async 是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>13、重定向的状态码有哪些？它们的区别是什么？【描述】【举例】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>14、https 相较 http ，是怎么体现安全性的？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>http: 超文本传输协议(Hypertext Transfer Protocol)，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），它是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。<br>https 的全称是 Hypertext Transfer Protocol Secure , 它用来在计算机网络上的两个端系统之间进行安全的交换信息(secure communication). HTTPS 是 HTTP 协议的一种扩展，它本身并不保证传输的安全性，那么谁来保证安全性呢？在 HTTPS 中，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。<br>（TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本，它们是用于在互联网两台计算机之间用于身份验证和加密的一种协议。）</p><p style=\"text-align: left; line-height: 2;\"><br><strong>http 和 https 的区别</strong></p><p style=\"text-align: left; line-height: 2;\"><br></p><ul><li style=\"text-align: left; line-height: 2;\">https 协议需要 ca 证书，费用较高</li><li style=\"text-align: left; line-height: 2;\">http 数据信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li><li style=\"text-align: left; line-height: 2;\">使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80 , https 的端口为 443</li><li style=\"text-align: left; line-height: 2;\">http 的连接很简单，是无状态的；https 协议是由 http + ssl 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</li><li style=\"text-align: left; line-height: 2;\"></li></ul><h3 style=\"text-align: left; line-height: 2;\"><strong>15、https 证书的作用是什么？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>CA 的全称是 Certificate Authority，证书认证机构，你必须让 CA 颁布具有认证过的公钥，才能解决公钥的信任问题。</p><p style=\"text-align: left; line-height: 2;\">存在一个数字签名的认证问题。因为私钥是自己的，公钥是谁都可以发布，所以必须发布经过认证的公钥，才能解决公钥的信任问题。</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>16、讲一下js原型链【描述】</strong></h3><p><br></p><p style=\"text-align: left; line-height: 2;\"> <a href=\"http://116.62.179.162/#/note/essay?id=28\" target=\"_blank\">http://116.62.179.162/#/note/essay?id=28</a> </p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>17、讲一下闭包？实际开发中有什么应用？【描述】【举例】</strong></h3><p><br></p><p style=\"text-align: left; line-height: 2;\"> <a href=\"http://116.62.179.162/#/note/essay?id=28\" target=\"_blank\">http://116.62.179.162/#/note/essay?id=28</a> </p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>18、flex 布局相关都有哪些属性？含义是什么？flex 属性对应哪几个属性【描述】</strong></h3><ol><li style=\"text-align: start; line-height: 2.5;\">display: flex;：将一个容器元素设置为Flex容器。</li><li style=\"text-align: start; line-height: 2.5;\">flex-direction。</li><li style=\"text-align: start; line-height: 2.5;\">flex-wrap: nowrap | wrap | wrap-reverse。</li><li style=\"text-align: start; line-height: 2.5;\">flex-flow: 是flex-direction和flex-wrap的简写形式。例如，flex-flow: row wrap; 表示水平方向从左到右排列，并在需要时换行。</li><li style=\"text-align: start; line-height: 2.5;\">justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;：指定Flex容器中项目在主轴上的对齐方式。默认为flex-start，表示起点对齐。</li><li style=\"text-align: start; line-height: 2.5;\">align-items: flex-start | flex-end | center | baseline | stretch;：定义Flex容器中项目在交叉轴上的对齐方式。默认为stretch，表示拉伸填充容器。</li><li style=\"text-align: start; line-height: 2.5;\">align-content: flex-start | flex-end | center | space-between | space-around | stretch;：指定多行Flex容器在交叉轴上的对齐方式。默认为stretch，表示拉伸填充容器。</li><li style=\"text-align: start; line-height: 2.5;\">flex：1 ：自动分配剩余宽度</li></ol><p style=\"text-align: start; line-height: 2.5;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>19、flex-grow 和 flex-shrink 代表什么含义【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>20、CommonJS 与 ESModule 的区别【描述】</strong></h3><p style=\"line-height: 2.5;\"><br></p><p style=\"line-height: 2.5;\">CommonJS（通常简写为CJS）和ESModule（通常简写为ESM）是两种不同的模块化系统，用于在JavaScript中组织和导入/导出代码。</p><ol><li style=\"line-height: 2.5;\">语法差异：CommonJS使用 require() 导入模块，使用 module.exports 或 exports 导出模块。ESModule使用 import 导入模块，使用 export 导出模块。</li><li style=\"line-height: 2.5;\">动态 vs 静态导入/导出：CommonJS模块是动态的，在运行时导入和导出。导入的值被复制到一个变量中，后续的修改不会影响原始导出的值。ESModule是静态的，在解析阶段确定所有导入和导出。导入的值是实时绑定，对导入的模块的修改会反映在导入的值上。</li></ol><p><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>21、Tree-shaking 原理【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><p style=\"text-align: start; line-height: 2.5;\">Tree-shaking是一种在打包过程中消除未使用代码的优化技术，它可以显著减小最终的构建文件大小。</p><p style=\"text-align: start; line-height: 2.5;\">原理如下：</p><ol><li style=\"text-align: start; line-height: 2.5;\">静态分析：Tree-shaking通过静态分析源码来确定哪些代码片段被使用，哪些被标记为未使用。它会对每个模块进行分析，并构建模块之间的依赖关系图。</li><li style=\"text-align: start; line-height: 2.5;\">标记未使用的代码：根据静态分析的结果，Tree-shaking会标记模块中未被使用的部分代码。</li><li style=\"text-align: start; line-height: 2.5;\">无副作用的剪枝：Tree-shaking会移除被标记为未使用的代码，包括函数、变量、类、模块导出等。但要注意，如果被标记的代码存在副作用（比如修改全局变量、操作IO等），那么这部分代码可能无法被移除，以保证程序的正确执行。</li><li style=\"text-align: start; line-height: 2.5;\">代码块合并：Tree-shaking会合并和打包仅使用的代码块，从而优化整体构建结果。</li></ol><p style=\"text-align: start;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>22、ESModule 模块化是怎么解决循环引用的问题的【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>参考 https://es6.ruanyifeng.com/#docs/module-loader#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>23、你对 react 怎么看待？【描述】</strong></h3><p><br></p><ol><li style=\"text-align: start; line-height: 2;\">组件化开发：React 强调组件化开发，通过将 UI 分解为独立且可复用的组件，使得构建复杂 UI 变得更加直观和模块化。这种组件化的开发方式使得代码的可维护性和可重用性大大提高。</li><li style=\"text-align: start; line-height: 2;\">虚拟 DOM：React 使用虚拟 DOM（Virtual DOM）来管理和更新实际的 DOM。React 会在内存中构建一个虚拟表示，通过对比前后两个虚拟 DOM，只更新需要改变的部分，从而提高性能和效率。</li><li style=\"text-align: start; line-height: 2;\">单向数据流：React 使用单向数据流来管理组件的状态和数据流动。这种单向的数据流动模型使得数据流动更可控和明确，方便进行状态管理和数据处理。</li></ol><p style=\"text-align: start; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>24、你是通过什么手段去学习前端技术的？【描述】</strong></h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\">1. 习惯性浏览博客网站，例如掘金，csdn</p><p style=\"line-height: 2;\">2. 视频跟学，像bilibili，跟着视频完成特定的项目</p><p style=\"line-height: 2;\">3. github参考一些优秀源码，例如elementUI源码</p><p style=\"line-height: 2;\">4. 多参加活动，认识技术大牛，从中学习，比如字节的青训营，学校的软件设计赛等等。</p><p style=\"text-align: left; line-height: 2;\"><br></p><h2 style=\"text-align: left; line-height: 2;\"><span style=\"color: rgb(60, 112, 198);\"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;二面</span></h2><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>1、最近在学习什么新技术？Vue3.0做了哪些优化【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><ol><li style=\"text-align: start; line-height: 2.5;\">更快的渲染性能：Vue 3.0采用了重新设计的响应式系统，使用Proxy代理对象替代了传统的Object.defineProperty，使得侦听属性变更的性能得到显著提升。此外，Vue 3.0还引入了静态树提升（Static Tree Hoisting）和一些编译时的优化，通过减少运行时的节点操作，进一步加快了组件的渲染速度。</li><li style=\"text-align: start; line-height: 2.5;\">更小的包体积：Vue 3.0采用了模块化的架构，将Vue的核心库和各个功能模块拆分成了更小的片段。这使得开发者在使用Vue时只需引入需要的功能，减小了包的体积。</li><li style=\"text-align: start; line-height: 2.5;\">更好的 TypeScript 支持：Vue 3.0对 TypeScript 提供了更好的支持，对类型推断进行了改进，提供了更好的类型检查和更准确的代码提示。</li></ol><p style=\"text-align: start; line-height: 2.5;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>2、说一个你做过印象最深刻的项目【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><h3 style=\"text-align: left; line-height: 2;\"><strong>3、对于首屏加速，你有哪些方案【描述】</strong></h3><p style=\"text-align: start;\"><br></p><ol><li style=\"text-align: start; line-height: 2;\">代码优化：通过压缩和混淆 JavaScript、CSS 和 HTML 代码来减小文件大小，使用图片压缩和懒加载来减少图片的加载大小。</li><li style=\"text-align: start; line-height: 2;\">按需加载：将页面划分为多个模块，并在页面加载时仅加载当前可见区域的模块，延迟加载其他模块，从而减少初始的网络请求和资源加载。</li><li style=\"text-align: start; line-height: 2;\">缓存策略：使用浏览器缓存机制来缓存静态资源，以便在后续的访问中可以直接从缓存中获取资源，减少网络请求和提高加载速度。</li><li style=\"text-align: start; line-height: 2;\">使用CDN加速：将静态资源部署到内容分发网络（CDN）上，以实现全球分布和就近访问，从而提高内容的传输速度和减少延迟。</li><li style=\"text-align: start; line-height: 2;\">预加载和预渲染：通过使用 &lt;link rel=\"preload\"&gt; 标签来预加载关键资源，或者使用服务器端渲染（SSR）或静态站点生成器（如Gatsby、Next.js）来预渲染页面，可以减少客户端的工作量和提高首屏加载速度。</li></ol><p><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>4、路由懒加载有哪些方式【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><p style=\"text-align: start;\">路由懒加载是一种优化技术，用于在需要时异步加载路由组件，以减小初始加载的文件大小和提升应用性能。在Vue中，有以下几种方式可以实现路由懒加载：</p><ol><li style=\"text-align: start;\">使用动态导入（Dynamic Import）：这是最常见和推荐的方式。通过将组件的导入语句改为动态导入，可以使用Webpack等构建工具将组件作为单独的异步块进行打包。例如：</li></ol><pre style=\"text-align: left;\"><code>const Home = () =&gt; import(\'./components/Home.vue\');\nconst About = () =&gt; import(\'./components/About.vue\');</code></pre><ol><li style=\"text-align: start;\">结合Vue的<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>lazy</code></span>函数：Vue 2.6+版本引入了<span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>lazy</code></span>函数，可以直接在路由配置中使用。这种方式相比于动态导入更为简洁，但需要依赖Vue的内置函数。例如：</li></ol><pre style=\"text-align: left;\"><code>import { createRouter, createWebHistory } from \'vue\';\n\nconst router = createRouter({\n  history: createWebHistory(),\n  \n  routes: [\n    {\n      path: \'/\',\n      component: () =&gt; import(\'./components/Home.vue\')\n    },\n    {\n      path: \'/about\',\n      component: () =&gt; import(\'./components/About.vue\')\n    }\n  ]\n});</code></pre><p style=\"text-align: left; line-height: 2;\"><br></p><p style=\"text-align: start;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>5、说一下你对模块化的理解，CommonJS 和 ESModule 有什么区别？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><ul><li style=\"text-align: left; line-height: 2;\">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li style=\"text-align: left; line-height: 2;\">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li style=\"text-align: left; line-height: 2;\">CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。</li></ul><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>6、打包结果里面出现重复包的情况，怎么解决【描述】</strong></h3><p><br></p><ol><li style=\"text-align: start; line-height: 2.5;\">依赖版本统一：检查项目中使用的依赖项，并确保它们的版本是一致的。通过更新或降级依赖项的版本，将它们统一为相同的版本，可以减少重复包的潜在冲突。</li><li style=\"text-align: start; line-height: 2.5;\">删除重复依赖：查找项目中重复依赖的包，并将其中的重复部分删除。可以通过检查项目的package.json文件或构建工具生成的依赖图表（dependency graph）来识别重复的依赖。</li><li style=\"text-align: start; line-height: 2.5;\">引入Tree-shaking：通过使用支持Tree-shaking的构建工具和使用ES6模块语法，可以在打包过程中剔除未使用的代码和依赖，从而减少输出中的重复包。</li><li style=\"text-align: start; line-height: 2.5;\">使用代码分割（Code Splitting）：将应用程序的代码拆分为多个块，只加载需要的模块。这样可以最大程度地减少重复包的存在，并提高应用的加载性能。</li><li style=\"text-align: start; line-height: 2.5;\">检查依赖的引入方式：确保项目中正确引入依赖项，避免重复引入同一包。例如，在Vue.js中，可以使用Vue Router的路由懒加载方式，避免重复加载同一个组件</li></ol><p><br></p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>7、有哪些手段可以加快 webpack 打包速度【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><ul><li style=\"text-align: left; line-height: 2;\">使用高版本的webpack (使用webpack4)</li><li style=\"text-align: left; line-height: 2;\">多线程/多实例构建：HappyPack(不维护了) thread-loader</li><li style=\"text-align: left; line-height: 2;\">缩小打包作用域</li><li style=\"text-align: left; line-height: 2;\">充分利用缓存提升二次构建速度</li><li style=\"text-align: left; line-height: 2;\">DLLPlugin 提前打包、分包，避免反复编译浪费时间</li></ul><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>8、移动端开发，是怎么适配的？有没有办法在打包时将 px 转换为 rem【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><ol><li style=\"text-align: start; line-height: 2;\">使用媒体查询和弹性布局：通过使用CSS媒体查询和弹性布局（Flexbox和Grid）等技术，可以基于设备的屏幕尺寸和方向来调整布局和元素的排列方式。这样可以确保页面的布局在不同的设备上适配自然。</li><li style=\"text-align: start; line-height: 2;\">使用相对单位：在移动端开发中，推荐使用相对单位（如百分比和rem）而不是固定单位（如像素px）。相对单位可以根据设备的屏幕尺寸进行自适应，从而实现适配。其中，rem单位是根据根元素的字体大小来计算的，可以方便地进行适配。</li></ol><p style=\"text-align: start; line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 14px;\">关于将px转换为rem的打包方式，可以通过构建工具的插件或loader来实现。例如，在Webpack中可以使用</span>px2rem-loader<span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 14px;\">来将样式文件中的像素值自动转换为rem值。</span></p><p style=\"text-align: start; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>9、描述一下 Vue 中 template 模板编译的过程【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2.5;\"></h3><ol><li style=\"text-align: start; line-height: 2.5;\">解析：将template模板解析成抽象语法树（AST，Abstract Syntax Tree），通过AST可以更方便地对模板进行分析和修改。解析过程使用了HTML解析器和指令解析器。</li><li style=\"text-align: start; line-height: 2.5;\">代码生成：将抽象语法树转换为渲染函数（render function），渲染函数是一个JavaScript函数，用于生成VNode（虚拟DOM节点）。静态节点会被生成为静态的渲染代码；动态节点会根据不同的情况生成相应的渲染代码，例如对表达式进行求值、属性绑定、事件绑定等。</li><li style=\"text-align: start; line-height: 2.5;\">返回渲染函数：最终，编译过程会返回一个渲染函数，该函数接收一个用于生成VNode的h函数，并返回一个VNode。</li></ol><p style=\"text-align: start; line-height: 2.5;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>10、说下 vue-router 的实现原理【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><ol><li style=\"text-align: start; line-height: 2;\">路由配置：在创建 Vue Router 实例时，需要配置路由规则。我们可以定义不同的路由规则，包括路径、组件和路由参数等。</li><li style=\"text-align: start; line-height: 2;\">路由映射：Vue Router 在初始化时会根据路由配置生成一张路由映射表，将路径和对应的组件进行映射关联。这样，当路径发生变化时，Vue Router 就能找到对应的组件。</li><li style=\"text-align: start; line-height: 2;\">监听 URL 变化：Vue Router 通过监听浏览器的 URL 变化，使用了 HTML5 的 history API（包括 pushState 和 replaceState），或者使用 hash 模式(hashchange 事件)，来检测 URL 的变化。</li><li style=\"text-align: start; line-height: 2;\">路由跳转：Vue Router 提供了一系列的方法，如 push 和 replace 方法，用于编程式地进行路由跳转。在跳转时，会更新 URL，触发导航守卫，并根据新的 URL 找到相应的组件进行渲染。</li></ol><p style=\"text-align: start; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>11、有没有方案，当 history.pushState 改变了浏览器地址栏后，监听到地址改变【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>- 利用观察者模式<br>- 重写 history 方法，并添加 window.addHistoryListener 事件机制</p><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>12、你觉得怎样才算是一个高标准的组件库【描述】</strong></h3><h3 style=\"text-align: left; line-height: 2;\"></h3><p><span style=\"font-size: 16px;\">功能完整且易上手</span></p><p><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">良好的性能表现：组件渲染，动画流畅度等等</span></p><p><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">兼容性：</span></p><ol><li style=\"text-align: start;\"><span style=\"font-size: 16px;\">使用现代 Web 技术和标准：在开发组件库时，尽可能使用符合当前 Web 标准的技术和语法。避免使用已经过时或不推荐的API和特性，以确保在各种浏览器中的良好兼容性。</span></li><li style=\"text-align: start;\"><span style=\"font-size: 16px;\">适配并测试多个浏览器：在开发过程中，使用跨浏览器测试工具（如BrowserStack、Selenium等）或者手动测试，对你的组件库在目标浏览器中进行测试和调试。确保组件在不同浏览器中都具有良好的显示和交互效果。</span></li></ol><p><br></p><p><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">高度可定制性：组件库应该提供丰富的配置选项和扩展点</span></p><p><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">规范一致性：组件的风格和规范应该一致</span></p><p><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>13、组件库的文档是怎么开发的？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br></p><ol><li style=\"text-align: start; line-height: 2;\">选择文档生成工具：选择适合的文档生成工具，常见的选择包括 VuePress、Docusaurus、Docz等。</li><li style=\"text-align: start; line-height: 2;\">编写文档源文件：使用选定的文档生成工具提供的语法，编写组件库的文档源文件。</li><li style=\"text-align: start; line-height: 2;\">配置文档生成工具：根据文档生成工具的官方文档，进行相应的配置,例如tab栏，路由跳转，首页的样式等等。</li><li style=\"text-align: start; line-height: 2;\">提供示例代码：为了更好地演示组件的用法，文档通常会提供示例代码，展示组件的不同使用场景。示例代码可以包含HTML、CSS和JavaScript代码，并配合说明和截图。</li><li style=\"text-align: start; line-height: 2;\">安装和使用指南：为了让用户能够顺利使用组件库，文档中应该提供安装和使用指南，包括安装依赖、导入组件、调用API等步骤的详细说明。</li></ol><p style=\"text-align: left; line-height: 2;\"><br></p><h3 style=\"text-align: left; line-height: 2;\"><strong>14、组件库怎么进行本地开发调试？【描述】</strong></h3><p style=\"text-align: left; line-height: 2;\"><br>（1）本地写demo<br>（2）本地编译，拷贝到业务系统，替换 node_module 下的静态资源进行测试<br><strong>15、求实现：有个请求，10秒内可以重试3次，如果3次都失败，就抛出异常【伪代码】</strong></p><p style=\"text-align: left; line-height: 2;\"><br></p><ol><li style=\"text-align: start; line-height: 2;\">设置最大重试次数和重试间隔：设置最大重试次数为3次。设置重试间隔为10秒。</li><li style=\"text-align: start; line-height: 2;\">编写请求函数：编写一个函数，用于发送请求并处理返回结果。</li><li style=\"text-align: start; line-height: 2;\">添加重试逻辑：使用循环，执行最大重试次数内的请求尝试。在每次请求之前，使用延迟函数等待重试间隔时间。如果请求成功，立即结束循环并返回结果。如果请求失败且未达到最大重试次数，继续尝试下一次请求。如果请求失败且已达到最大重试次数，抛出异常。</li></ol><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: left; line-height: 2;\">或者利用 setTimeout 和 Promise.race 实现</p><p style=\"text-align: left; line-height: 2;\">（promise.race<span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 14px;\"> 方法的作用是在多个Promise对象中，只要有一个Promise对象率先 fulfilled（已完成）或者 rejected（已拒绝），那么返回的Promise对象就会立即完成。</span>）</p><p style=\"text-align: left; line-height: 2;\"><br><strong>16、说一下你的职业规划【描述】</strong></p><p style=\"text-align: left; line-height: 2;\"><br></p><ol><li style=\"text-align: start; line-height: 2;\">目前的计划还是学习和掌握基本的前端技术，巩固好底层的逻辑知识</li><li style=\"text-align: start; line-height: 2;\">再是不断实践和积累项目经验</li><li style=\"text-align: start; line-height: 2;\">深入学习前端框架及工具：在基础知识扎实的基础上，学习并掌握常用的前端框架和工具，如React、Vue.js、Webpack等。了解它们的工作原理和使用方法，能够应对复杂的前端项目需求。</li><li style=\"text-align: start; line-height: 2;\">关注前端技术发展，前端技术日新月异，持续关注行业动态，阅读优秀的前端博客、参加技术交流活动，跟随社区的最新讨论，保持对前端领域的敏感性，并不断学习和探索新的技术。</li></ol><p style=\"text-align: start; line-height: 2;\"><br></p><h4 style=\"text-align: left; line-height: 2;\">17、对我们公司有什么想了解的吗</h4><p><br></p><p>工作地点，</p><p>转正的考核，</p><p>工作的氛围，大家平时是怎么一起工作的，怎么交流</p><p><br></p><p><br></p><p style=\"text-align: left; line-height: 2;\">转载自 <a href=\"https://www.qinglite.cn/doc/41896476ba8b2ef85\" target=\"_blank\">https://www.qinglite.cn/doc/41896476ba8b2ef85</a> </p><p style=\"text-align: left; line-height: 2;\"><br></p><p style=\"text-align: left; line-height: 2;\"><br></p>', '/public/uploads/2023/06/28/1687943204404552.png', '朴朴三年经验前端面试', '三年经验前端社招面经', '', '面试', 'VUE', '2', '2023-06-28 11:25:25', '2023-06-28 11:25:25', 'D', 2);
INSERT INTO `blog_essay` VALUES (54, '<h3 style=\"line-height: 2;\">http缓存</h3><p style=\"line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">HTTP缓存是一种用于提高Web应用性能的机制，它可以减少网络资源的传输次数，降低延迟，并减轻服务器的负载。</p><p style=\"text-align: start; line-height: 2;\">HTTP缓存的工作原理如下：</p><ol><li style=\"text-align: start; line-height: 2;\">当浏览器或代理服务器第一次请求某个资源时，服务器会返回该资源的完整内容，并在响应头中包含缓存相关的信息，比如Cache-Control、Expires、Last-Modified和ETag等。</li><li style=\"text-align: start; line-height: 2;\">浏览器接收到响应后，将资源缓存到本地，同时保存响应头中的缓存信息。</li><li style=\"text-align: start; line-height: 2;\">当浏览器再次请求该资源时，它会检查本地缓存中是否存在该资源的副本，并且根据缓存策略的配置来决定是否使用缓存。如果缓存有效，则直接使用本地缓存，不再发送请求到服务器。</li><li style=\"text-align: start; line-height: 2;\">如果缓存无效，则浏览器会向服务器发送请求，其中会包含缓存信息，以及其他用于判断资源是否有更新的标识符，比如If-Modified-Since和If-None-Match。</li><li style=\"text-align: start; line-height: 2;\">服务器收到请求后会进行判断，如果资源未发生变化，则返回一个304 Not Modified的响应，告诉浏览器可以使用缓存。如果资源已更新，则返回新的资源内容，并在响应头中包含新的缓存信息。</li><li style=\"text-align: start; line-height: 2;\">浏览器收到响应后，根据响应的情况，更新本地缓存的副本，然后使用新的资源内容。</li></ol><p style=\"text-align: start; line-height: 2;\">HTTP缓存可以根据缓存策略来控制缓存的行为。常见的缓存策略有：</p><ul><li style=\"text-align: start; line-height: 2;\">强缓存：使用Cache-Control和Expires响应头来控制资源的缓存时间，强缓存意味着在缓存有效期内，资源将被直接从缓存中读取，而不与服务器通信。</li><li style=\"text-align: start; line-height: 2;\">协商缓存：使用Last-Modified和ETag响应头来判断资源是否有更新，如果资源未变化，服务器将返回304 Not Modified响应，浏览器将直接使用缓存，减少数据传输。</li></ul><p style=\"text-align: start; line-height: 2;\">HTTP缓存对于提升网页加载速度、减少网络流量和提高用户体验非常重要。开发者可以通过设置适当的缓存策略，控制资源的缓存行为，并在服务器端对响应进行缓存控制，以满足特定需求。</p><p style=\"text-align: start; line-height: 2;\"><br></p><h3 style=\"text-align: start; line-height: 2;\">两个栈实现一个队列</h3><p><br></p><p style=\"text-align: start; line-height: 2;\">使用两个栈实现一个队列的常用思路是将一个栈作为输入栈（用于入队操作），另一个栈作为输出栈（用于出队操作）。当需要进行出队操作时，如果输出栈为空，则将输入栈的元素逐个弹出并压入输出栈，此时输出栈的顶部即为队列的头部元素，可以进行出队操作。</p><p style=\"text-align: start; line-height: 2;\">下面是使用两个栈实现队列的 JavaScript 代码示例：</p><pre style=\"text-align: left;\"><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.inputStack = [];  // 输入栈\n    this.outputStack = [];  // 输出栈\n  }\n\n  enqueue(element) {\n    this.inputStack.push(element);\n  }\n\n  dequeue() {\n    if (this.outputStack.length === 0) {\n      // 将输入栈元素逐个转移到输出栈\n      while (this.inputStack.length &gt; 0) {\n        this.outputStack.push(this.inputStack.pop());\n      }\n    }\n    return this.outputStack.pop();  // 弹出输出栈的顶部元素，即队列的头部元素\n  }\n\n  isEmpty() {\n    return this.inputStack.length === 0 &amp;&amp; this.outputStack.length === 0;\n  }\n\n  size() {\n    return this.inputStack.length + this.outputStack.length;\n  }\n}\n\n</code></pre><p style=\"text-align: start; line-height: 2;\">使用时，可以创建一个队列对象，并使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>enqueue()</code></span> 方法进行入队操作，使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>dequeue()</code></span> 方法进行出队操作，以及使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>isEmpty()</code></span> 方法检查队列是否为空，使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>size()</code></span> 方法获取队列的大小。</p><p style=\"text-align: start; line-height: 2;\">示例用法：</p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code class=\"language-javascript\">const queue = new Queue();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(3);\n\nconsole.log(queue.dequeue());  // 输出：1\nconsole.log(queue.dequeue());  // 输出：2\n\nconsole.log(queue.isEmpty());  // 输出：false\nconsole.log(queue.size());  // 输出：1</code></pre><p><br></p><h3 style=\"text-align: start; line-height: 2;\">两个队列实现一个栈</h3><p style=\"text-align: start; line-height: 2;\">使用两个队列实现一个栈的常用思路是，首先选择一个主队列和一个辅助队列，所有的入栈操作都在主队列上进行。当需要进行出栈操作时，可以将主队列中的元素转移到辅助队列，直到主队列只剩下一个元素，然后将该元素弹出即可。这样可以模拟栈的后进先出（LIFO）特性。</p><p style=\"text-align: start; line-height: 2;\">下面是使用两个队列实现栈的 JavaScript 代码示例：</p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code class=\"language-javascript\">class Stack {\n  constructor() {\n    this.mainQueue = []; // 主队列\n    this.helperQueue = []; // 辅助队列\n  }\n\n  push(element) {\n    this.mainQueue.push(element);\n  }\n\n  pop() {\n    if (this.mainQueue.length === 0) {\n      return null;  // 栈为空，返回 null\n    }\n\n    // 将主队列中的元素转移到辅助队列，直到只剩下一个元素\n    while (this.mainQueue.length &gt; 1) {\n      this.helperQueue.push(this.mainQueue.shift());\n    }\n\n    // 弹出主队列的最后一个元素，即栈顶元素\n    const popped = this.mainQueue.shift();\n\n    // 将辅助队列设置为主队列\n    [this.mainQueue, this.helperQueue] = [this.helperQueue, this.mainQueue];\n\n    return popped;\n  }\n\n  isEmpty() {\n    return this.mainQueue.length === 0;\n  }\n\n  size() {\n    return this.mainQueue.length;\n  }\n}\n\n</code></pre><p style=\"text-align: start; line-height: 2;\">使用时，可以创建一个栈对象，并使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>push()</code></span> 方法进行入栈操作，使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>pop()</code></span> 方法进行出栈操作，使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>isEmpty()</code></span> 方法检查栈是否为空，使用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>size()</code></span> 方法获取栈的大小。</p><p style=\"text-align: start; line-height: 2;\">示例用法：</p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code class=\"language-javascript\">const stack = new Stack();\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nconsole.log(stack.pop());  // 输出：3\nconsole.log(stack.pop());  // 输出：2\n\nconsole.log(stack.isEmpty());  // 输出：false\nconsole.log(stack.size());  // 输出：1\n\n</code></pre><p style=\"text-align: start; line-height: 2;\">使用两个队列实现栈的关键在于出栈操作时的处理，通过辅助队列实现元素转移和栈顶元素弹出，从而实现后进先出的效果</p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">vue router跳转的原理</h3><p><br></p><p style=\"line-height: 2;\"><span style=\"color: rgb(36, 41, 47); background-color: rgb(255, 255, 255); font-size: 16px;\">Vue Router 利用了 BOM 中的 history 对象来实现SPA的路由功能。具体来说，Vue Router 使用了 History API 中的 pushState 方法（或者 replaceState 方法）来改变浏览器的 URL，而不会引起页面的刷新。这样就实现了在单页应用中切换页面而不引起整个页面的重新加载。</span></p><p style=\"line-height: 2;\"><span style=\"font-size: 16px;\">当浏览器的 URL 发生变化时，Vue Router 会根据当前的 URL 匹配到对应的路由配置项，然后将其对应的组件渲染到指定的视图区域中。</span></p><ol><li style=\"line-height: 2;\">在 Vue Router 的配置中，定义各个路由配置项，每个配置项对应一个 URL 路径和一个组件。</li><li style=\"line-height: 2;\">当浏览器的 URL 发生变化时，Vue Router 监听到 URL 变化事件，并根据当前的 URL 路径匹配到对应的路由配置项。</li><li style=\"line-height: 2;\">根据匹配到的路由配置项，Vue Router 渲染对应的组件，并将其渲染到指定的视图区域中。</li><li style=\"line-height: 2;\">视图区域中的组件会随着 URL 的变化而实时更新，实现了页面的无刷新跳转效果。</li></ol><p style=\"line-height: 2;\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAAXNSR0IArs4c6QAAAIFJREFUKFOV0LENwjAQheHfSW36iDYFuwS2iISUJRiCAiZgAKZJyyQvOukcoQQS293Z9+ndOUiKwBFogQ64eM2vE5aXkmqgB25As3xfgdQg6QC8PHV2f4F1SKqAOzAksQm+0Dsl7QJHNt5oO2UBR1fgWQLs9z7ZwFMepeBcCk6lIE4RQize+r7aywAAAABJRU5ErkJggg==\" alt=\"\" data-href=\"\" style=\"width: 5.98958px;height: 5.98958px;\"></p><h3 style=\"line-height: 2;\">vue实现单页面的原理</h3><p style=\"line-height: 2;\"><br></p><p style=\"line-height: 2;\">Vue 实现单页面应用（SPA）的核心原理是利用前端路由和组件化的思想，将应用分解为多个组件，并使用路由配置来管理这些组件之间的跳转和切换。</p><p style=\"line-height: 2;\">下面是 Vue 实现单页面应用的基本原理：</p><ol><li style=\"line-height: 2;\">组件化开发：将应用拆分为多个组件，每个组件负责不同的功能或页面展示。每个组件包含自己的模板、样式和逻辑。</li><li style=\"line-height: 2;\">前端路由配置：使用前端路由库（如 Vue Router）来定义应用的路由配置，即不同 URL 对应的组件。通过配置路由来实现页面的跳转和切换。</li><li style=\"line-height: 2;\">根组件挂载：在 Vue 根实例中，以根组件的形式挂载整个应用。根组件负责渲染应用的布局结构，并提供一个占位符（通常是 &lt;router-view&gt;）用来展示当前路由对应的组件。</li><li style=\"line-height: 2;\">路由导航：当用户在应用中点击链接或触发其他跳转行为时，前端路由拦截并处理该事件，根据配置的路由规则来决定要展示的组件，并更新浏览器的 URL。</li><li style=\"line-height: 2;\">组件渲染：当路由发生变化时，前端路由根据当前的 URL 匹配到对应的路由规则，从而确定要渲染的组件。根组件中的占位符会被匹配的组件渲染取代。</li><li style=\"line-height: 2;\">视图更新：根组件中的占位符被匹配组件取代后，Vue 会自动更新视图，将匹配组件的模板渲染到对应的位置，并执行组件的生命周期钩子函数。</li></ol><p style=\"line-height: 2;\">在单页面应用中，所有的路由跳转操作都是在前端进行的，页面不会刷新。通过前端路由的监听和处理，实现不同页面间的切换和数据的动态加载，给用户带来流畅的交互体验。</p><p style=\"line-height: 2;\">总结来说，Vue 实现单页面应用的原理是利用前端路由和组件化开发的思想，通过路由配置管理组件的跳转和切换，实现页面的无刷新更新和交互。</p><p style=\"text-align: start;\"><br></p><h3 style=\"text-align: start;\">函数柯里化</h3><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">柯里化的基本思想是将一个接受多个参数的函数转换为一系列只接受一个参数的函数，当所有参数都被传入后，才执行原来的函数并返回结果。这种转换过程可以通过函数模板和闭包来实现。</p><p style=\"text-align: start;\">下面是一个简单的例子来说明函数柯里化的概念：</p><p style=\"text-align: start;\"><br></p><pre style=\"text-align: left;\"><code>function multiply(a, b, c) {\n  return a * b * c;\n}\n\n// 使用柯里化转换 multiply 函数\nfunction curriedMultiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    }\n  }\n}\n\n// 使用柯里化后的函数\nconst multiplyBy2 = curriedMultiply(2);\nconst multiplyBy3 = multiplyBy2(3);\n\nconsole.log(multiplyBy3(4)); // 输出 24\n\n</code></pre><p style=\"text-align: start;\">在上面的例子中，我们将原始函数 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>multiply</code></span> 转换为柯里化版本的 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>curriedMultiply</code></span> 函数。通过调用 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>curriedMultiply</code></span> 函数分别传递参数 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>2</code></span> 和 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>3</code></span>，我们得到了一个新的函数 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>multiplyBy3</code></span>，它接受最后一个参数 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>c</code></span>。当我们传递参数 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>4</code></span> 给 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>multiplyBy3</code></span> 函数时，它会执行原始的乘法操作，返回结果 <span style=\"color: rgb(71, 101, 130); background-color: rgba(27, 31, 35, 0.05);\"><code>24</code></span>。</p><p style=\"text-align: start;\">函数柯里化的优势在于可以将一个多参数的函数转换成多个接受单一参数的函数组合使用，这提供了更高的灵活性和可复用性。它常用于函数组合、参数复用和延迟函数执行等场景中，可以帮助简化代码和提升代码的可读性。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '/public/uploads/2023/07/08/1688799772302303.png', '面试-自我总结', '面试总结题目', '面试总结', '面试', 'VUE', '1', '2023-07-08 15:02:52', '2023-07-08 15:02:52', 'U', 1);
INSERT INTO `blog_essay` VALUES (55, '<p><br></p><h3>1. fetch VS ajax VS axios</h3><p><br></p><p>传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始 js 中，核心使用 XMLHttpRequest 对象，多个请求之间如果有先后关系的话，就会出现回调地狱。JQuery ajax 是对原生XHR 的封装</p><p><br></p><p>axios 是一个基于 Promise ，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，</p><p><br></p><p>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest对象。</p><p><br></p><h3>2. React 事件处理—修改 this 指向</h3><p><br></p><p>通过 bind 方法进行原地绑定，从而改变 this 指向</p><p>通过创建箭头函数</p><p>在 constructor 中提前对事件进行绑定</p><p>将事件调用的写法改为箭头函数的形式</p><p><br></p><h3>3. 请简述你对 react 的理解</h3><p><br></p><p>React 起源于 facebook，react 是一个用于构建用户界面的 js 库</p><p><br></p><p>特点：</p><p><br></p><p>声明式设计：react 采用范式声明，开发者只需要声明显示内容，react就会自动完成</p><p>高效： react 通过对 dom 的模拟（也就是虚拟 dom），最大限度的减少与 dom 的交互</p><p>灵活： react 可以和已知的库或者框架很好配合</p><p>组件： 通过 react 构建组件，让代码更容易复用，能够很好应用在大型项目开发中，把页面功能拆分成小模块 每个小模块就是组件</p><p>单向数据流： react 是单向数据流，数据通过 props 从父节点传递到子节点，如果父级的某个 props 改变了，react 会重新渲染所有的子节点</p><p><br></p><h3>4. react 组件之间的数据传递</h3><p><br></p><p>正向传值用 props</p><p>逆向传值用函数传值 通过事件调用函数传递</p><p>同级传值用 pubsub-js</p><p>用 pubsub.publish（事件名，数据）抛出数据</p><p>用 pubsub.subscribe（监听的事件，（）=）{}）接收数据</p><p>跨组件传递 用 context 要使用 context 进行跨组件传值就需要使用createContext()方法，这个方法有两个对象 provider生 产者 Consumer 消费者</p><p><br></p><h3>5. Vue 与 react 区别</h3><p><br></p><p>相同点：</p><p><br></p><p>都支持服务器渲染</p><p>都有虚拟 dom，组件化开发，通过 props 参数进行父子组件数据的传递，都实现 webcomponent 规范都是</p><p>数据驱动视图</p><p>都有状态管理，react 有 redux，vue 有 vuex</p><p>都有支持 native’的方案 react 有 react native vue 有 weex</p><p>不同点：</p><p><br></p><p>react 严格上只针对 mvc 的 view 层，vue 是 mvvm 模式</p><p>虚拟 dom 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个 dom 组件树，而 react 不同，当应用的状态被改变时，全部组件都会重新渲染，所以 react 中用 shouldcomponentupdate 这个生命周期的钩子函数来控制</p><p>组件写法不一样 ，react 是 jsx 和 inline style ，就是把 html 和 CSS 全写进 js 中，vue 则是 html，CSS ，js 在同一个文件</p><p>数据绑定不一样，vue 实现了数据双向绑定，react 数据流动是单向的</p><p>在 react 中，state 对象需要用 setstate 方法更新状态，在 vue 中，state对象不是必须的，数据由 data 属性在 vue 对象中管理</p><p><br></p><h3>6. 请简述虚拟 dom 与 diff 算法</h3><p><br></p><p>虚拟DOM也就是常说的虚拟节点，它是通过js的object对象模拟DOM中的节点，然后再通过特定的渲染方法将其渲染成真实的 DOM 节点。 频繁的操作 DOM，或大量造成页面的重绘和回流</p><p><br></p><p>diff 算法：把树形结构按照层级分解，只比较同级元素，给列表结构的每个单元添加唯一的 key 值，方便比较</p><p><br></p><h3>7. 你对组件的理解</h3><p><br></p><p>可组合，可复用，可维护，可测试</p><p><br></p><h3>8. 调用 setState 之后发生了什么？</h3><p><br></p><p>React 在调用 setstate 后，react 会将传入的参数对象和组件当前的状态合并，触发调和过程</p><p><br></p><p>在调和过程中，react 会根据新的状态构建 react 元素树重新渲染整个UI 界面，在得到元素树之后，react 会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染</p><p><br></p><h3>9. react 生命周期函数</h3><p><br></p><p>componentWillMount 组件渲染之前调用</p><p>componentDidMount 在第一次渲染之后调用</p><p>componentWillReceiveProps 在组件接收到一个新的 props 时调用</p><p>shouldComponentUpdate 判断组件是否更新 html</p><p>componentWillupdate 组件即将更新 html 时调用</p><p>componentDidupdate 在组件完成更新后立即调用</p><p>componentWillUnmount 在组件移除之前调用</p><p>10. 为什么虚拟 dom 会提高性能?(必考)</p><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能</p><p><br></p><h3>11. (组件的)状态(state)和属性(props)之间有何不同</h3><p><br></p><p>State 与 props 区别</p><p><br></p><p>Props 是一个从外部传进组件的参数，主要作用就是父组件向子组件传递数据，但是 props 对于使用它的组件来说是只读的，一旦赋值不能修改，只能通过外部组件主动传入新的 props 来重新渲染子组件</p><p><br></p><p>State 一个组件的显示形态可以由数据状态和外部参数决定，外部参数是props，数据状态就是 state，首先，在组件初始化的时候，用 this.state给组件设定一个初始的 state，在第一次渲染的时候就会用这个数据来渲染组件，state 不同于 props 一点时，state 可以修改，通过 this.setState()方法来修改 state</p><p><br></p><h3>12. shouldComponentUpdate 是做什么的</h3><p><br></p><p>这个 react 生命周期钩子函数是来解决这个问题：</p><p>在更新数据的时候用 setState 修改整个数据，数据变了之后，遍历的时候所有内容都要被重新渲染，数据量少还好，数据量大就会严重影响性能</p><p><br></p><p>解决办法：</p><p><br></p><p>shouldcomponentupdate 在渲染前进行判断组件是否更新，更新了再渲染</p><p>purecomponent（纯组件）省去了虚拟 dom 生成和对比的过程 在类组件中使用</p><p>react.memo() 类似于纯组件 在无状态组件中使用</p><p><br></p><h3>13. react diff 原理</h3><p><br></p><p>它是基于三个策略：</p><p><br></p><p>tree diff web UI 中 dom 节点跨层级的移动操作特别少，可以忽略不计component diff 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件会生成不同的树形结构</p><p><br></p><p>element diff 对于同一层级的一组子节点，他们可以通过唯一的 id 进行区分</p><p><br></p><h3>14. 何为受控组件</h3><p><br></p><p>React 负责渲染表单的组件，值是来自于 state 控制的，输入表单元素称为受控组件</p><p><br></p><h3>15. 调用 super(props) 的目的是什么</h3><p><br></p><p>super()调用父类的构造方法，有 super，组件才有自己的 this，在组件全局中都可以使用 this，如果只是 constructor 而不执行 super，之后的 this 都是错的，super 继承父组件的 this</p><p><br></p><h3>16. React 中构建组件的方式</h3><p><br></p><p>自定义组件：函数组件或者无状态组件 组件首字母大写</p><p><br></p><p>类组件：一个类组件必须实现一个 render 方法，这个方法必须返回一个jsx 元素，要用一个外层的元素把所有内容包裹起来</p><p><br></p><h3>17.简述 flux 思想</h3><p><br></p><p>Flux 的最大特点，就是数据的\"单向流动\"。</p><p><br></p><p>用户访问 View</p><p>View 发出用户的 Action</p><p>Dispatcher 收到 Action，要求 Store进行相应的更新</p><p>Store 更新后，发出一个\"change\"事件</p><p>View 收到\"change\"事件后，更新页面</p><p><br></p><h3>18. React 项目用过什么脚手架？Mern? Yeoman?</h3><p><br></p><p>Mern：MERN 是脚手架的工具，它可以很容易地使用 Mongo, Express, React and NodeJS 生成同构 JS 应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。</p><p><br></p><h3>19. 应该在 React 组件的何处发起 Ajax 请求？</h3><p><br></p><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行， 在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p><p><br></p><h3>20. 何为高阶组件(higher order component)？</h3><p><br></p><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p><p><br></p><p>————————————————</p><p>版权声明：本文为CSDN博主「白酒永远的神」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：https://blog.csdn.net/JKQ8525350/article/details/125039376</p>', '/public/uploads/2023/07/18/168965397565241.jpg', 'react面试', 'react面试', 'react面试', 'react,面试', 'REACT', '2', '2023-07-18 12:20:42', '2023-07-18 12:20:42', 'I', 1);

-- ----------------------------
-- Table structure for blog_record
-- ----------------------------
DROP TABLE IF EXISTS `blog_record`;
CREATE TABLE `blog_record`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `message` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_record
-- ----------------------------
INSERT INTO `blog_record` VALUES (1, '2022-07-05 09:07:42', '2022-07-05 09:07:44', '海滩上的人换了一轮，又一轮。只有灼热的太阳和大海未曾变过。他们不说话，但他们什么都懂了', 'I');
INSERT INTO `blog_record` VALUES (2, '2022-07-05 09:08:12', '2022-07-05 09:08:15', '好好学习，天天向上', 'I');
INSERT INTO `blog_record` VALUES (4, '2022-10-14 20:05:33', '2022-10-14 20:05:33', '微信订餐小程序', 'I');
INSERT INTO `blog_record` VALUES (5, '2023-03-21 18:02:01', '2023-03-21 18:02:01', '最新更新', 'D');
INSERT INTO `blog_record` VALUES (6, '2023-04-27 09:38:05', '2023-04-27 09:38:05', '最新更新--改善页面，删除花里胡哨的页面样式', 'I');
INSERT INTO `blog_record` VALUES (7, '2023-04-28 13:04:04', '2023-04-28 13:04:04', 'unicorn意为独角兽', 'I');
INSERT INTO `blog_record` VALUES (8, '2023-05-09 23:25:50', '2023-05-09 23:25:50', '好忙好忙', 'D');
INSERT INTO `blog_record` VALUES (9, '2023-05-09 23:26:26', '2023-05-09 23:26:26', '太阳会是我融化，但我依然向阳', 'D');
INSERT INTO `blog_record` VALUES (10, '2023-05-24 20:17:40', '2023-05-24 20:17:40', '好好准备面试', 'D');
INSERT INTO `blog_record` VALUES (11, '2023-07-24 17:44:14', '2023-07-24 17:44:14', '今天也要给自己一朵小红花哦', 'I');

-- ----------------------------
-- Table structure for comment_user
-- ----------------------------
DROP TABLE IF EXISTS `comment_user`;
CREATE TABLE `comment_user`  (
  `comment_id` int NOT NULL,
  `user_id` int NOT NULL,
  PRIMARY KEY (`comment_id`, `user_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment_user
-- ----------------------------
INSERT INTO `comment_user` VALUES (35, 36);
INSERT INTO `comment_user` VALUES (36, 36);
INSERT INTO `comment_user` VALUES (37, 8);
INSERT INTO `comment_user` VALUES (38, 37);
INSERT INTO `comment_user` VALUES (47, 36);

-- ----------------------------
-- Table structure for day_img
-- ----------------------------
DROP TABLE IF EXISTS `day_img`;
CREATE TABLE `day_img`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of day_img
-- ----------------------------
INSERT INTO `day_img` VALUES (1, '/public/uploads/main/bg/day01.jpg', NULL, NULL);
INSERT INTO `day_img` VALUES (2, '/public/uploads/main/bg/sunset01.jpg', NULL, NULL);
INSERT INTO `day_img` VALUES (3, '/public/uploads/main/bg/night01.jpg', NULL, NULL);

-- ----------------------------
-- Table structure for default_portrait
-- ----------------------------
DROP TABLE IF EXISTS `default_portrait`;
CREATE TABLE `default_portrait`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of default_portrait
-- ----------------------------
INSERT INTO `default_portrait` VALUES (1, '/public/uploads/2022/08/03/1659524422501607.jpg', '2023-03-19 11:33:48', '2023-03-19 11:33:51');
INSERT INTO `default_portrait` VALUES (2, '/public/uploads/2022/08/03/1659525306960790.jpg', NULL, NULL);
INSERT INTO `default_portrait` VALUES (3, '/public/uploads/2022/08/04/1659575550058157.jpg', NULL, NULL);
INSERT INTO `default_portrait` VALUES (4, '/public/uploads/2022/08/04/1659575588104356.jpg', NULL, NULL);

-- ----------------------------
-- Table structure for essay_comments
-- ----------------------------
DROP TABLE IF EXISTS `essay_comments`;
CREATE TABLE `essay_comments`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `essay_id` int NULL DEFAULT NULL,
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `message` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `essay_id`(`essay_id`) USING BTREE,
  CONSTRAINT `essay_id` FOREIGN KEY (`essay_id`) REFERENCES `blog_essay` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 48 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of essay_comments
-- ----------------------------
INSERT INTO `essay_comments` VALUES (35, 25, '福建省福州市', '哈哈哈', '2023-06-06 17:11:40', '2023-06-06 17:11:40', 'I');
INSERT INTO `essay_comments` VALUES (36, 49, '福建省福州市', 'hhh', '2023-06-06 19:49:04', '2023-06-06 19:49:04', 'I');
INSERT INTO `essay_comments` VALUES (37, 49, '福建省福州市', '傻呗考试\n', '2023-06-08 14:11:47', '2023-06-08 14:11:47', 'U');
INSERT INTO `essay_comments` VALUES (47, 54, '福建省福州市', '111', '2023-07-17 16:11:59', '2023-07-17 16:11:59', 'U');

-- ----------------------------
-- Table structure for essay_detail
-- ----------------------------
DROP TABLE IF EXISTS `essay_detail`;
CREATE TABLE `essay_detail`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `essay_id` int NULL DEFAULT NULL,
  `good` int NULL DEFAULT NULL,
  `collect` int NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `essay_data_id`(`essay_id`) USING BTREE,
  CONSTRAINT `essay_data_id` FOREIGN KEY (`essay_id`) REFERENCES `blog_essay` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 56 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of essay_detail
-- ----------------------------
INSERT INTO `essay_detail` VALUES (21, 25, 3, 7, '2023-04-10 23:28:52', '2023-04-22 15:55:31');
INSERT INTO `essay_detail` VALUES (22, 26, 1, 2, '2023-04-25 14:21:22', '2023-04-25 14:21:22');
INSERT INTO `essay_detail` VALUES (23, 35, 1, 1, '2023-05-11 15:04:39', '2023-05-11 15:04:41');
INSERT INTO `essay_detail` VALUES (24, 36, 2, 1, NULL, NULL);
INSERT INTO `essay_detail` VALUES (25, 32, 4, 2, NULL, NULL);
INSERT INTO `essay_detail` VALUES (26, 48, 0, 1, NULL, NULL);
INSERT INTO `essay_detail` VALUES (27, 52, 1, 1, NULL, NULL);
INSERT INTO `essay_detail` VALUES (28, 34, 2, 1, NULL, NULL);
INSERT INTO `essay_detail` VALUES (55, 54, 1, 1, NULL, NULL);

-- ----------------------------
-- Table structure for home_bg
-- ----------------------------
DROP TABLE IF EXISTS `home_bg`;
CREATE TABLE `home_bg`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of home_bg
-- ----------------------------
INSERT INTO `home_bg` VALUES (1, '/public/uploads/main/bgGif/banner01.gif', NULL, NULL);
INSERT INTO `home_bg` VALUES (2, '/public/uploads/main/bgGif/banner00.gif', NULL, NULL);
INSERT INTO `home_bg` VALUES (3, '/public/uploads/main/bgGif/banner02.gif', NULL, NULL);

-- ----------------------------
-- Table structure for home_bg_now
-- ----------------------------
DROP TABLE IF EXISTS `home_bg_now`;
CREATE TABLE `home_bg_now`  (
  `id` int NOT NULL,
  `bg_id` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of home_bg_now
-- ----------------------------
INSERT INTO `home_bg_now` VALUES (1, 2);

-- ----------------------------
-- Table structure for message
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 100 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES (88, '1', '2023-03-21 16:36:34', '2023-03-21 16:36:34', '福建省福州市', 'I');
INSERT INTO `message` VALUES (89, '哈哈哈', '2023-03-21 17:39:14', '2023-03-21 17:39:14', '福建省福州市', 'I');
INSERT INTO `message` VALUES (90, '111', '2023-03-21 17:40:16', '2023-03-21 17:40:16', '福建省福州市', 'I');
INSERT INTO `message` VALUES (91, '555', '2023-03-21 17:42:12', '2023-03-21 17:42:12', '福建省福州市', 'I');
INSERT INTO `message` VALUES (92, '5224', '2023-03-21 17:44:34', '2023-03-21 17:44:34', '福建省福州市', 'I');
INSERT INTO `message` VALUES (93, '555', '2023-03-21 17:45:20', '2023-03-21 17:45:20', '福建省福州市', 'I');
INSERT INTO `message` VALUES (94, '156', '2023-03-21 17:57:43', '2023-03-21 17:57:43', '福建省福州市', 'I');
INSERT INTO `message` VALUES (96, 'Map对象用于保存键值对，任何值JavaScript支持的值都可以作为一个键（key）或者一个值（value）。\n与对象不同的是\n\nobject的键只能是字符串或ES6的symbol值，而Map可以是任何值。\nMap对象有一个size属性，存储了键值对的个数，而object对象没有类似属性。\n😀', '2023-05-31 17:41:47', '2023-05-31 17:41:47', '福建省福州市', 'I');
INSERT INTO `message` VALUES (97, '哈哈哈', '2023-05-31 17:52:35', '2023-05-31 17:52:35', '福建省福州市', 'I');
INSERT INTO `message` VALUES (98, '你在干什么', '2023-06-26 16:39:29', '2023-06-26 16:39:29', '福建省福州市', 'I');
INSERT INTO `message` VALUES (99, 'bug:点赞和收藏为0的文章点收藏时有效果，但收藏数未增加，查看egg-server和数据库查看是否添加该文章的详情数据。初步判断数据库未添加文章详情数据，只添加了用户详情数据😇', '2023-07-17 16:19:54', '2023-07-17 16:19:54', '福建省福州市', 'I');

-- ----------------------------
-- Table structure for message_reply
-- ----------------------------
DROP TABLE IF EXISTS `message_reply`;
CREATE TABLE `message_reply`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `message_id` int NULL DEFAULT NULL,
  `reply` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `reply_message_id`(`message_id`) USING BTREE,
  CONSTRAINT `reply_comment_id` FOREIGN KEY (`message_id`) REFERENCES `message` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of message_reply
-- ----------------------------
INSERT INTO `message_reply` VALUES (4, 90, '555', '2023-03-21 17:43:46', '2023-03-21 17:43:46', 'I');
INSERT INTO `message_reply` VALUES (6, 93, '哈哈哈哈哈哈', '2023-05-20 21:12:43', '2023-05-20 21:12:43', 'I');
INSERT INTO `message_reply` VALUES (9, 94, '哈哈哈', '2023-05-21 10:49:14', '2023-05-21 10:49:14', 'I');
INSERT INTO `message_reply` VALUES (10, 99, '111', '2023-07-27 16:42:37', '2023-07-27 16:42:37', 'I');

-- ----------------------------
-- Table structure for message_user
-- ----------------------------
DROP TABLE IF EXISTS `message_user`;
CREATE TABLE `message_user`  (
  `message_id` int NOT NULL,
  `user_id` int NOT NULL,
  PRIMARY KEY (`message_id`, `user_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of message_user
-- ----------------------------
INSERT INTO `message_user` VALUES (88, 8);
INSERT INTO `message_user` VALUES (89, 8);
INSERT INTO `message_user` VALUES (90, 36);
INSERT INTO `message_user` VALUES (91, 36);
INSERT INTO `message_user` VALUES (92, 8);
INSERT INTO `message_user` VALUES (93, 8);
INSERT INTO `message_user` VALUES (94, 8);
INSERT INTO `message_user` VALUES (96, 36);
INSERT INTO `message_user` VALUES (97, 36);
INSERT INTO `message_user` VALUES (98, 8);
INSERT INTO `message_user` VALUES (99, 37);

-- ----------------------------
-- Table structure for project
-- ----------------------------
DROP TABLE IF EXISTS `project`;
CREATE TABLE `project`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `coverUrl` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `upt_act` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `state` int NULL DEFAULT NULL COMMENT '1为发布，2为不发布',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of project
-- ----------------------------
INSERT INTO `project` VALUES (1, '欧美特卫浴', '前台：http:116.62.179.162:666\n\n\n后台：http:116.62.179.162:777\n', '/public/uploads/2023/05/23/1684851373316407.jpg', '<p>大二时期写的一个项目，包括前台和后台，后端</p><p><br></p><p>项目成员共三个人，我为组长</p><p><br></p><p>前台主要功能：</p><p>展示卫浴轮播图；</p><p>根据赞的获取数量展示销售榜单；</p><p>通过分类查找需要的卫浴图片；</p><p><br></p><p>后台主要功能：</p><p>对轮播图增删改查；</p><p>对产品增删改查；</p><p>在产品中添加畅销榜单；</p><p><br></p><p>主要难点与解决方案：</p><p>头部组件的制作：如何在变化路由时控制下划线的位置，移至二级菜单时，下划线不能移动等等</p><p><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/09/1686288165111137.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"/></p><p>解决：通过watch监听重新初始化</p><p><br></p><p>后台图片预览：当图片上传后不能直接传到服务器，而是先预览，在确定新增或修改等操作后，再调用接口</p><p>解决方案：：</p><pre><code class=\"language-javascript\">      // 创建一个读取对象\n      var reader = new FileReader();\n      // 将文件转化为一个二进制字符串\n      reader.readAsArrayBuffer(file.raw);\n      // 监听文件读取完成\n      reader.onload = (e) =&gt; {\n      // 监听完成后，将二进制字符串转化为Blob对象，并且通过URL.createObjectURL创建一个url，指向该Blob对象\n      let data = window.URL.createObjectURL(new Blob([e.target.result]));\n      // 将生成的url赋值给需要预览的url\n      this.imgurl = data;</code></pre><p><br></p>', 'U', '2023-05-14 22:55:30', '2023-05-14 22:55:32', 1);
INSERT INTO `project` VALUES (2, 'blog网站', '前台：http://116.62.179.162\n\n后台：http://116.62.179.162:81 用户账号(admin,888888)\n\ngithub源码：https://github.com/xielinchang/personal-blog', '/public/uploads/2023/04/21/1682061056437239.png', '<p>一个简易博客网站</p><p><br></p><p>网站制作初心只是为了自己对前后端开发的学习，提高自身的技术能力，主要的功能如下：</p><p><br></p><ol><li style=\"text-align: start; line-height: 2;\">内容发布功能：博客最核心的功能是能够让用户发布和管理自己的文章内容。</li><li style=\"text-align: start; line-height: 2;\">评论功能：让用户在文章下方进行评论，与其他读者互动、讨论。</li><li style=\"text-align: start; line-height: 2;\">分类功能：主要以领域划分，以自身的技术栈展开划分，分html，css，js，vue，node，其他。（开发中）</li><li style=\"text-align: start; line-height: 2;\">收藏功能：让读者可以查看喜欢的文章。</li><li style=\"text-align: start; line-height: 2;\">搜索功能：提供一个搜索框让读者可以搜索相关的文章和内容。</li><li style=\"text-align: start; line-height: 2;\">分享功能：提供多种分享方式，让读者可以把自己喜欢的文章分享给自己的社交网络和好友。</li><li style=\"text-align: start; line-height: 2;\">自定义主题功能：可以让用户根据自己的喜好，自定义博客的风格和样式。</li><li style=\"text-align: start; line-height: 2;\">数据统计功能：可以让用户了解博客的流量、访问来源、用户行为等数据信息，方便用户优化博客和改进写作。（开发中）</li><li style=\"text-align: start; line-height: 2;\">管理功能：管理员账户可以帮助博主管理自己的发布、评论等操作。</li></ol><p style=\"text-align: start; line-height: 2;\"><br></p><p style=\"text-align: start; line-height: 2;\">项目难点：</p><p style=\"text-align: start; line-height: 2;\"><br></p><ol><li style=\"text-align: start; line-height: 2;\">界面和用户体验：博客需要具备良好的界面设计和用户体验，能让用户方便、快捷地浏览和使用博客。</li></ol><p style=\"text-align: start; line-height: 2;\">如何解决：<span style=\"color: rgb(36, 41, 47); font-size: 14px;\">使用媒体查询等等做页面优化，兼容。</span></p><p style=\"text-align: start; line-height: 2;\">2. &nbsp;数据库设计和安全管理：博客需要有一个结构化、高效、安全的数据库管理系统，用于保存和处理博客的各种数据信息。</p><p style=\"text-align: start; line-height: 2;\">如何解决：首先一个jwt权限管理，输入框的文字长度限制等等</p><p style=\"text-align: start; line-height: 2;\">3. &nbsp;性能优化：制作之初，页面访问卡顿</p><p style=\"text-align: start; line-height: 2;\">如何解决：删除不必要的dom操作，图片懒加载，</p><p style=\"text-align: start; line-height: 2;\">4. &nbsp;后台动态路由的实现</p><p style=\"text-align: start; line-height: 2;\">如何解决：</p><ol><li style=\"text-align: start; line-height: 2;\">让每个用户有自己的菜单数组，通过管理用户的菜单数组对其页面的访问进行控制</li></ol><p style=\"text-align: start; line-height: 2;\">2. &nbsp;实现动态路由生成：在 Vue Router 实例化时，通过后台接口请求返回的用户权限列表，根据权限列表动态生成路由，可以使用 addRoutes 方法。</p><p style=\"text-align: start; line-height: 2;\">5. &nbsp;权限管理：每个角色对应不同的权限</p><p style=\"text-align: start; line-height: 2;\">如何解决：</p><p style=\"text-align: start; line-height: 2;\">首先是数据库设计分三个表，角色用户列表，角色列表，用户列表，每个用户都对应着一个角色，每个角色又有对应的menu列表，通过更改角色对应的menu列表每个页面的状态来控制角色对他的权限。</p><p style=\"text-align: start; line-height: 2;\"><br></p><p><br></p>', 'U', '2023-05-17 23:13:42', '2023-05-17 23:13:45', 1);
INSERT INTO `project` VALUES (3, 'vue3+ts+vitepress组件库', 'github：https://github.com/xielinchang/demo-ui\n\n测试网站：http://116.62.179.162:88\n\n由于组件未上传npm，文档站引用的是测试组件，还未部署。具体可下载源码打开docs文件夹所在目录执行yarn docs:dev命令查看', '/public/uploads/2023/05/23/1684852666864368.png', '<p style=\"line-height: 2;\">2023寒假期间字节青训营写的vue3组件库，包括各类常用组件以及文档站的编写，由于写的人数不多且有些人对vue3不熟悉，所以组件数和功能性不全，</p><p style=\"line-height: 2;\">以下是文档站的一些截图</p><h3 style=\"line-height: 2;\">截图：</h3><h3 style=\"line-height: 2;\"><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/29/1687968256147104.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></h3><p style=\"line-height: 2;\"><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/29/1687968281557269.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></p><p style=\"line-height: 2;\"><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/29/1687968327654768.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></p><p style=\"line-height: 2;\"><img src=\"http://116.62.179.162:7001/public/uploads/2023/06/29/1687968354094430.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\"></p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">主要组件：</h3><p style=\"line-height: 2;\">返回顶部，按钮，卡片，计数器, &nbsp;对话框，icon图标，消息框，分页，选择下拉框， 消息提示，tooltip提示。</p><p style=\"line-height: 2;\"><br></p><h3 style=\"line-height: 2;\">主要难点：</h3><p style=\"line-height: 2;\">消息框和消息的挂载：这边示例消息的挂载和位置计算</p><p style=\"line-height: 2;\">vue3：</p><pre><code class=\"language-javascript\">// 创建根元素\nfunction createRootDom() {\n  const div = document.createElement(\'div\');\n  div.setAttribute(\'id\', prefixCls);\n  return document.body.appendChild(div);\n}\n\n// 在屏幕上展示 message 组件\nfunction showMessage(app: App) {\n  // 查找根元素\n  let rootDom = document.getElementById(prefixCls);\n  if (!rootDom) {\n    // 如果根元素不存在，创建一个新的根元素\n    rootDom = createRootDom();\n  }\n</code></pre><p style=\"line-height: 2;\">vue2:(参考elementUI中message组件源码)</p><pre><code class=\"language-javascript\">  instance = new MessageConstructor({\n    data: options\n  })\n  instance.id = id\n  //挂载实例\n  instance.$mount()\n  //添加元素\n  document.body.appendChild(instance.$el)\n  //设置默认高度\n  let verticalOffset = options.offset || 30\n  //多个消息同时出现时计算遍历高度，使之不重合\n  instances.forEach(item =&gt; {\n    verticalOffset += item.$el.offsetHeight + 16\n  })\n  instance.verticalOffset = verticalOffset\n  instance.visible = true\n  instances.push(instance)\n  return instance\n}\n//消息关闭\nMessage.close = function(id, userOnClose) {\n  const len = instances.length\n  let index = -1\n  let removedHeight\n  for (let i = 0; i &lt; len; i++) {\n    if (id === instances[i].id) {\n      removedHeight = instances[i].$el.offsetHeight\n      index = i\n      if (typeof userOnClose === \'function\') {\n        userOnClose(instances[i])\n      }\n      instances.splice(i, 1)\n      break\n    }\n  }\n  if (len &lt;= 1 || index === -1 || index &gt; instances.length - 1) return\n  for (let i = index; i &lt; len - 1; i++) {\n    const dom = instances[i].$el\n    dom.style[\'top\'] =\n        parseInt(dom.style[\'top\'], 10) - removedHeight - 16 + \'px\'\n  }\n}\n// 最后在main.js\nimport msg from \'组件路径\'\nVue.prototype.$msg = msg // 注册消息事件</code></pre><p style=\"line-height: 2;\">tooltip位置的计算:</p><pre><code class=\"language-javascript\">  function getStyle() {\n    // 获取tooltipRef的DOM矩形，若存在则执行下面的代码块\n    const tooltipRect = tooltipRef.value?.getBoundingClientRect();\n    if (tooltipRect) {\n      // 从props中获取弹出框的方向信息，比如top、right、bottom、left等\n      const direction = props.placement;\n      // 如果方向是top或bottom\n      if ([\'top\', \'bottom\'].includes(direction)) {\n        // 计算内容的垂直偏移距离 使tooltip移出元素为  元素本身高度再+10的箭头高度\n        const value = tooltipRect.height + 10;\n        const y = direction === \'top\' ? -value : value;\n        // 设置contentStyle对象的transform属性，使内容沿Y轴平移\n        contentStyle.value = {\n          transform: `translate(-50%, ${y}px)`,\n        };\n      } else {\n        // 否则方向为left或right\n        // 计算内容的水平偏移距离\n        const value = tooltipRect.width + 10;\n        const x = direction === \'left\' ? -value : value;\n        // 设置contentStyle对象的transform属性，使内容沿X轴平移\n        contentStyle.value = {\n          transform: `translate(${x}px, -50%)`,\n        };\n      }\n    }\n  }</code></pre><p style=\"line-height: 2;\">拖拽对话框:</p><pre><code class=\"language-javascript\">  // 记录元素偏离原位置的距离\n  let transform = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n\n  const onMousedown = (e: MouseEvent) =&gt; {\n    // 获取鼠标当前坐标 因为translate是相对原位置移动\n    const downX = e.clientX;\n    const downY = e.clientY;\n    const { offsetX, offsetY } = transform;\n\n    // 我们确信这个字段100%出现，那么就可以添加！，强调这个字段一定存在,！可以强制链式调用。\n    const targetRect = targetRef.value!.getBoundingClientRect();\n    // 获取元素相对可视区域的位置\n    const targetLeft = targetRect.left;\n    const targetTop = targetRect.top;\n    // 获取元素的宽高\n    const targetWidth = targetRect.width;\n    const targetHeight = targetRect.height;\n\n    // 获取可见区域的宽高\n    const clientWidth = document.documentElement.clientWidth;\n    const clientHeight = document.documentElement.clientHeight;\n\n    // translate可以移动的边界情况 表示x y轴可以移动的最大范围\n    // 注意这些边界情况也是相对原位置的所以要加上offsetX\n    // 其实就是没移动前第一次获取到的targetLeft这些属性。\n    const minLeft = -targetLeft + offsetX;\n    const minTop = -targetTop + offsetY;\n    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;\n    const maxTop = clientHeight - targetTop - targetHeight + offsetY;\n\n    // 鼠标移动事件\n    const onMousemove = (e: MouseEvent) =&gt; {\n      // 获取鼠标偏离原位置距离= 已偏离位置+新移动位置\n      const moveX = Math.min(Math.max(offsetX + e.clientX - downX, minLeft), maxLeft);\n      const moveY = Math.min(Math.max(offsetY + e.clientY - downY, minTop), maxTop);\n\n      transform = {\n        offsetX: moveX,\n        offsetY: moveY,\n      };\n      // 利用translate移动元素\n      targetRef.value!.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;\n    };\n\n    // 鼠标松开事件\n    const onMouseup = () =&gt; {\n      document.removeEventListener(\'mousemove\', onMousemove);\n      document.removeEventListener(\'mouseup\', onMouseup);\n    };\n\n    // 点下鼠标 开始监听 鼠标移动与松开事件\n    document.addEventListener(\'mousemove\', onMousemove);\n    document.addEventListener(\'mouseup\', onMouseup);\n  };\n\n  const onDraggable = () =&gt; {\n    if (dragRef.value && targetRef.value) {\n      dragRef.value.addEventListener(\'mousedown\', onMousedown);\n    }\n  };\n\n  const offDraggable = () =&gt; {\n    if (dragRef.value && targetRef.value) {\n      dragRef.value.removeEventListener(\'mousedown\', onMousedown);\n    }\n  };\n  onMounted(() =&gt; {\n    if (draggable.value) {\n      onDraggable();\n    } else {\n      offDraggable();\n    }\n  });\n</code></pre><p style=\"line-height: 2;\">分页器的...位置计算</p><pre><code class=\"language-javascript\">// 计算分页按钮总数的中间位置\r\n      const center = Math.ceil(props.pageCount / 2);\r\n      // 当前页处于靠近首页的位置\r\n      if (props.currentPage &gt;= 1 && props.currentPage &lt;= center) {\r\n        let firstList = [];\r\n        if (props.pageCount == 1) {\r\n          firstList.push(1);\r\n        } else {\r\n          for (let i = 0; i &lt;= props.pageCount; i++) {\r\n            if (i &lt; props.pageCount - 1) {\r\n              firstList.push(1 + i);\r\n            } else if (i == props.pageCount - 1) {\r\n              firstList.push(\'...\');\r\n            } else {\r\n              firstList.push(pageTotal.value);\r\n            }\r\n          }\r\n        }\r\n        return firstList;\r\n      } else if (\r\n        props.currentPage &lt;= pageTotal.value &&\r\n        props.currentPage &gt;= pageTotal.value - center + 1\r\n      ) {\r\n        // 当前页处于靠近尾页的位置\r\n        let firstList = [];\r\n        if (props.pageCount == 1) {\r\n          firstList.push(pageTotal.value);\r\n        } else {\r\n          for (let i = props.pageCount; props.pageCount &gt;= i && i &gt;= 0; i--) {\r\n            if (i &gt; props.pageCount - 1) {\r\n              firstList.push(1);\r\n            } else if (i == props.pageCount - 1) {\r\n              firstList.push(\'...\');\r\n            } else {\r\n              firstList.push(pageTotal.value - i);\r\n            }\r\n          }\r\n        }\r\n        return firstList;\r\n      } else {\r\n        // 当前页处于中间页的位置\r\n        let firstList = [];\r\n        firstList.push(1);\r\n        firstList.push(\'...\');\r\n        let justCenter = Math.ceil((props.pageCount - 2) / 2);\r\n        for (let i = 1; i &lt;= props.pageCount - 2; i++) {\r\n          if (i &lt; justCenter) {\r\n            firstList.push(props.currentPage - (justCenter - i));\r\n          } else if (i == justCenter) {\r\n            firstList.push(props.currentPage);\r\n          } else {\r\n            firstList.push(props.currentPage + (i - justCenter));\r\n          }\r\n        }\r\n        firstList.push(\'...\');\r\n        firstList.push(pageTotal.value);\r\n        return firstList;\r\n      }</code></pre><h3 style=\"line-height: 2;\">项目心得：</h3><p style=\"line-height: 2;\">之前没有接触过vue3，这是第一次接触vue3，所以学到了vue3与vue2不同之处，对setup语法糖有了基础的认知，对组件封装，挂载，原型等有了新的认识，自己也用vue2仿照该项目进行练习。</p><p style=\"line-height: 2;\">了解了vitepress文档站，认识和学习了文档站的基础配置和如何书写文档站。</p>', 'U', '2023-05-14 22:55:30', '2023-05-14 22:55:32', 1);
INSERT INTO `project` VALUES (4, '', '', '', '<p> hhh</p>', 'D', '2023-05-14 22:55:30', '2023-05-14 22:55:32', 1);

-- ----------------------------
-- Table structure for record_default
-- ----------------------------
DROP TABLE IF EXISTS `record_default`;
CREATE TABLE `record_default`  (
  `id` int NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of record_default
-- ----------------------------
INSERT INTO `record_default` VALUES (1, '爱尔兰语Coisíní，翻译过来意为“怦然心动”', 'Coisíní', '/public/uploads/2023/05/09/1683646933795721.jpg', '2023-03-23 14:49:47', '2023-05-09 23:45:16');

-- ----------------------------
-- Table structure for save_essay
-- ----------------------------
DROP TABLE IF EXISTS `save_essay`;
CREATE TABLE `save_essay`  (
  `id` int NOT NULL,
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `coverUrl` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `subtitle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `digest` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '每个标签按逗号分开',
  `domain` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `radio` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '1表示原创，2表示转载',
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of save_essay
-- ----------------------------
INSERT INTO `save_essay` VALUES (0, '<p>fetch的使用</p><pre><code class=\"language-javascript\">fetch( `/api1/search/users2?q=${keyword}`).then(\nresponse =&gt; {\nconsole.log(\'联系服务器成功了\");\nreturn response.json()\nerror =&gt; {\nconsole.log(\'联系服务器失败了\" ,error);\nreturn new Promise(()=&gt;{})\n)\n).then(\nresponse =&gt; {console.log(\'获取数据成功了\',response);},\nerror =&gt; {console.log(\'获取数据火败了 \' ,error);}\n)\n)</code></pre><p><br></p>', '', '', '', '', '', 'REACT', '1', '2022-07-04 19:49:39', '2023-05-09 11:24:55');

-- ----------------------------
-- Table structure for save_project
-- ----------------------------
DROP TABLE IF EXISTS `save_project`;
CREATE TABLE `save_project`  (
  `id` int NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `coverUrl` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `upt_act` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of save_project
-- ----------------------------
INSERT INTO `save_project` VALUES (1, '', '', '', '<p> </p>', 'U', '2023-05-14 22:55:30', '2023-05-14 22:55:32');

-- ----------------------------
-- Table structure for sys_dict
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict`;
CREATE TABLE `sys_dict`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '字典类型',
  `label` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '注释',
  `value` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '值',
  `state` int NULL DEFAULT 1 COMMENT '1正常0停用',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_dict
-- ----------------------------
INSERT INTO `sys_dict` VALUES (1, 'direction', 'Java', '1', 1);
INSERT INTO `sys_dict` VALUES (2, 'direction', 'JavaScript', '2', 0);
INSERT INTO `sys_dict` VALUES (3, 'direction', 'C', '3', 0);
INSERT INTO `sys_dict` VALUES (4, 'sex', '男', '1', 1);
INSERT INTO `sys_dict` VALUES (5, 'sex', '女', '2', 1);
INSERT INTO `sys_dict` VALUES (6, 'sex', '保密', '0', 1);

-- ----------------------------
-- Table structure for sys_dict_type
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict_type`;
CREATE TABLE `sys_dict_type`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `dict_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '字典名称',
  `dict_type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '字典类型',
  `state` int NULL DEFAULT NULL COMMENT '状态',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_dict_type
-- ----------------------------
INSERT INTO `sys_dict_type` VALUES (1, '方向', 'direction', 1, NULL);
INSERT INTO `sys_dict_type` VALUES (2, '性别', 'sex', 1, NULL);

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '物理主键',
  `path` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '路径',
  `component` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '组件路径',
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '组件标识',
  `meta_title` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '菜单标题',
  `meta_icon` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '菜单图标',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `parent_id` int NULL DEFAULT NULL COMMENT '父菜单ID',
  `hidden` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '(0显示，1隐藏)',
  `keep_alive` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '(0不缓存，1缓存)',
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '数据状态（I插入 D删除 U更新）',
  `created_id` int NULL DEFAULT NULL COMMENT '创建人ID',
  `created_at` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `updated_id` int NULL DEFAULT NULL COMMENT '更新人ID',
  `updated_at` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 81 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '系统菜单表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, '/sys', 'Layout', 'sys', '系统管理', 'set', 2, 0, '0', '0', 'I', NULL, NULL, NULL, NULL);
INSERT INTO `sys_menu` VALUES (2, '/sys/user', 'sys/User', 'User', '用户管理', 'user', 3, 1, '0', '1', 'U', NULL, NULL, 36, '2021-04-01 10:38:52');
INSERT INTO `sys_menu` VALUES (3, '/sys/role', 'sys/Role', 'Role', '角色管理', 'role', 4, 1, '0', '1', 'U', NULL, NULL, 36, '2022-03-18 10:55:57');
INSERT INTO `sys_menu` VALUES (4, '/sys/menu', 'sys/Menu', 'Menu', '菜单管理', 'menu', 5, 1, '0', '1', 'I', NULL, NULL, NULL, NULL);
INSERT INTO `sys_menu` VALUES (5, '/', 'Layout', 'home', '首页', 'home', 0, 0, '0', '0', 'I', NULL, NULL, NULL, NULL);
INSERT INTO `sys_menu` VALUES (6, '/', 'index/Index', 'Home', '首页', 'home', 1, 5, '0', '0', 'I', NULL, NULL, NULL, NULL);
INSERT INTO `sys_menu` VALUES (56, '/sys/dict', 'sys/Dict', 'Dict', '字典管理', 'course', 9, 1, '0', '0', 'U', 36, '2022-07-14 16:28:40', 36, '2022-07-15 14:41:13');
INSERT INTO `sys_menu` VALUES (57, '/sys/dict/detail', 'sys/DictDetail', 'DictDetail', '字典详情', 'course', 9, 1, '1', '0', 'U', 36, '2022-07-15 15:41:06', 36, '2022-07-20 15:03:52');
INSERT INTO `sys_menu` VALUES (64, '/blog', 'Layout', 'Blog', '博客管理', 'home', 9, 0, '0', '0', 'U', 36, '2023-05-20 10:32:07', 36, '2023-05-20 12:23:57');
INSERT INTO `sys_menu` VALUES (65, '/blog/essay', 'blog', 'Essay', '文章管理', 'course', 9, 64, '0', '0', 'D', 36, '2023-05-20 10:34:45', 36, '2023-05-20 12:24:49');
INSERT INTO `sys_menu` VALUES (66, '/blog/message', 'blog/Message', 'Message', '留言管理', 'record', 9, 64, '0', '0', 'U', 36, '2023-05-20 10:37:40', 36, '2023-05-20 12:09:31');
INSERT INTO `sys_menu` VALUES (67, '/blog/aboutme', 'blog/Aboutme', 'Aboutme', '关于我管理', 'role', 9, 64, '0', '0', 'U', 36, '2023-05-20 10:38:43', 36, '2023-05-20 12:09:37');
INSERT INTO `sys_menu` VALUES (68, '/blog/user', 'blog/User', 'User', '前台用户管理', 'user', 9, 64, '0', '0', 'U', 36, '2023-05-20 10:39:38', 36, '2023-05-20 12:09:44');
INSERT INTO `sys_menu` VALUES (69, '/blog/project', '/blog/project', 'Project', '项目管理', 'class', 9, 64, '0', '0', 'D', 36, '2023-05-20 10:41:15', 36, '2023-05-20 10:43:41');
INSERT INTO `sys_menu` VALUES (70, '/blog/record', 'blog/Record', 'Record', '记录管理', 'record', 9, 64, '0', '0', 'U', 36, '2023-05-20 10:43:24', 36, '2023-05-20 12:09:49');
INSERT INTO `sys_menu` VALUES (71, '/blog/essay/control', 'blog/Essay/Control', 'Control', '管理', 'role', 9, 65, '0', '0', 'U', 36, '2023-05-20 11:58:12', 36, '2023-05-20 12:05:08');
INSERT INTO `sys_menu` VALUES (72, '/blog/essay/writing', 'blog/Essay/Writing', 'Writing', '添加文章', 'add', 9, 65, '0', '0', 'U', 36, '2023-05-20 11:59:08', 36, '2023-05-20 12:07:34');
INSERT INTO `sys_menu` VALUES (73, '/blog/essay', 'Layout', 'Essay', '文章管理', 'course', 9, 0, '0', '0', 'U', 36, '2023-05-20 12:25:49', 36, '2023-05-20 12:27:28');
INSERT INTO `sys_menu` VALUES (74, '/blog/essay/control', 'essay/Control', 'EssayControl', '文章管理', 'role', 9, 73, '0', '0', 'U', 36, '2023-05-20 12:26:32', 36, '2023-06-01 00:15:32');
INSERT INTO `sys_menu` VALUES (75, '/blog/essay/writing', 'essay/Writing', 'EssayWriting', '添加/编辑(文章)', 'add', 9, 73, '0', '0', 'U', 36, '2023-05-20 12:27:21', 36, '2023-06-20 11:14:07');
INSERT INTO `sys_menu` VALUES (76, '/blog/project', 'Layout', 'Project', '项目管理', 'class', 9, 0, '0', '0', 'I', NULL, '2023-05-21 23:20:38', NULL, '2023-05-21 23:20:38');
INSERT INTO `sys_menu` VALUES (77, '/blog/project/control', 'project/Control', 'ProjectControl', '项目管理', 'role', 9, 76, '0', '0', 'U', NULL, '2023-05-21 23:21:31', NULL, '2023-06-01 00:15:45');
INSERT INTO `sys_menu` VALUES (78, '/blog/project/writing', 'project/Writing', 'ProjectWriting', '编辑/添加(项目)', 'add', 9, 76, '0', '0', 'U', NULL, '2023-05-21 23:22:05', NULL, '2023-06-20 11:14:25');
INSERT INTO `sys_menu` VALUES (79, '/blog/essay/edit', 'essay/Writing', 'EssayEdit', '编辑', 'edit', 9, 73, '1', '0', 'D', NULL, '2023-06-07 15:43:51', NULL, '2023-06-07 15:48:40');
INSERT INTO `sys_menu` VALUES (80, '/blog/bg', 'blog/Bg', 'Bg', '背景管理', 'list', 9, 64, '0', '0', 'I', NULL, '2023-06-16 18:17:47', NULL, '2023-06-16 18:17:47');

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '物理主键',
  `name` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '角色名称',
  `code` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '角色代码',
  `sort` int NULL DEFAULT NULL COMMENT '排序',
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '数据状态（I插入 D删除 U更新）',
  `created_at` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `created_id` int NULL DEFAULT NULL COMMENT '创建人ID',
  `updated_at` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `updated_id` int NULL DEFAULT NULL COMMENT '更新人ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '系统角色表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, '超级管理员', 'ADMIN', 1, 'I', '2020-12-07 16:08:19', 1, '2020-12-07 16:08:22', 1);
INSERT INTO `sys_role` VALUES (10, '普通管理员', 'USER', 2, 'I', '2023-05-28 17:10:00', NULL, '2023-05-28 17:10:00', NULL);

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` int NOT NULL COMMENT '角色ID',
  `menu_id` int NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '系统【角色】【菜单】表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (1, 1);
INSERT INTO `sys_role_menu` VALUES (1, 2);
INSERT INTO `sys_role_menu` VALUES (1, 3);
INSERT INTO `sys_role_menu` VALUES (1, 4);
INSERT INTO `sys_role_menu` VALUES (1, 5);
INSERT INTO `sys_role_menu` VALUES (1, 6);
INSERT INTO `sys_role_menu` VALUES (1, 56);
INSERT INTO `sys_role_menu` VALUES (1, 57);
INSERT INTO `sys_role_menu` VALUES (1, 64);
INSERT INTO `sys_role_menu` VALUES (1, 66);
INSERT INTO `sys_role_menu` VALUES (1, 67);
INSERT INTO `sys_role_menu` VALUES (1, 68);
INSERT INTO `sys_role_menu` VALUES (1, 70);
INSERT INTO `sys_role_menu` VALUES (1, 73);
INSERT INTO `sys_role_menu` VALUES (1, 74);
INSERT INTO `sys_role_menu` VALUES (1, 75);
INSERT INTO `sys_role_menu` VALUES (1, 76);
INSERT INTO `sys_role_menu` VALUES (1, 77);
INSERT INTO `sys_role_menu` VALUES (1, 78);
INSERT INTO `sys_role_menu` VALUES (1, 80);
INSERT INTO `sys_role_menu` VALUES (10, 64);
INSERT INTO `sys_role_menu` VALUES (10, 66);
INSERT INTO `sys_role_menu` VALUES (10, 67);
INSERT INTO `sys_role_menu` VALUES (10, 68);
INSERT INTO `sys_role_menu` VALUES (10, 70);
INSERT INTO `sys_role_menu` VALUES (10, 73);
INSERT INTO `sys_role_menu` VALUES (10, 74);
INSERT INTO `sys_role_menu` VALUES (10, 75);
INSERT INTO `sys_role_menu` VALUES (10, 76);
INSERT INTO `sys_role_menu` VALUES (10, 77);
INSERT INTO `sys_role_menu` VALUES (10, 78);
INSERT INTO `sys_role_menu` VALUES (10, 80);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '物理主键',
  `username` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '账号',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '姓名',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '密码',
  `sex` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '性别',
  `phone` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '电话',
  `upt_act` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '数据状态（I插入 D删除 U更新）',
  `created_id` int NULL DEFAULT NULL COMMENT '创建人ID',
  `created_at` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `updated_id` int NULL DEFAULT NULL COMMENT '更新人ID',
  `updated_at` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 49 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '系统用户表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (36, 'admin', '超级管理员', '743c4d81b35239313001ae8e8a142acc', '1', '123456', 'U', 31, '2020-12-17 15:07:35', 36, '2022-03-18 09:34:21');
INSERT INTO `sys_user` VALUES (48, 'yonghu1', '用户1', '743c4d81b35239313001ae8e8a142acc', '1', '15860128125', 'I', NULL, '2023-05-28 17:10:47', NULL, '2023-05-28 17:10:47');

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `user_id` int NOT NULL COMMENT '用户ID',
  `role_id` int NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '系统【用户】【角色】关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (36, 1);
INSERT INTO `sys_user_role` VALUES (48, 10);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `portrait` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (8, '123456', '743c4d81b35239313001ae8e8a142acc', '我要路过你了', '2022-09-27 14:56:36', '2023-08-29 17:01:11', '/public/uploads/2023/04/21/1682061056437239.png', 'U');
INSERT INTO `user` VALUES (36, 'yonghu1', '743c4d81b35239313001ae8e8a142acc', '用户1', '2023-05-17 11:01:36', '2023-07-03 14:11:21', '/public/uploads/2022/08/03/1659525306960790.jpg', 'U');
INSERT INTO `user` VALUES (37, 'yonghu2', '743c4d81b35239313001ae8e8a142acc', '用户2', '2023-05-17 21:16:51', '2023-07-03 14:11:25', '/public/uploads/2022/08/03/1659524422501607.jpg', 'U');
INSERT INTO `user` VALUES (38, '1312084035', '743c4d81b35239313001ae8e8a142acc', '二月廿三', '2023-06-07 23:19:06', '2023-07-03 14:16:53', '/public/uploads/2022/08/03/1659525306960790.jpg', 'U');
INSERT INTO `user` VALUES (39, '666666', 'b9e79361b4040a3f3a71668163d2f058ntihcbRbx1mnFKKW38ZI7hoBMKbe35Me', '66', '2023-07-03 13:55:13', '2023-07-03 13:55:13', '/public/uploads/2022/08/04/1659575550058157.jpg', 'D');
INSERT INTO `user` VALUES (40, '777777', '743c4d81b35239313001ae8e8a142acc', '777', '2023-07-03 14:00:03', '2023-07-03 14:16:49', '/public/uploads/2022/08/04/1659575550058157.jpg', 'U');

-- ----------------------------
-- Table structure for user_detail
-- ----------------------------
DROP TABLE IF EXISTS `user_detail`;
CREATE TABLE `user_detail`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL,
  `collect` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '收藏的文章id，以‘，’隔开',
  `created_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL,
  `good` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `upt_act` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  CONSTRAINT `user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_detail
-- ----------------------------
INSERT INTO `user_detail` VALUES (4, 8, '25,35,32', '2023-03-23 14:27:23', '2023-04-25 14:21:22', '32', 'I');
INSERT INTO `user_detail` VALUES (5, 36, '32,48,52,25,34', NULL, NULL, '36,52,34,25,54,54,54,32,34', 'I');
INSERT INTO `user_detail` VALUES (6, 37, '26,54,36,25', NULL, NULL, '54,54,36,54,25', NULL);

SET FOREIGN_KEY_CHECKS = 1;
